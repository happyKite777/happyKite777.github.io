<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>MySQL索引及其优化 | HappyKite777的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 索引的类型哈希索引&amp;emsp;哈希索引为索引列计算一个哈希值，然后存放在一个哈希表中。如果哈希值相同，则以链表的形式连接。  哈希索引数据未排序，因此做区间查询的速度慢，且无法用于order by 哈希索引对于数据读取特别快，但只适用于等值查询的场景，比如Memory引擎 如果哈希冲突很多，索引维护代价高  B-Tree索引&amp;emsp;&amp;emsp;最常用的索引，大多数MySQL引擎支持B-T">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL索引及其优化">
<meta property="og:url" content="http://example.com/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="HappyKite777的博客">
<meta property="og:description" content="1. 索引的类型哈希索引&amp;emsp;哈希索引为索引列计算一个哈希值，然后存放在一个哈希表中。如果哈希值相同，则以链表的形式连接。  哈希索引数据未排序，因此做区间查询的速度慢，且无法用于order by 哈希索引对于数据读取特别快，但只适用于等值查询的场景，比如Memory引擎 如果哈希冲突很多，索引维护代价高  B-Tree索引&amp;emsp;&amp;emsp;最常用的索引，大多数MySQL引擎支持B-T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/39bb332f3420ad4aeff72ecc1ee7f58c/xmlnote/WEBRESOURCEeaac64d29be16f22c5dbe9dde8da5926/18609">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9iVVJQamdGcEdNVDl5Z2dQc2Zkcktad1pjZkEwZmliaWM2Uk5ZeDdaWkpYZVN1bDVZRnp1TmZmT2JHOG9ZSUk0d21hTWZkd1pERGtyY2RvaWM0aDJuYWcwdy82NDA?x-oss-process=image/format,png">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg">
<meta property="article:published_time" content="2020-09-25T11:42:55.944Z">
<meta property="article:modified_time" content="2020-09-25T11:54:18.479Z">
<meta property="article:author" content="happyKite777">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png">
  
    <link rel="alternate" href="/atom.xml" title="HappyKite777的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HappyKite777的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MySQL索引及其优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2020-09-25T11:42:55.944Z" itemprop="datePublished">2020-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MySQL索引及其优化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-索引的类型"><a href="#1-索引的类型" class="headerlink" title="1. 索引的类型"></a>1. 索引的类型</h1><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>&emsp;哈希索引为索引列计算一个哈希值，然后存放在一个哈希表中。如果哈希值相同，则以链表的形式连接。<br><img src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" alt="image"></p>
<ul>
<li>哈希索引数据未排序，因此做区间查询的速度慢，且无法用于order by</li>
<li>哈希索引对于数据读取特别快，但只适用于等值查询的场景，比如Memory引擎</li>
<li>如果哈希冲突很多，索引维护代价高</li>
</ul>
<h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>&emsp;&emsp;最常用的索引，大多数MySQL引擎支持B-Tree索引（Archive引擎不支持任何索引），虽然名字叫B-Tree索引，但不同的引擎内部有自己的实现方式，比如NDB集群引擎内部使用B-Tree结构存储数据，而InnDB使用B+Tree结构。</p>
<html>
<center>
<img src='https://note.youdao.com/yws/public/resource/39bb332f3420ad4aeff72ecc1ee7f58c/xmlnote/WEBRESOURCEeaac64d29be16f22c5dbe9dde8da5926/18609'></img>
<h4>InnoDB 索引结构</h4>
</center>
关于<a target="_blank" rel="noopener" href='https://blog.csdn.net/qq_26222859/article/details/80631121'>B+树</a>
</html>

<p>&emsp;&emsp;二叉搜索树是查询效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>&emsp;&emsp;你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p>
<p>&emsp;&emsp;二分查找每一次搜索就是一次IO，如果想减少IO操作，必须把树变矮，存储数据不变，则每个节点变多，也就是N叉树（B+树的阶）。“N”取决于数据块的大小。</p>
<p>&emsp;&emsp;以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<hr>
<h1 id="2-普通索引和唯一索引"><a href="#2-普通索引和唯一索引" class="headerlink" title="2. 普通索引和唯一索引"></a>2. 普通索引和唯一索引</h1><p>索引按照类型区分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通索引：仅加速查询</span><br><span class="line">唯一索引：加速查询 + 列值唯一（可以有null）</span><br><span class="line">主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</span><br><span class="line">组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</span><br><span class="line">全文索引：对文本的内容进行分词，进行搜索</span><br></pre></td></tr></table></figure>
<ul>
<li>普通索引和唯一索引如何选择？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当数据页更新时，如果这个数据页还没有在内存中的话，</span><br><span class="line">在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中。</span><br><span class="line">当下次访问这个数据页的时候，会将change buffer持久化到磁盘。</span><br><span class="line"></span><br><span class="line">记录要更新的目标页在内存中：</span><br><span class="line">对于唯一索引来说，找到合适的位置，判断到没有冲突，插入这个值，语句执行结束；</span><br><span class="line">对于普通索引来说，找到合适的位置，插入这个值，语句执行结束。</span><br><span class="line"></span><br><span class="line">记录要更新的目标页不在内存中：</span><br><span class="line">对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</span><br><span class="line">对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</span><br></pre></td></tr></table></figure>
综上，尽量选择普通索引，如果有唯一性需求，在业务代码中做判断。</li>
</ul>
<p>ps.索引合并，使用多个单列索引组合搜索</p>
<hr>
<h1 id="3-InnoDB索引模型"><a href="#3-InnoDB索引模型" class="headerlink" title="3. InnoDB索引模型"></a>3. InnoDB索引模型</h1><h2 id="主键索引（聚簇索引）和非主键索引（二级索引）"><a href="#主键索引（聚簇索引）和非主键索引（二级索引）" class="headerlink" title="主键索引（聚簇索引）和非主键索引（二级索引）"></a>主键索引（聚簇索引）和非主键索引（二级索引）</h2><p>假设有以下表T，id为主键，k建索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">  id int primary key, </span><br><span class="line">  k int not null, </span><br><span class="line">  name varchar(16),</span><br><span class="line">  index (k)</span><br><span class="line">)engine&#x3D;InnoDB;</span><br></pre></td></tr></table></figure>
<p>那么将会对应2颗索引树主键索引和非主键索引，如下图。<br><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="image"></p>
<ul>
<li>主键索引的叶子节点存的是==整行数据==。在InnoDB里，主键索引也被称为==聚簇索引==（clustered index）。</li>
<li>非主键索引的叶子节点内容是==主键的值==。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</span><br><span class="line">如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</span><br></pre></td></tr></table></figure>
<p>==基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。==</p>
<p>对于InnDB，如果建表时候没有指定pk，会判断是否有非空的唯一索引，如果有则该列为主键，如果没有会自动创建一个Rowid做主键。</p>
<h2 id="主键如何选择"><a href="#主键如何选择" class="headerlink" title="主键如何选择"></a>主键如何选择</h2><p>主键可以采用自增也可以以业务字段（比如身份证号）做主键。</p>
<ul>
<li>从性能上看，以业务字段做主键无法保证有序插入，这样使得写数据的成本变高。</li>
<li>从存储空间的角度来看，每个非主键索引的叶子节点上都是主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</li>
</ul>
<p>==显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。==</p>
<p>当业务需求，表中只有一个索引，且为唯一索引时，适合使用业务字段做主键。</p>
<h1 id="4-索引优化策略"><a href="#4-索引优化策略" class="headerlink" title="4. 索引优化策略"></a>4. 索引优化策略</h1><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>&emsp;&emsp;上述例子，如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为==覆盖索引==。</p>
<html>
<p style="color:red;">&emsp;&emsp;由<b>于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</b></p>
</html>

<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>前缀索引就是只给列的前n个字符建立索引。通常适合在大字段上建立前缀索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_dispatch_citys add key(en_name(n))</span><br></pre></td></tr></table></figure>
<ul>
<li>n如何选择？  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择性 &#x3D; 基数 &#x2F; 记录总数,   （1&#x2F;T  ~  1）</span><br></pre></td></tr></table></figure>
选择性要足够大，唯一索引的选择性为1，是最好的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">1</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r1,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">2</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r2,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">3</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r3,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">4</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r4,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">5</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r5,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">6</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r6,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">7</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r7,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">8</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r8,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(en_name, <span class="number">20</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> r9</span><br><span class="line"><span class="keyword">from</span> <span class="string">`t_dispatch_citys`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试结果</span></span><br><span class="line"><span class="comment">#   r1	 r2		  r3	  r4	  r5	  r6	  r7	  r8	</span></span><br><span class="line"><span class="comment"># 0.094	0.1865	0.4966	0.7416	0.9011	0.9730	0.9888	0.9910</span></span><br><span class="line"><span class="comment"># 当n=6的时候，选择性已经97%了。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>MySQL不支持后缀索引，但是可以采用曲线方式，后缀索引=reverse(前缀)</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引即在多个字段上建索引，联合索引也符合“最左前缀原则”。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where a&#x3D;? and b&#x3D;?</span><br></pre></td></tr></table></figure>
<p>如果分别在a、b上建索引，则mysql会采用using intersect交集算法。对所有使用的索引执行同步扫描，并生成从合并索引扫描中接收到的行序列的交集。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9iVVJQamdGcEdNVDl5Z2dQc2Zkcktad1pjZkEwZmliaWM2Uk5ZeDdaWkpYZVN1bDVZRnp1TmZmT2JHOG9ZSUk0d21hTWZkd1pERGtyY2RvaWM0aDJuYWcwdy82NDA?x-oss-process=image/format,png" alt="image"></p>
<ul>
<li>联合索引如何排序？<blockquote>
<p>如果通过调整顺序，可以少维护一个索引，则优先考虑该顺序。<br>如果仅仅只是选择这一个索引，则选择性高的字段排前面。</p>
</blockquote>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    a  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    b  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    c  <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    d <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">index</span> (a, b, c)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>, a <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> c = <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以上sql还是会命中索引，where虽然不符合最左前缀原则，但是id和a字段都在联合索引上，优化器会对比遍历主键索引树和联合索引树的代价，发现联合索引更快，于是会命中。</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>
<p>MySQL5.6以前是这样走的<br><img src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="image"><br>MySQL5.6推出了索引下推策略，是这样走的，减少了回表的次数<br><img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/" data-id="ckfi6q4vq0000juxxbzkd8751" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/">MySQL索引及其优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 happyKite777<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>