

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/happy.jpg">
  <link rel="icon" type="image/png" href="/img/happy.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="happyKite777">
  <meta name="keywords" content="">
  <title>类加载机制 - HappyKite777的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"happykite777.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":100,"cursorChar":"...","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>HappyKite777的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="类加载机制">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-29 15:04" pubdate>
        2020年10月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      76
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">类加载机制</h1>
            
            <div class="markdown-body">
              <h2 id="1、类加载机制概述"><a href="#1、类加载机制概述" class="headerlink" title="1、类加载机制概述"></a>1、类加载机制概述</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTMyMzMwNjgyLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="java虚拟机的结构图简图"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTQ1MzIxMjIyLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="java虚拟机的结构图详细图"><br>&emsp;java虚拟机的结构图如上所示，从详细图可以看出，字节码文件首先会被类加载器子系统加载到内存中，类加载器的工作分为三步：<strong>加载、链接和初始化</strong>。加载需要加载器，比如引导加载器、扩展加载器和应用加载器等。链接环节分为验证、准备、解析三个步骤，最后是初始化。文件被加载到内存中，内存中又分为不同区域。之后解释器和JIT即时编译器会把字节码翻译成成机器指令。当内存使用完毕后，GC收集器会对内存区域进行回收。</p>
<p>&emsp;从上图可以看出，如果自己手写虚拟机，需要考虑  <strong>类加载器</strong> 和 <strong>执行引擎</strong>。类加载是虚拟机极其重要的一个过程。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MDgxODEzNDA5LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="类加载器子系统"></p>
<p>&emsp;class文件中描述了各种信息，这些信息需要被加载到虚拟机之后才能被运行和使用。java虚拟机吧描述类的数据从Class文件加载到内存，并对其进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称作虚拟机的类加载机制。<br>&emsp;java语言里面，类型的加载、连接和初始化实在程序运行期间完成的，而不是像某些语言一样，在编译阶段就完成了。这种策略虽然让提前编译多些困难，也让类加载稍微增加了性能开销，但是却为java应用提高了极高的扩展性和灵活性。<strong>java的动态扩展特性就是依赖于运行期动态加载和动态链接特点实现的。</strong>比如Applet、JSP和OSGI等技术，都依赖于运行期动态加载才实现。</p>
<h2 id="2、类加载的时机"><a href="#2、类加载的时机" class="headerlink" title="2、类加载的时机"></a>2、类加载的时机</h2><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3278574594,735796484&fm=26&gp=0.jpg" srcset="/img/loading.gif" alt="类的生命周期"></p>
<p>&emsp;一个类型（类或接口）从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备和解析被统称为连接（Linking）。<br>&emsp;其中加载、验证、准备、初始化和卸载顺序是确定的，类加载必须按照此顺序开始，而解析则不一定，某些情况下它可以在初始化之后再开始（比如动态绑定时）。<br>&emsp;虚拟机规范明确规定了以下6种情况必须立即对类进行初始化。如果类型没有进行过初始化，则必须进行类的加载、验证、准备和初始化。</p>
<ul>
<li>遇到new、getstatic、putstatic和invokestatic 4条字节码指令。即实例化对象（new），读取静态字段和调用静态方法时。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化类时发现父类还没初始化过，则必须先初始化父类</li>
<li>虚拟机启动时，需要执行主类（main），虚拟机会先初始化主类。</li>
<li>jdk7新加的动态语言支持，如果java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_newInvokeStatic和REF_newInvokeSpecial四种类型的方法句柄，且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>jdk8新加入的默认方法（default修饰的接口方法）。如果接口的实现类发生了初始化，则该接口必须先被初始化。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>hk7<span class="token punctuation">.</span>memory</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadingSuper</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"super"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> val <span class="token operator">=</span> <span class="token string">"JVM"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadingTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">LoadingSuper</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoadingSuper</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;以上代码并不会输出super，是因为以上代码并没有触发LoadingSuper类的初始化阶段，但是它出发了[Lcom.hk7.memory.LoadingSuper初始化，数组的定义是由newarray指令触发的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoadingTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">LoadingSuper</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;依旧不会输出super，因为以上代码也没有触发LoadingSuper类的初始化阶段。虽然确实引用了LoadingSuper类的常量，但是实际上，在编译阶段，由于常量传播优化，此常量的值”JVM“已经被存储在NotInitialization类中了。编译之后LoadingTest直接引用的是NotInitialization类，因此LoadingSuper并不会被初始化。</p>
<p>&emsp;对于接口的类初始化，区别在于以上第3种，接口初始化时不必初始化父类，父类只有被使用到才会初始化。</p>
<h2 id="3、类加载过程"><a href="#3、类加载过程" class="headerlink" title="3、类加载过程"></a>3、类加载过程</h2><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>&emsp;加载是类加载第一个阶段，这一阶段，jvm需要完成以下三件事：</p>
<ul>
<li>通过一个类的全限定（比如java.lang.Integer）名来获取定义此类的二进制字节流。</li>
<li>将获取到的字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<p>&emsp;需要注意，类的二进制字节流文件不仅仅从磁盘加载，还可以从网络、数据库、压缩包或者运行时计算生成等。</p>
<ul>
<li><p>非数组类型的加载阶段，可以使用jvm内置的引导类加载器来完成，也可以使用自定义的类加载去完成。</p>
</li>
<li><p>对于数组类不通过类加载创建，而是jvm直接在内存中构造出来的。但是数组类的元素类型最终还是依靠类加载器来完成加载，它的创建规则如下：</p>
<ul>
<li>如果数组组件类型为引用类型，则递归的采用本节定义的加载过程加载组件类型。数组会被标识在该类加载的类名称空间上。</li>
<li>如果是直接类型，则把数组C标记为与引导类加载器关联。</li>
<li>数组类的可访问性和它的组件类型可访问性一致，如果不是引用类型，则为public。</li>
</ul>
</li>
</ul>
<p>&emsp;加载阶段结束后，二进制字节流就按照虚拟机所规定的格式存储在方法区里面了，方法区中的数据结构由虚拟机实现自行定义。类型数据妥善安置在方法区之后，会在java堆内存中实例化一个java.lang.Class类对象，这个对象是程序访问方法区中类型数据的外部接口。</p>
<h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>&emsp;验证是一个很重要的阶段，必须确保class文件中的数据全都符合虚拟机规范，保证不会危害到虚拟机自身安全。验证阶段决定了虚拟机是否能承受恶意代码的攻击，在性能和代码量来说，占了类加载很大的比重。验证的东西特别多，主要分为文件格式验证、元数据验证、字节码验证和符号引用验证四种。</p>
<blockquote>
<p>文件格式验证</p>
</blockquote>
<p>&emsp;主要是验证class文件的格式是否符合虚拟机规范。比如是否0xCAFEBABE开头，版本号是否合理、常量池类型等。具体可看类文件结构分析。验证通过后字节流才被允许存储在jvm内存的方法区中。后面的阶段均基于方法区进行，不会再读取字节流。</p>
<blockquote>
<p>元数据验证</p>
</blockquote>
<p>&emsp;对字节码描述的信息进行语义分析。比如类是否有父类、是否继承了不被允许继承的类、类中的方法字段等是否和父类产生矛盾等。</p>
<blockquote>
<p>字节码验证</p>
</blockquote>
<p>&emsp;最复杂的验证，主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。元数据校验之后，这部分是对类的方法体（Class文件中的Code属性）进行校验。保证方法被运行时不会危害虚拟机。比如</p>
<ul>
<li><p>任意时刻操作数栈的数据类型和指令序列能操作的数据类型一致。比如iload  —  long不可。</p>
</li>
<li><p>任何跳转指令不会跳到方法体以外的字节码指令上。</p>
</li>
<li><p>方法体中的类型转换合法。比如Pig转Animal可，Pig转Food不可。</p>
<p>……</p>
</li>
</ul>
<p>&emsp;由于字节码验证复杂性很高，为了避免验证阶段耗费过多时间，jdk6之后的javac编译器进行了优化，把大量的辅助验证挪到javac编译器里进行。具体是：给方法体的Code属性属性表中新增了一块”StackMapTable“的新属性，该属性描述了方法的所有基本块开始时的本地变量表和操作栈应有的状态。在字节码验证阶段，只验证StackMapTable的合理性。这样就将类型推导变为了类型检查，大大节省时间。推导的过程编译时验证。</p>
<blockquote>
<p>符号引用验证</p>
</blockquote>
<p>&emsp;解析时，虚拟机会将符号引用转化为直接引用，这时需要对符号引用进行验证。验证内容为</p>
<ul>
<li><p>符号引用中通过字符的全限定名是否可以找到对应的类</p>
</li>
<li><p>指定类中是否存在符合方法的字段描述符以及简单名所描述的方法和字段</p>
</li>
<li><p>符号引用中的类、字段、方法的可访问性是否可被当前类访问</p>
<p>……</p>
</li>
</ul>
<p>&emsp;符号引用验证目的是确保解析能够正常执行。如果验证不通过，则会抛出java.lang.IncompatibleClassChangeError的子异常。</p>
<h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p>&emsp;准备阶段正式为类中定义的<strong>静态变量</strong>分配内存并设置零值。在JDK7及其之前，HotSpot使用永久代来实现方法区，内存分配在方法区上进行。JDK8及其之后，类变量会随着Class对象一起存放在Java堆中。</p>
<p>&emsp;准备阶段只是为类变量赋值，而且是赋零值。实例变量会随着对象的实例化和对象一起被分配在java堆中。比如<code>public static int val = 123</code>，准备阶段之后，val的值为0。给val赋值123的putstatic指令是程序编译后，存放在构造器clinit()方法中，因此真正赋值的动作要到类的初始化阶段才会被执行。java基本数据类型的零值如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int   		0
long  		0L
short 		(short)0
char  		&#39;\u0000&#39;
byte		(byte)0
boolean		false
float 		0.0f
double		0.0d
reference	null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;一般而言，准备阶段会给类变量赋零值，但是也有例外。<strong>如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段类变量会被初始化为ConstantValue属性所指定的初始值</strong>。比如<code>public static final int val=123</code>，编译时javac会为val生成ConstantValue属性，在准备阶段虚拟机会把val赋值为123。</p>
<h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>&emsp;该阶段主要工作：<strong>java虚拟机将常量池内的符号引用替换为直接引用</strong>。</p>
<ul>
<li>符号引用：用一组符号描述所引用的目标，比如Class文件中的CONSTANT_Class_info等常量。符号引用与虚拟机内存布局无关，引用的目标并不一定必须加载到内存中。</li>
<li>直接引用：可以直接执行目标的指针、相对偏移量或者是一个能简介定位到目标的句柄。直接引用和虚拟机实现的内存布局直接相关。</li>
</ul>
<p>&emsp;比如有以下代码，当加载A.class文件时，b.f()这一段代码块以符号的形式存在（比如f），标识这个地方引用的不是实际内存中存在的地址，这个叫符号引用。链接的时候，所有jvm会把所有f符号引用的代码块替换为实际内存地址，这个叫直接引用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	b<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;《java虚拟机规范》没有规定解析发生的具体时间，但是以下执行以下指令之前，必须对符号引用进行解析。以下指令有个共同点，都需要操作内存，因此在此之前必须完成解析。</p>
<pre class="line-numbers language-none"><code class="language-none">anewarray                       &#x2F;&#x2F;创建新数组
checkcast                       &#x2F;&#x2F;检查数组属性
getfield												&#x2F;&#x2F;访问实例变量
getstatic												&#x2F;&#x2F;访问类变量
instanceof											&#x2F;&#x2F;判断类类型
invokedynamic										&#x2F;&#x2F;动态调用方法
invokeinterface									&#x2F;&#x2F;调用由接口实现的方法
invokespecial								  	&#x2F;&#x2F;根据编译时类型来调用实例方法
invokestatic										&#x2F;&#x2F;调用命名类中的静态方法
invokevirtual										&#x2F;&#x2F;调度对象的实例方法
ldc															&#x2F;&#x2F;加载常量到操作数栈
ldc_w														&#x2F;&#x2F;加载常量到操作数栈
ldc2_w													&#x2F;&#x2F;加载常量到操作数栈
multianewarray									&#x2F;&#x2F;创建新多维数组
new															&#x2F;&#x2F;创建实例
putfield												&#x2F;&#x2F;设置实例变量的值
putstatic												&#x2F;&#x2F;设置类变量的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c710f7f62ad">https://www.jianshu.com/p/3c710f7f62ad</a></p>
<p>&emsp;虚拟机的实现可以根据需求自行判断，类被加载前就对常量池中的符号引用进行解析，还是等到符号引用将要被使用前才去解析它。</p>
<p>&emsp;同一个符号被多处引用，则会进行都次解析，除了invokedynamic指令，其他的指令第一次解析符号时，虚拟机会把解析结果缓存起来，后续再次解析符号时，会从缓存中直接读取。<strong>invokedynamic指令用于动态支持，必须程序运行到该条指令时，才会进行解析过程。</strong></p>
<blockquote>
<p>类或接口的解析</p>
</blockquote>
<p>&emsp;假设当前代码所处类为D，第一次解析符号引用N，将其解析为类或者接口C的直接饮用，步骤如下：</p>
<ol>
<li>C不是数组类型，虚拟机会N的全限定名传递给D的类加载器，D的类加载器会加载类C。过程中由于加载验证，可能会触发其他相关类的加载。</li>
<li>C是数组类型，且元素类型为对象，N的描述符类似于<code>[Ljava/lang/Integer</code>的形式，则按照规则1加载数组的元素类型，比如需要加载的元素类型为java.lang.Integre，虚拟机会生成一个代表该数组维度和元素的数组对象。</li>
<li>上述1和2正常加载后，C在虚拟机中实际上已经成为一个有效的类或者接口了，但是还需要进行符号引用验证，即验证D是否具备对C的访问权限。权限不符合会报java.lang.IllegalAccessError异常。</li>
</ol>
<p>&emsp;字段解析、方法解析、接口方法解析很简单，主要是解析符号，按照顺序层层解析，具体的解析例子可以看上一篇文章，类文件结构中的例子。</p>
<h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>&emsp;初始化时类加载过程的最后一个步骤，初始化阶段，虚拟机会根据程序员主观计划去初始化变量和其他资源，即执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法不是直接在java代码中定义的，而是javac编译器生成的。</p>
<p>&emsp;<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，收集顺序是和语句在代码中的顺序一致，<strong>静态语句块中只能访问到静态语句块之前的变量，之后的变量，可以赋值，但不能访问</strong>。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
  i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                  <span class="token comment">//正常编译通过</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//报错，Illegal forward reference</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;由于父类的<code>&lt;clinit&gt;()</code>方法先执行，因此父类中定义的静态语句块优先于子类的变量赋值操作。java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法类型肯定是java.lang.Object。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Parent</span><span class="token operator">:</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token class-name">Child</span><span class="token operator">:</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token class-name">A</span><span class="token punctuation">;</span> <span class="token comment">//在B赋值前，A的值已经被赋值为2</span>

<span class="token class-name">Main</span><span class="token operator">:</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Sub</span><span class="token punctuation">.</span><span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;<code>&lt;clinit&gt;()</code>方法对于类或接口来说非必须，如果类中无static{}，没有类似static int = 1代码，也没有构造方法，则编译不会生成clinit方法。多线程环境中，只会有一个线程去执行这个类的clinit方法，其他线程会阻塞直至clinit执行结束。</p>
<h2 id="4、类加载器"><a href="#4、类加载器" class="headerlink" title="4、类加载器"></a>4、类加载器</h2><h3 id="4-1-类和类加载器"><a href="#4-1-类和类加载器" class="headerlink" title="4.1 类和类加载器"></a>4.1 类和类加载器</h3><p>&emsp;类加载器用于实现类的加载工作。类由类本身和加载它的类加载器来确定唯一性，同一个class文件被同一个虚拟机加载，但是如果加载他们的加载器不同，则这2个类不就不相等。比如以下例子，一个是由虚拟机的应用程序类加载器加载，一个是由自定义加载器加载，虽然来自同一个class文件com.hk7.memory.ClassLoadingTest.class，但java虚拟机中同时存在2个com.hk7.memory.ClassLoadingTest类，其instanceof结果不一致。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span> <span class="token punctuation">&#123;</span>
  <span class="token class-name">ClassLoader</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> fileName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>
        <span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> is<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>is<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>

    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  <span class="token class-name">Object</span> obj <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.hk7.memory.ClassLoadingTest"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//class com.hk7.memory.ClassLoadingTest</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">ClassLoadingTest</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="4-1-双亲委派机制"><a href="#4-1-双亲委派机制" class="headerlink" title="4.1 双亲委派机制"></a>4.1 双亲委派机制</h3><p>&emsp;类加载器除了能用来加载类，还能用来作为类的层次划分。Java自身提供了3种类加载器：</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)：属于虚拟机自身的一部分，用C++实现，负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录中或被-Xbootclasspath指定的路径中的并<strong>且文件名是被虚拟机识别</strong>的文件。自己放进去的类无法被加载。</li>
<li>扩展类加载器(Extension ClassLoader)：java实现，独立于虚拟机。主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中或被java.ext.dirs系统变量所指定的路径的类库。</li>
<li>应用程序类加载器(Application ClassLoader)：java实现，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器，那它就是我们程序中的默认加载器。</li>
</ul>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605693998967&di=50d862ec9c7975e89fb3497c632504c6&imgtype=0&src=http://img-blog.csdnimg.cn/img_convert/18ea18c886353f393e9c501b7ac6f4e9.png" srcset="/img/loading.gif" alt="双亲委派模型"></p>
<p>&emsp;上图就类加载的双亲委派模型。如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。双亲委派的实现及其简单：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">synchronized</span> <span class="token class-name">Class</span> loadClass<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span>
  <span class="token comment">//先判断class是否已经被加载过了</span>
  <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//找父类去加载</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//没父类说明是顶层了就用Bootstrap ClassLoader去加载</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// ClassNotFoundException thrown if class not found</span>
      <span class="token comment">// from the non-null parent class loader</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// If still not found, then invoke findClass in order</span>
      <span class="token comment">// to find the class.</span>
      <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//最后如果没找到，那就自己自家</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;<strong>双亲委派机制使得类之间具有了优先级的层次关系，可以保证java体系的基础行为的正确性</strong>。比如，类java.lang.Object，它存放于<code>&lt;JAVA_HOME&gt;\lib</code>的rt.jar之中，无论哪一个加载器加载该类，最后都是委派给Bootstrap ClassLoader加载，因此Object类在程序的各个加载环境之中都是同一个类。如果不遵循双亲委派机制，由各个加载器自行加载，如果有不法分子自行构造java.lang.Object类，嵌入了危害代码，那么构造的Object类会被加载进虚拟机，会导致虚拟机中各个Object类不一致，甚至会导致整个应用程序崩溃，因此为了保证程序的争取运行，推荐使用双亲委派机制。双亲委派机制中，自行编写的基础类，可以被编译，但无法被加载运行。</p>
<h3 id="4-1-破坏双亲委派机制"><a href="#4-1-破坏双亲委派机制" class="headerlink" title="4.1 破坏双亲委派机制"></a>4.1 破坏双亲委派机制</h3><p>&emsp;<strong>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。</strong>有时也可能违背双亲委派机制，比如JDBC。</p>
<p>&emsp;我们知道SPI，它不同于API，是由各个厂商实现的，java只需要定义SPI的标准，mysql有mysql的jdbc实现，oracle有oracle的jdbc实现，只需遵循标准，java就能调动数据库。JDBC的实现必须违背双亲委派机制，因为遵循的话Boostrap ClassLoader无法自行加载各个厂商的类，只能委托子类来加载厂商提供的具体实现。为了解决这个问题，java设计团队引入了<strong>线程上下文类加载器</strong>（Thread Context ClassLoader）。</p>
<p>&emsp;这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果线程创建时还未设置，会从父类线程中继承一个，如果应用程序的全局范围内都没有设置过，这个类加载默认就是应用程序类加载器。java中涉及到SPI的加载基本都是使用该方式完成，比如JDBC、JNDI、JCE、JAXB和SPA等。但这种方式不太优雅，jdk6提供了java.util.ServiceLoader类，结合META-INF/services中的配置信息，辅以责任链模式来解决。</p>
<p>&emsp;再比如商家对动态部署的需求，比如OSGI的模块坏热部署，使得双亲委派机制被打破。OSGI热部署的关键是它自定义的类加载器实现，每一个程序模块都有自己的类加载器，当需要更坏模块时，把模块和类加载器一起换掉以实现代码的热替换。</p>
<h2 id="5、Java模块化系统"><a href="#5、Java模块化系统" class="headerlink" title="5、Java模块化系统"></a>5、Java模块化系统</h2><p>&emsp;为了实现<strong>可配置的封装隔离机制</strong>，JDK引入了Java模块化系统（Java Platform Module System，JPMS）。java虚拟机对类加载架构也做了响应的变动调整。Java模块包括以下内容（类似于modejs的包的概念）：</p>
<ul>
<li>代码的容器</li>
<li>依赖其他模块的列表</li>
<li>导出的包列表，即其他模块可以使用的列表</li>
<li>开放的包列表，即其他模块可反射访问模块的列表</li>
<li>使用的服务列表</li>
<li>提供服务的实现列表</li>
</ul>
<p>&emsp;模块化之前，类加载主要依靠类路径，如果类路径中缺失了依赖的类型，那么只能等到程序运行到该类型的加载、链接时才会报出运行时异常。JDK9之后，如果启用了模块化封装，模块可以申明对其他模块的显示依赖，这样虚拟机就能够在启动时验证程序运行需要的依赖关系在运行期是否完备，如果缺失则启动失败，这样可以避免大部分的由依赖引发的运行时异常。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/167729732">模块化优点</a>具体的JDK9的模块化系统可以读读其他文章。</p>
<h3 id="5-1-模块的兼容"><a href="#5-1-模块的兼容" class="headerlink" title="5.1 模块的兼容"></a>5.1 模块的兼容</h3><p>&emsp;java里面有“类路径（ClassPath）”的概念，JDK9为了兼容，提出了“模块路径（ModulePath）”的概念。</p>
<p>&emsp;某个类库到底是模块还是传统的jar包，取决于它存放在哪种路径上。只要是处于类路径上的，即便包含了模块信息也会被当做传统jar包对待。而放在模块路径上的包，即使不包含JMOD后缀，不包含module-info.class文件，也会被当做模块来对待。</p>
<p>&emsp;JPMS的向下兼容规则：</p>
<ul>
<li>jar文件在类路径的访问规则：所有类路径下的jar文件及其他资源，被视为自动打包在一个匿名模块中（Unamed Module）里，匿名模块没有任何隔离，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块导出的包。</li>
<li>模块在模块路径访问规则：具名模块（Named Module）只能访问它列明的模块和包。不可访问匿名模块，即具名模块看不见传统jar内容。</li>
<li>jar文件在模块路径的访问规则：传统的jar包放到模块路径下，它会变成一个自动模块（Automatic Module）。不包含module-info.class文件，但默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，也默认导出自己所有的包。</li>
</ul>
<p><img src="http://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZXMuaW5mb3EuY29tL2FydGljbGVzL2phdmE5LW9zZ2ktZnV0dXJlLW1vZHVsYXJpdHktcGFydC0yL2VuL3Jlc291cmNlcy8yZmlndXJlLmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="OSGI和JPMS的交互"></p>
<h3 id="5-2-模块下的类加载器"><a href="#5-2-模块下的类加载器" class="headerlink" title="5.2 模块下的类加载器"></a>5.2 模块下的类加载器</h3><p>&emsp;模块化之后，扩展类加载器被平台类加载器取代。平台类加载器之后依然是自定义类加载器（图中未画出）。模块化之后整个java类库都满足可扩展的需求，因此无需再保留<code>&lt;java_home&gt;\lib/ext</code>目录，<br><img src="https://www.freesion.com/images/996/c62a8f3caf451578f58630c0e55ce61c.JPEG" srcset="/img/loading.gif" alt="JDK9之后的双亲委派模型"><br>&emsp;平台类或者程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如可以就优先委派给负责那个模块的加载器。</p>
<p>&emsp;在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块。<br>&emsp;启动类加载器负责加载的模块：</p>
<pre class="line-numbers language-none"><code class="language-none">java.base                        java.security.sasl
java.datatransfer                java.xml
java.desktop                     jdk.httpserver
java.instrument                  jdk.internal.vm.ci
java.logging                     jdk.management
java.management                  jdk.management.agent
java.management.rmi              jdk.naming.rmi
java.naming                      jdk.net
java.prefs                       jdk.sctp
java.rmi                         jdk.unsupported<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;平台类加载负责加载的模块：</p>
<pre class="line-numbers language-none"><code class="language-none">java.activation*                jdk.accessibility
java.compiler*                  jdk.charsets
java.corba*                     jdk.crypto.cryptoki
java.scripting                  jdk.crypto.ec
java.se                         jdk.dynalink
java.se.ee                      jdk.incubator.httpclient
java.security.jgss              jdk.internal.vm.compiler*
java.smartcardio                jdk.jsobject
java.sql                        jdk.localedata
java.sql.rowset                 jdk.naming.dns
java.transaction*               jdk.scripting.nashorn
java.xml.bind*                  jdk.security.auth
java.xml.crypto                 jdk.security.jgss
java.xml.ws*                    jdk.xml.dom
java.xml.ws.annotation*         jdk.zipfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>&emsp;应用程序类加载器负责加载的模块：</p>
<pre class="line-numbers language-none"><code class="language-none">jdk.aot                         jdk.jdeps
jdk.attach                      jdk.jdi
jdk.compiler                    jdk.jdwp.agent
jdk.editpad                     jdk.jlink
jdk.hotspot.agent               jdk.jshell
jdk.internal.ed                 jdk.jstatd
jdk.internal.jvmstat            jdk.pack
jdk.internal.le                 jdk.policytool
jdk.internal.opt                jdk.rmic
jdk.jartool                     jdk.scripting.nashorn.shell
jdk.javadoc                     jdk.xml.bind*
jdk.jcmd                        jdk.xml.ws*
jdk.jconsole<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/java/">java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/jvm/">jvm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM之垃圾回收</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/">
                        <span class="hidden-mobile">类文件结构分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
