<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java线程安全和锁</title>
    <link href="/2021/02/19/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/"/>
    <url>/2021/02/19/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="1-java线程安全"><a href="#1-java线程安全" class="headerlink" title="1. java线程安全"></a>1. java线程安全</h1><p>&emsp;按照线程安全的由强至弱的程度，可以把java语言中各种操作共享的数据分为五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h2 id="java中的线程安全"><a href="#java中的线程安全" class="headerlink" title="java中的线程安全"></a>java中的线程安全</h2><h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p>&emsp;不可变对象一定是线程安全的，无需再进行任何安全措施保障。比如<code>final</code>修饰的变量等。比如<code>java.lang.String</code>，它的任何方法<code>substring()、concat()</code>等都是返回新的字符串，不会修改原字符串。</p><h3 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h3><p>&emsp;不管运行时环境如何，调用者都不需要任何额外的同步措施。通常代价较大。比如<code>java.util.Vector</code>，它的方法<code>add() get() remove() size()</code>等都添加了<code>synchronized</code>，尽管效率不高，但是可以保证原子性、可见性和有序性。但是它不是绝对线程安全的，比如有多个线程同时多次添加、读取、删除Vector元素，这时候无法保证循环每个线程中for循环的i的原子性，可能会报越界，因此需要额外保证同步。</p><h3 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h3><p>&emsp;通常来说线程是安全的，但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。比如Vector</p><h3 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h3><p>&emsp;本身不是线程安全的，但是可以通过调用端使用同步来保证安全性。java类api中大多数类都是线程兼容的。</p><h3 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h3><p>&emsp;无论是否采用同步措施，都无法在并发中使用。比如Thread类的<code>suspend()</code>和<code>resume()</code>方法。</p><h2 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h2><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>&emsp;互斥是方法，同步是目的。临界区（Critical Section）、互斥量（Metex）和信号量（Semaphore）是常见的实现互斥的方式。</p><blockquote><p>互斥量和信号量的区别</p><ul><li><strong>互斥量用于线程的互斥，信号量用于线程的同步。</strong><ul><li>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li><li>同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</li></ul></li><li>互斥量值只能为0/1，信号量值可以为非负整数。</li><li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li></ul></blockquote><p>&emsp;<code>synchronized</code>是实现互斥同步的最基本的手段。<code>synchronized</code>编译后会在代码块前后产生<code>monitorenter</code>和<code>monitorexit</code>字节码指令。<code>monitorenter</code>指令被执行时，会先获取对象的锁，如果当前线程已经持有了对象锁了，则会把锁计数器+1，<code>monitorexit</code>指令被执行时，锁计数器-1，当锁计数器为0的时候说明锁被释放了。如果获取锁失败，当前线程阻塞，直至获取成功为止。</p><p><strong>&emsp;加锁是一个重量级的操作</strong>。因为java线程是映射到操作系统原生的线程之上的，如果需要阻塞或者唤醒线程，则需要操作系统的帮忙，需要切换用户态到内核态，这种状态转换需要消耗很多处理器时间。比如给简单的get/set方法加锁，切换耗时会比代码耗时更长，因此非必要不加锁。</p><p>&emsp;虚拟机对锁进行了一些优化，比如自旋锁等，下节会看到。</p><p>&emsp;除了&emsp;<code>synchronized</code>，jdk5起提供了<code>java.util.concurrent</code>包，其中的<code>java.util.concurrent.locks.Lock</code>接口成了Java的另一种互斥同步手段。重入锁（ReentrantLock）是Lock接口最常见的一种实现，也是可重入的，功能与&emsp;<code>synchronized</code>类似，多了以下高级功能：</p><ul><li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>可实现公平锁：多个线程等待同一锁时，必须按照申请时间来一次获得。默认非公平。</li><li>绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象。</li></ul><p>&emsp;性能上，理论上多线程环境下synchronized的吞吐量比不上ReentrantLock，但是由于虚拟机对锁的优化，实际上他们两差不多。在实际功能中，如果都满足条件，《深入理解java虚拟机》作者推荐使用synchronized。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>&emsp;互斥同步实际上一种阻塞同步，属于一种悲观的并发策略。实际上不一定会发生互斥，因此也可以不管风险，直接操作，如果共享数据被征用了，再进行补偿措施，这种乐观的并发策略被称为非阻塞同步。这种需要硬件支持（否则手动实现需要互斥同步），需要操作和冲突检测这两个步骤具备原子性。这类指令有：</p><ul><li><p>Test-and-Set</p></li><li><p>Fetch-and-Increment</p></li><li><p>Swap</p></li><li><p>Compare-and-Swap，CAS</p></li><li><p>Load-Linked/Store-Conditional，LL/SC</p></li></ul><p>  &emsp;以上最常用的是CAS指令，它有3个操作数<code>内存地址V, 旧的预期值A，准备设置的新值B</code>，执行CAS指令时，当V符合A时，才会更新V的值为B，否则不更新，这是一个原子操作。<code>java.util.concurrent.atomic</code>包中提供了一系列可原子操作的对象。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntVolatile</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger a = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        a++</span><br>        a.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                        increase();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-comment">//等待所有线程结束</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br><span class="hljs-comment">//        while (Thread.activeCount() &gt; 1)</span><br><span class="hljs-comment">//            Thread.yield();</span><br><br>        System.out.println(a);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//incrementAndGet（）实现，实际就是 自旋锁 + CAS操作</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> var5;<br>  <span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<br>    <span class="hljs-comment">//CAS操作</span><br>  &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br>  <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>&emsp;有一些代码天生就安全，无需额外同步。比如不使用全局变量的类方法，在栈上操作，线程私有。</p><h1 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h1><h2 id="自旋锁和自适应锁"><a href="#自旋锁和自适应锁" class="headerlink" title="自旋锁和自适应锁"></a>自旋锁和自适应锁</h2><p>&emsp;使用synchronize关键字的时候，需要使线程挂起和唤醒，然而挂起线程和唤醒线程都需要转入到核心态完成。实际上，程序不需要等待很久的时间就可以轮到下一个程序来执行了，那么这个时候就没有必要挂起线程，而是让等待的线程在获取到锁的时候，在原地循环等待，不断判断锁，是否可以被自己获取。如果有线程释放锁了，那就可以停止等待获取锁了。这种叫<strong>自旋锁</strong>。</p><p>&emsp;但是获取锁的线程并没有执行什么任务，虽然都是在活跃的状态，我们称作busy-waiting。</p><p>&emsp;<strong>自旋锁优点</strong>：避免线程切换的开销（即一直处在用户态）；</p><p>&emsp;<strong>自旋锁缺点</strong>：1.不公平锁，所以存在“线程饥饿”问题   2.如果等待时间过长，消耗cpu不做事情，cpu的使用率就下降</p><p><a href="https://blog.csdn.net/qq_34337272/article/details/81252853">自旋锁实现</a></p><p>&emsp;<strong>自适应锁</strong>：为了提高cpu使用率，自旋默认次数是10，但是可以修改参数。jdk1.6自适应不意味着时间不固定了，而是由前一次在同一个锁上的等待时间来决定，虚拟机可以做一些判断。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>&emsp;我们之前也讲过，比如Vector，他的内部源码基本所有都存在互斥同步的关键字synchronize，但是实际上有时候不存在数据竞争，那么java编译器就会在编译的时候消除这个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">concat</span><span class="hljs-params">(String s1, String s2, String s3)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> s1 + s2 + s3;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;以上代码，字符串不可变，连接操作时生成新的的String对象，javac对对此优化。在jdk5之前会转化为StringBuffer的append操作，之后会转为StringBuild操作。由于Stringbuffer是线程安全的，appen方法有加锁操作，因此以上代码实际上存在同步操作（JDK5之前）。但是虚拟机经过逃逸分析发现，它不会逃到concat方法之外，因此在JIT编译之后，这段代码会忽略所有的同步操作。这个就叫<strong>锁消除</strong>。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>&emsp;通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demoMethod</span><span class="hljs-params">()</span></span>&#123;  <br>  <span class="hljs-keyword">synchronized</span>(lock)&#123;   <br>    <span class="hljs-comment">//do sth.  </span><br>  &#125;  <br>  <span class="hljs-comment">//...做其他不需要的同步的工作，但能很快执行完毕  </span><br>  <span class="hljs-keyword">synchronized</span>(lock)&#123;   <br>    <span class="hljs-comment">//do sth.  </span><br>  &#125; <br>&#125;<br><br><br><span class="hljs-comment">//锁粗化之后</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demoMethod</span><span class="hljs-params">()</span></span>&#123;  <br>  <span class="hljs-comment">//整合成一次锁请求 </span><br>  <span class="hljs-keyword">synchronized</span>(lock)&#123;   <br>    <span class="hljs-comment">//do sth.   </span><br>    <span class="hljs-comment">//...做其他不需要的同步的工作，但能很快执行完毕  </span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>&emsp;重量级锁：synchronize</p><p>&emsp;轻量级锁：通过CSA操作来进行加锁操作。</p><p>&emsp;对于绝大部分的锁，整个周期内都是不存在竞争关系的，那么轻量级锁就可以使用CSA操作来避开使用互斥同步的开销，但是如果存在互斥量的开销外还额外的产生CSA操作，那么轻量级锁就会比重量级锁还要慢。</p><p>&emsp;<b style="color:red">轻量级锁所适应的场景：线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</b></p><p>&emsp;我们看一下轻量级锁的加锁和解锁过程。下图是对象的对象头Mark Word，它一共32位，前25位记录对象的哈希码，中间4位记录分代年龄，最后2位记录锁的状态。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2471399057,1363437917&fm=26&gp=0.jpg" alt="HotSpot虚拟机对象头Mark Word"></p><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2070698%2F202101%2F2070698-20210111184723897-1637978656.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1616396571&t=e69ede1faf50468ff8eaf6117d8ec93e" alt="轻量级锁CAS之前堆栈与对象状态"></p><p>&emsp;1. 在代码进入同步块，若是同步对象没有被锁定（01），虚拟机就将当前线程的栈帧中建立一个锁记录空间，用来存储Mark Word的拷贝（Displaced Mark Word）</p><p>&emsp;2. 虚拟机使用CSA操作尝试将对象的Mark Word更新为指向锁记录指针，若是成功，则拥有这个对象的锁了，并且Mark Word的锁标志位为00，表示处于轻量级锁状态。如下图所示。</p><p>&emsp;3. 若是操作失败，则先检查对象的Mark Word是否指向当前线程的栈帧，若当前线程有这个锁了，那就进入同步块继续执行，若是没有，这说明这个锁被其他线程抢占了，这个时候Mark Word变成了重量级互斥指针（10）。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2070698%2F202101%2F2070698-20210111184817699-1133634522.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1616396571&t=5a8e0b2e2ce52b355bb32bafa486c22b" alt="轻量级锁CAS之后堆栈与对象状态"></p><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>&emsp;1. 若是对象的Mark Word仍指向线程的锁记录，那就用CSA操作把对象当前的Mark Word和线程赋值的Displaced Mark Word替换回来；</p><p>&emsp;2. 替换成功，同步完成，失败说明有其他锁试图获取该锁，那就唤醒被挂起的线程。</p><p>&emsp;如果使用轻量级同步锁提升性能，必须满足：对于绝大部分锁，在同步周期内不存在竞争。否则的话，存在锁竞争，出去互斥量开销，还额外发生了CAS操作开销。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>&emsp;<strong>偏向锁</strong>：顾名思义，偏袒，在无竞争的情况下把整个同步都消除掉，偏向于第一个获得它的线程。若是该锁接下来没有被其他线程获取，持有偏向锁的线程就不需要同步。</p><p>&emsp;轻量级锁是在无竞争的情况下使用CAS操作进行消除同步使用的互斥量；但是偏向锁是消除所有同步，包括CAS。</p><p>&emsp;假设当前虚拟机开启了偏向锁<code>-XX: UseBiased Locking, 默认开启</code>，当锁第一次被线程获取时，虚拟机会把Mark Word中的标志位设置为01，偏向模式设置为1，同时CSA操作把获取锁的线程的ID记录在对象的Mark Word里。如果cas操作成功，以后持有该锁的线程进入同步块都不会做任何同步操作。</p><p>&emsp;一旦出现另一个线程尝试去获取偏向锁的时候，偏向模式结束，撤销偏向后恢复到未锁定01或者轻量级锁定00。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=268473915,597337485&fm=26&gp=0.jpg" alt="锁状态转换"></p><p>&emsp;<strong>注意：</strong>从HotSpot虚拟机对象头Mark Word的结构我们可以看到，当对象进入偏向模式的时候，原先存哈希码的空间被用来存储持有锁的线程id了，那么原先的哈希码怎么办呢？</p><p>&emsp;哈希码对于对象来确定唯一性很重要，java中绝大多数api的<code>hashCode()</code>都继承自<code>Object::hashCode()</code>，调用hashCode函数后，哈希码会被记录在对象头中，如果一个对象已经记录了哈希码，那么它是无法进行偏向模式的；如果正持有偏向锁，又收到需要计算哈希码的请求，那么偏向锁会膨胀为重量级锁。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之后端编译与优化</title>
    <link href="/2021/01/25/JVM%E4%B9%8B%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2021/01/25/JVM%E4%B9%8B%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>&emsp;把class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，这个过程可以看做是整个编译过程的后端。</p><p>&emsp; JVM 的前端编译器： Javac。后端编译器：即时编译器（JIT 编译器）和提前编译器（AOT 编译器）。</p><p>&emsp;java虚拟机规范中并没有规定必须包含即时编译或者提前编译，但是这些是提升编译的一个方案，用来衡量虚拟机的品质。以下提到的即时编译器特值HotSpot虚拟机内置的即时编译器，虚拟机特指HotSpot虚拟机。</p><h1 id="1-即时编译器"><a href="#1-即时编译器" class="headerlink" title="1. 即时编译器"></a>1. 即时编译器</h1><p>&emsp;目前主流的两款商用 JVM（HotSpot、OpenJ9）中，Java 程序最初都是通过「<strong>解释器</strong>（Interpreter）」解释执行的，当 JVM 发现某个方法或代码块的执行特别频繁，就会认为它们是“<strong>热点代码</strong>（Hot Spot Code）”。</p><p>&emsp;为了提高热点代码的执行效率，JVM 会在「运行时」把这部分代码编译成本地机器码，并用各种手段去优化代码。运行时完成这个任务的后端编译器被称为「<strong>即时编译器</strong>」。</p><h2 id="1-1-解释器与编译器"><a href="#1-1-解释器与编译器" class="headerlink" title="1.1 解释器与编译器"></a>1.1 解释器与编译器</h2><p>解释器（Interpreter）：工作在「运行时」，对源码一行一行的解释然后执行，然后返回结果。</p><p>编译器（Compiler）：往往是在「执行」之前完成，产出是一种可执行或需要再编译或者解释的「代码」。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fstatic.zybuluo.com%2Ffeixuelove1009%2Fx6c0pdl90q1129rgfne1p5gy%2Fimage.png&refer=http%3A%2F%2Fstatic.zybuluo.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1614853202&t=6ebb39f7e91ae14bd363d39d8ddb8bdb" alt="编译器和解释器的理解"></p><p>&emsp;HotSpot中内置了2或3个编译器：</p><ul><li>客户端编译器（Client Compiler，C1）</li><li>服务端编译器（Server Compiler，C2，也叫Opto编译器）</li><li>Graal编译器（JDK 10 出现用于替代 C2）</li></ul><p>&emsp;分层编译出现前，解释器通常和其中一个编译器搭配使用。虚拟机默认会根据硬件来性能自动选择虚拟机运行在客户端模式还是服务器模式，也可以<code>-clent</code> <code>-server</code>手动指定。 </p><p>&emsp;<strong>解释执行</strong>：启动速度快。<br>&emsp;<strong>C1 编译执行</strong>：预热较快，运行时，执行快，相对更高的编译速度。<br>&emsp;<strong>C2 编译执行</strong>：需要较慢，运行时，执行快，相对更好的编译质量。</p><p>&emsp;现在的解释器和编译器并不是单独工作了，而是交互执行。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4192503619,3653616387&fm=26&gp=0.jpg" alt="交互执行"></p><h2 id="1-2-分层编译"><a href="#1-2-分层编译" class="headerlink" title="1.2 分层编译"></a>1.2 分层编译</h2><p>&emsp;在分层编译的工作模式出现前，HotSpot 虚拟机通常时采用解释器与其中一个编译器直接搭配的方式工作。为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机在编译子系统中加入了分层编译功能。</p><p>&emsp;解释器和编译器搭配使用的方式称为”混合模式“。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -version        //Java HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">25</span>.<span class="hljs-number">211</span>-b<span class="hljs-number">12</span>, mixed mode)<br><span class="hljs-attribute">java</span> -Xint -version  //Java HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">25</span>.<span class="hljs-number">211</span>-b<span class="hljs-number">12</span>, interpreted mode)<br><span class="hljs-attribute">java</span> -Xcomp -version //Java HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">25</span>.<span class="hljs-number">211</span>-b<span class="hljs-number">12</span>, compiled mode)<br></code></pre></td></tr></table></figure><ul><li>level 0：interpreter 解释执行。</li><li>level 1：C1 编译，无 profiling（性能监控）</li><li>level 2：C1 编译，仅方法及循环 back-edge 执行次数的 profiling</li><li>level 3：C1 编译，除 level 2 中的 profiling 外还包括 branch（针对分支跳转字节码）及 receiver type（针对成员方法调用或类检测，如 checkcast，instnaceof，aastore 字节码）的 profiling</li><li>level 4：C2 编译，将字节码编译成本地代码。相比客户端，会启用更多耗时长的优化。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200910212623971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0OTAyODA=,size_16,color_FFFFFF,t_70#pic_center" alt="分层编译"></p><p>&emsp;以上层次并不是一层不变的，根据不同的运行参数，虚拟机可以调整分层的数量，分层编译的交互如下如所示：</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F340444%2F202012%2F340444-20201228145824696-1515231115.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1615289603&t=189b53163ab56a8a25182025ce04e184" alt="分层编译交互"></p><p>上图列举了4 种编译模式（非全部）。</p><ol><li>通常情况下，一个方法先被解释执行（level 0），然后被C1 编译（level 3），再然后被得到profile 数据的C2 编译（level 4）。</li><li>如果编译对象非常简单，虚拟机认为通过C1 编译或通过C2 编译并无区别，便会直接由C1 编译且不插入profiling 代码（level 1）。</li><li>在C1 忙碌的情况下，interpreter 会触发profiling，而后方法会直接被C2 编译；</li><li>在C2 忙碌的情况下，方法则会先由C1 编译并保持较少的profiling（level 2），以获取较高的执行效率（与3 级相比高30%）。</li></ol><p>&emsp;实施分层编译后，解释器、客户端编译器和服务端编译器会同时工作，热点代码可能会被多次编译。用C1获取更高的编译速度，用C2获取更好的编译质量，在解释执行时也无需承担额外性能监控的任务，在C2采用高复杂度的优化算法时，C1可以采用简单优化来为它争取更多的编译时间。</p><h2 id="1-2-热点代码和热点探测"><a href="#1-2-热点代码和热点探测" class="headerlink" title="1.2 热点代码和热点探测"></a>1.2 热点代码和热点探测</h2><blockquote><p>热点代码</p></blockquote><p>&emsp;运行时会被即时编译器编译的目标是“热点代码”，主要包括下面两类：</p><ol><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ol><p>&emsp;前者是jvm标准的即时编译，以整个方法作为编译对象。</p><p>&emsp;后者依然以方法作为编译对象，但是触发即时编译的入口不一样（即不是从方法的第一行开始）。编译时会传入执行入口点的字节码序号（ByteCodeIndex，BCI）。由于该情况发生在方法执行的过程中，也被称为栈上替换（On Stack Replacement，OSR）。也就是方法的栈帧还在栈上，但方法已经被替换了。</p><blockquote><p>热点探测</p></blockquote><p>&emsp;只有探测出了该代码是热点代码，才会执行即时编译。主流的热点探测方式有以下2种：</p><ol><li><p><strong>基于采样的热点探测</strong>（Sample Based Hot Spot Code Detection）</p><p>周期性的去检查一下所有线程的调用栈顶，若发现某些方法经常出现在栈顶，该方法就会被认为是“热点代码”。J9 虚拟机使用过该方法。</p><p>优点：实现简单高效，而且可以通过堆栈信息获取到方法之间的调用关系；</p><p>缺点：难以精确的确定方法热度，容易受到线程阻塞的干扰（即方法阻塞时可能长时间处于栈顶，可能产生误判）。</p></li><li><p><strong>基于计数器的热点探测</strong>（Counter Based Hot Spot Code Detection）</p><p>为每个方法（或代码块）建立计数器来统计方法的执行次数，当次数超过一定的阈值就认为是“热点代码”。HotSpot 虚拟机就是使用该方法进行探测的。</p><p>优点：统计结果更加精确严谨；</p><p>缺点：统计起来稍麻烦（要为每个方法建立并维护计数器），而且不能直接获取到方法的调用关系。</p></li></ol><p>&emsp;在HotSpot中采用的是基于计数器的热点探测技术。HotSpot使用了2种计数器：</p><ul><li><p>方法调用计数器（Invocation Counter）：统计方法被调用的次数。</p><p>客户端阈值：1500。服务端阈值：10000。可以使用<code>-XX:CompileThreadhod</code>设定。</p></li><li><p>回边计数器（Back Edge Counter）：统计方法中循环体代码执行的次数，目的是触发栈上替换。</p><p>字节码中遇到控制流向后跳转的指令称为“<strong>回边</strong>”。</p></li></ul><p><b style="color:red">方法调用计数器流程</b></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9vcGhUYjkwb1lDVFVDanJNckdBcDNBdkdnbmppYnhFZ1lTeERpYUVtYlVwczlqSk1NZFM2OTFhWXVaRFdWZVAwd3M1NnBZc3IzNVRQdlZpYlM2ZGhXZGNnUS82NDA?x-oss-process=image/format,png"></p><p>&emsp;方法调用计数器统计的并非方法被调用的绝对次数，而是是一个相对的执行频率。</p><p>&emsp;在一段时间内，如果方法的调用次数未到达阈值，计数器就会减少为原先的一半。该过程被称为<strong>热度衰减</strong>（Counter Decay），这段时间则被称为<strong>半衰周期</strong>（Counter Half Life Time）。这样的话，只要程序运行的时间足够长，程序中大部分代码都会被编译成本地代码。<code>-XX: UseCounterDecay</code>来设置关闭热度衰减，<code>-XX: CounterHalfLifeTime</code>设置半衰周期（秒）。</p><p><b style="color:red">回边计数器流程</b></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9vcGhUYjkwb1lDVFVDanJNckdBcDNBdkdnbmppYnhFZ1lueXRrWDVBWEFUaWJpYzRVT2RzWkVaYzlpY285TmtMekVFN3VwallxV0htVXVyeFBYSkF5Yk45R0EvNjQw?x-oss-process=image/format,png" alt="回边计数器流程"></p><p>&emsp;<code>-XX:CompileThreadhod</code>阈值。</p><p>&emsp;<code>-XX: OnStackReplacePercentage</code>调整回边计数器的阈值的OSR比例，默认933。</p><p>&emsp;<code>-XX:InterpreterProfilePercentage </code> 解释器监控比率，默认 33。</p><p>&emsp;客户单模式下，<code>阈值 = 阈值 * OSR比例 / 100  </code> ，默认为13995。</p><p>&emsp;服务器模式下，<code>阈值 = 阈值 * (OSR比例 - 解释器监控比率) / 100  </code> ，默认为10700。</p><p>&emsp;回边计数器没有热度衰减，因此这个值就是循环的绝对次数。</p><p>&emsp;以上两个附图实际上描述的是客户端模式下的探测过程，服务端模式下，更复杂。</p><h2 id="1-3-编译过程"><a href="#1-3-编译过程" class="headerlink" title="1.3 编译过程"></a>1.3 编译过程</h2><p>&emsp;默认情况下， 不论是方法调用产生的标准编译请求还是栈上替换编译请求，在编译器完成编译之前，虚拟机都将按照解释方式执行代码，而编译动作会在后台继续进行。可使用<code>-XX: -BackgroundCompilation</code>来禁止后台编译，禁止后，如果触发了即时编译，执行线程会向虚拟机提交编译请求，然后阻塞直至编译完成，然后执行编译器输出的本地代码。</p><p>&emsp;那么在后台编译的过程中，编译器具体会做什么事情呢？</p><blockquote><p> 客户端编译器编译过程</p></blockquote><p>&emsp;编译器主要目的是提供各种优化手段，客户端编译器的关注点在于局部性的优化，而服务端的关注点在耗时较长的全局性优化。</p><p>&emsp;客户端编译的优化过程分为3个阶段：</p><ul><li>阶段1：将字节码构造成<strong>高级中间代码表示</strong>（High-Level Intermediate Representation，HIR，与目标机器指令集<strong>无关</strong>的中间表示）。<ul><li>在构造HIR之前，编译器会在字节码上做部分基础优化，比如方法内联、常量传播等。</li><li>HIR使用静态单分配（Static Single Assignment，SSA）的形式来表示代码值，这样可以让一些在HIR的构造过程之中和之后进行的优化动作更容易实现。</li></ul></li><li>阶段2：将HIR构造成<strong>低级中间代码表示</strong>（LIR，与目标机器指令<strong>相关</strong>的中间表示）。<ul><li>在构造LIR之前，编译器会在HIR上完成一些优化，比如空值检查消除、范围检查消除等，</li></ul></li><li>阶段3：使用线性扫描算法（Liner Scan Register Allocation）在LIR上分配寄存器、并在LIR上做窥孔（Peep hole）优化，然后产生机器代码。这一部分和平台相关，也就是系统平台相关，比如x86架构会产生x86指令，arm产生arm指令等，</li></ul><p>&emsp;客户端编译器执行过程如下图所示：</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3219334368,1848653826&fm=26&gp=0.jpg" alt="client compile"></p><blockquote><p>服务端编译器编译过程</p></blockquote><p>&emsp;服务端编译器是专门面向服务端的典型应用场景，并特意针对服务端配置调整过的编译器，是一个能容忍高复杂优化的高级编译器。塔会执行大部分经典的优化动作：</p><ul><li>无用代码消除（Dead Code Elimination）</li><li>循环展开（Loop Unrolling）</li><li>循环表达式外提（Loop Expression Hoisting）</li><li>消除公共子表达式（Common Subexpression Elimination）</li><li>常量传播（Constant Propagation）</li><li>基本块重排序（Basic Block Reordering）</li><li>……</li><li>范围检查消除（Range Check Elimination）</li><li>空值检查消除（Null CheckElimination ）</li><li>……</li><li>守护内联（Guarded Inlining）</li><li>分支频率预测（Branch Frequency Prediction）</li><li>……</li></ul><p>服务端编译是一个复杂的过程，部分细节参考1.4</p><h2 id="1-4-实战：查看及分析即时编译结果"><a href="#1-4-实战：查看及分析即时编译结果" class="headerlink" title="1.4 实战：查看及分析即时编译结果"></a>1.4 实战：查看及分析即时编译结果</h2><p>需要支持FastDebug或者SlowDebug优化级别的HotSpot虚拟机才能支持，Produce级别无法使用。因此需要自行编译jdk源码，等我编译了再来写。</p><h1 id="2-提前编译器"><a href="#2-提前编译器" class="headerlink" title="2. 提前编译器"></a>2. 提前编译器</h1><h2 id="2-1-提前编译的优缺点"><a href="#2-1-提前编译的优缺点" class="headerlink" title="2.1 提前编译的优缺点"></a>2.1 提前编译的优缺点</h2><p>&emsp;提前编译器（Ahead Of Time Compiler，AOT编译器）：直接把程序编译成与目标机器指令集相关的二进制代码的过程。目前有两种主要的实现方式：</p><ul><li><p>1.与传统C/C++编译器类似，在程序运行之前<strong>把程序代码编译成机器码的静态翻译</strong>工作</p></li><li><p>2.把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用</p></li></ul><p>&emsp;即时编译缺点：要占用程序运行时间和运算资源，即使现在的JIT编译器已经很先进，采用分层编译可以先用快且低质量的即时编译器为高质量的即时编译器争取出更多时间，但是消耗的运算资源都是原本可以用于程序运行的。例如最耗时的优化措施之一“过程间分析”，需要在全程序范围内做大量工作。</p><p>&emsp;如果是在程序运行之前进行静态编译，这些耗时操作就可以大胆的进行，因此方式1弥补了即时编译的缺点。</p><p>&emsp;方式2本质上是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热之后才能达到最高性能的问题。这种提前编译被称为<strong>动态提前编译</strong>或者直接叫<strong>即时编译缓存</strong>。HotSpot运行时可以直接加载这些编译结果，实现快速程序启动速度，减少程序达到全速运行状态所需要的时间。</p><p>JIT编译器相比AOT编译器的优点：</p><ul><li><strong>性能分析制导优化</strong>。解释器和客户端编译器在运行期间会不断收集性能监控信息，这些信息一般无法在静态分析是获得，或者不一定存在唯一的解，但在动态运行时很容易得到。</li><li><strong>激进预测性优化</strong>。<ul><li>静态优化无论何时都必须保证优化后的所有程序外部可见影响（不仅仅是执行结果）与优化前必须是一致的，否则优化会导致程序报错或不对。</li><li>即时编译的策略就可以不必那么保守，如果性能监控信息能够支持它做出一些正确的可能很大但是无法保证绝对正确的预测判断，就可以进行大胆的优化，大不了退回到低级i按一起甚至解释器上运行。而这样的优化往往能够大幅度降低目标程序的复杂度，输出运行速度非常高的代码。</li><li><strong>链接时优化</strong>。由于Java天生是动态连接的，一个个class文件在运行期被加载到虚拟机内存中，然后在即时编译器里产生优化后的代码。而C++等的主程序和动态链接库代码在编译时是完全独立的，当跨界调用的时候，需要做相应的优化。提前编译无法做到链接后的优化。</li></ul></li></ul><h2 id="2-2-实战：Jaotc的提前编译"><a href="#2-2-实战：Jaotc的提前编译" class="headerlink" title="2.2 实战：Jaotc的提前编译"></a>2.2 实战：Jaotc的提前编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成字节码文件</span><br>javac Hello.java<br><span class="hljs-comment"># 生成静态链接库，jaotc在jdk/bin目录下，jdk9及其之后才有</span><br>jaotc --output libHello.a Hello.classs<br><br><span class="hljs-comment"># 现在可以使用这个静态链接库来执行程序了</span><br>java -XX:AOTLibrary=./libHello.a Hello    <span class="hljs-comment">## Hello为类名</span><br></code></pre></td></tr></table></figure><p>&emsp;这是个很小的jaotc提前编译的例子，目前为止jaotc还有许多需要完善的地方，仍然难以直接编译spring boot、mybatis等常见的第三方工具库，甚至众多java模块中，只能顺利编译的只有java.base模块。但是随着Graal编译器的逐渐成熟，Jaotc未来可期。</p><h1 id="3-编译器优化技术"><a href="#3-编译器优化技术" class="headerlink" title="3. 编译器优化技术"></a>3. 编译器优化技术</h1><p>&emsp;<a href="https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex">https://wiki.openjdk.java.net/display/HotSpot/PerformanceTacticIndex</a></p><p>&emsp;以上是HotSpot团队列出的比较全面的即时编译器优化技术，特别多，但是不难理解，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原始代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br><span class="hljs-keyword">int</span> value;<br>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>y = b.get();<br>  <span class="hljs-comment">//do sth</span><br>  z = b.get();<br>  sum = y + z;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;以上代码看起来很简单，实际上仍然可以优化。</p><p>&emsp;<b style="color:red">第1步，优化内联</b></p><p>&emsp;优点：1.去除调用方法成本（方法版本查找，建立栈帧等）。2.为其他优化建立良好的基础。优化后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  y = b.value;<br>  <span class="hljs-comment">//do sth</span><br>  z = b.value;<br>  sum = y + z;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<b style="color:red">第2步，冗余访问消除</b><br>&emsp;假设注释部分的do sth不会改变b.value的值，那么<code>y=b.value</code>保证了<code>y</code>与<code>b.value</code>的值一致，如此则不必再访问b的局部变量了。如果<code>b.value</code>看作是表达式，那么该优化可以看作是一种<strong>公共子表达式消除</strong>。优化后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  y = b.value;<br>  <span class="hljs-comment">//do sth</span><br>  z = y;<br>  sum = y + z;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<b style="color:red">第3步，复写传播</b></p><p>&emsp;程序中没必要使用一个额外的变量z，它完全等于y，因此可以使用y代替z。复写传播后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  y = b.value;<br>  <span class="hljs-comment">//do sth</span><br>  y = y;<br>  sum = y + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<b style="color:red">第4步，无用代码消除</b></p><p>&emsp;无用代码：完全没意义的代码，或者永远不会被执行的代码。优化后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;<br>  y = b.value;<br>  <span class="hljs-comment">//do sth</span><br>  sum = y + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;优化后的代码在效果上和原始代码一致，但是在字节码和机器码指令的执行上，可就大大提高了效率。</p><p>&emsp;优化手段众多，其中最具代表性的优化技术有以下4种：</p><p><ul><li><b style="color:blue">方法内联</b>：最重要</li><li><b style="color:blue">逃逸分析</b>：最前沿</li><li><b style="color:blue">公共子表达式消除</b>：最经典，语言无关</li><li><b style="color:blue">数组边界检查消除</b>：最经典，语言相关</li></ul><h2 id="3-1-方法内联"><a href="#3-1-方法内联" class="headerlink" title="3.1 方法内联"></a>3.1 方法内联</h2><p>&emsp;最重要的优化技术之一，是所有优化的基础，被业内称为“优化之母”。</p><p>&emsp;方法内联：<strong>把目标代码的源代码原封不动的“复制”到发起调用的方法之中</strong>，避免发生真实的调用。</p><p>&emsp;注意：这里的代码指的被编译后的字节码或者机器码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInline</span><span class="hljs-params">()</span> </span>&#123;<br>  Object obj = <span class="hljs-keyword">null</span>;<br>  foo(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;方法内联看起来简单，实际上实现起来很复杂。由于<a href="https://happykite777.github.io/2020/12/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/#2-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">方法调用</a>中，虚方法只有在运行期间才能确定下来方法版本，因此编译器在编译时很难确定方法版本。又由于java是面向对象编程，对象的默认方法就是虚方法，所以大大增加了内联的难度。</p><p>&emsp;为了解决这个问题，C/C++选择了在默认方法前加上<code>final</code>，使得默认方法不为虚方法，当需要用到多态的时候，用<code>virtual</code>关键字来修饰。但是java选择了在虚拟机中解决这个问题。</p><p>&emsp;为了解决虚方法的内联问题，Java虚拟机引入了<strong>类型继承关系分析（Class Hierarchy Analysis，CHA）</strong>技术。主要用于确定整个应用程序范围内，目前已加载的类中，某个接口是否有多于一种实现、某个类是否存在子类、某个子类是否覆盖了父亲的某个虚方法等信息。这样在进行内联时，会根据情况来进行不同的内联。</p><ul><li>如果是<strong>非虚方法</strong>，不必选择方法版本，<strong>直接进行内联</strong>，这种方式百分之百安全。</li><li>如果是<strong>虚方法，则查询CHA</strong>，确定是否真的有多个版本可供选择<ul><li>如果只有一个版本，则“假设程序就是按照当前来运行的”，进行内联，这种方式叫<strong>守护内联</strong>（Guarded Inlining）。但是由于程序动态链接，说不定下一刻就会加载新的类型从而更改CHA结论，因此该方法属于激进预测性优化，必须留好退路。如果一直没有加载新的类型，则继续进行下去，如果加载了，则抛弃已经编译好的代码，进行解释执行或者重新编译。</li><li>如果有多个版本，那么JIT编译器会使用<strong>内联缓存</strong>（Inline Cache）的方式来缩减方法调用开销。内联缓存是一个建立在目标方法正常入口之前的缓存。<ul><li>未发生方法调用之前，内联缓存状态为空。</li><li>当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。</li><li>以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是种<strong>单态内联缓存</strong>(Monomorphic Inline Cache)，通过这种方式，开销仅仅只是比非虚方法多了一次类型判断而已。</li><li>如果出现方法接收者不一致， 就说明程序用到了 虚方法的多态特性， 这时候会退化成<strong>超多态内联缓存</strong>(Megamorphic Inline Cache)，其开销相当于真正查找虚方法表来进行。</li></ul></li></ul></li></ul><h2 id="3-2-逃逸分析"><a href="#3-2-逃逸分析" class="headerlink" title="3.2 逃逸分析"></a>3.2 逃逸分析</h2><p>&emsp;原理：分析对象动态作用域，当一个对象在方法里面被定义之后，它可能被外部方法所引用，例如作为调用参数传入到其他方法中，这种称为<strong>方法逃逸</strong>；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<strong>线程逃逸</strong>。</p><p>&emsp;  对象逃逸程度由低到高：从不逃逸、方法逃逸、线程逃逸。根据逃逸程度可以进行不同程度的优化：</p><ul><li><b style="color:red">栈上分配（Stack Allocation）</b>：对一个不会逃逸出线程的对象在栈上分配就是一个不错的主意，对象所占用的内存会随着栈桢的出栈而销毁，大量对象会随着方法的结束而自动销毁，垃圾收集系统也会减少压力。栈上分配支持方法逃逸，不支持线程逃逸。</li><li><b style="color:red">标量替换（Scalar Replacement）</b>：把Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析证明一个对象不会被方法外部访问，并且可以将这个对象拆散，那么程序真正执行的时候就不会去创建该对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替，而且这些成员变量还可以分配在栈上。不允许对象逃逸出方法范围。</li><li><b style="color:red">同步消除（Synchronization Elimination）</b>：线程同步本身是一个相当耗时的过程，如果逃逸分析·能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施就可以安全的消除掉。</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原始代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;<br>  <span class="hljs-comment">// getter/setter ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;<br>  Point p = <span class="hljs-keyword">new</span> Point(xx, <span class="hljs-number">42</span>);<br>  <span class="hljs-keyword">return</span> p.getX();<br>&#125;<br><br><br><br><span class="hljs-comment">// 方法内联优化后</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;<br>  Point p = point_memory_alloc(); <span class="hljs-comment">// 堆中分配内存示意方法</span><br>  p.x = xx; <span class="hljs-comment">// Point 构造函数内联后</span><br>  p.y = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">return</span> p.x; <span class="hljs-comment">// p.getX() 方法内联后</span><br>&#125;<br><br><br><br><span class="hljs-comment">// 逃逸分析：标量替换优化后</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> xx = x + <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">int</span> px = xx; <span class="hljs-comment">// 标量替换</span><br>  <span class="hljs-keyword">int</span> py = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">return</span> px;<br>&#125;<br><br><br><span class="hljs-comment">// 无效代码消除优化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过现在逃逸分析仍然不成熟，原因是逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗。</p><p> <code>-XX:+DoEscapeAnalysis</code>：手动开启逃逸分析</p><p> <code>-XX:+PrintEscapeAnalysis</code>：查看分析结果</p><p> <code>-XX:+EliminateAloocations</code>：开启标量替换</p><p><code>-XX:+EliminateLocks</code>：开启同步消除</p><p><code>-XX:+PrintEliminateLocks</code>：查看同步消除情况</p><h2 id="3-3-公共子表达式消除"><a href="#3-3-公共子表达式消除" class="headerlink" title="3.3 公共子表达式消除"></a>3.3 公共子表达式消除</h2><p>&emsp;定义：如果一个表达式E之前就被计算过了，并且先前的计算到现在E中所有变量的值都没有改变过，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间在对它重新进行计算，只需要直接用前面计算过的表达式结果替代E。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> d = (c * b) * <span class="hljs-number">12</span> + a + (a + b * c);<br><br><span class="hljs-comment">//未优化前，它的字节码指令执行如下：每次都会重新计算</span><br>         <span class="hljs-number">6</span>: iload_3<br>         <span class="hljs-number">7</span>: iload_2<br>         8: imul    # 计算 b*c<br>         <span class="hljs-number">9</span>: bipush        <span class="hljs-number">12</span><br>        11: imul    # 计算 (c * b) * 12<br>        <span class="hljs-number">12</span>: iload_1<br>        13: iadd    # 计算 (c * b) * 12 + a<br>        <span class="hljs-number">14</span>: iload_1<br>        <span class="hljs-number">15</span>: iload_2<br>        <span class="hljs-number">16</span>: iload_3<br>        17: imul    # 计算 b*c<br>        18: iadd    # 计算 (a + b * c)<br>        19: iadd    # 计算 (c * b) * 12 + a + (a + b * c)<br>        <span class="hljs-number">20</span>: istore        <span class="hljs-number">4</span><br>        <span class="hljs-number">22</span>: iload         <span class="hljs-number">4</span><br>        <span class="hljs-number">24</span>: ireturn<br><br></code></pre></td></tr></table></figure><p>&emsp;这段代码进入即时编译器后，将进行优化，编译器检测到 c * b 与 b * c 是一样的表达式，且在计算期间 b 和 c 的值不变，因此：<code>int d = E * 12 + a + (a + E);</code>，此时，编译器还可能进行代数化简<code>int d = E * 13 + a + a;</code>这样计算起来就可以节省一些时间。</p><h2 id="3-4-数组边界检查消除"><a href="#3-4-数组边界检查消除" class="headerlink" title="3.4 数组边界检查消除"></a>3.4 数组边界检查消除</h2><p>&emsp;由于Java语言是一门动态安全检查的语言，对于数组foo[]，访问数组元素foo[i]的时候系统会自动进行上下界范围检查，即i必须满足<code>i&gt;=0 &amp;&amp; i&lt;foo.length</code>的访问条件，否则将抛出运行时异常。这样每一次读写都要进行一次检查无疑是一种负担。</p><p>&emsp;有时数组边界检查不是必须继续进行的，此时就可以省略。</p><p>&emsp;例如数组下标是一个常量，如foo[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下表“3”没有越界，执行时的时候就无需判断了。</p><p>&emsp;又比如对于数组访问发生在循环中，并且使用循环变量对数组进行访问。如果编译器只要通过数据流分析就可以判定循环遍历取值范围永远在[0, foo.length)之内，那就可以把数组边界检查消除。</p><p>&emsp;隐式异常优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(foo != <span class="hljs-keyword">null</span>)&#123;<br>  <span class="hljs-keyword">return</span> foo.value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointException();<br>&#125;<br><br><span class="hljs-comment">//隐式异常优化后,伪代码</span><br><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-keyword">return</span> foo.value;<br>&#125;<span class="hljs-keyword">catch</span>(segment_default)&#123;<br>  uncommon_trap();<br>&#125;<br><span class="hljs-comment">//当程序中大量foo不为空的时候，可以节省开销，因为只有为空的时候才判断。</span><br></code></pre></td></tr></table></figure><h1 id="4-实战：深入理解Graal编译器"><a href="#4-实战：深入理解Graal编译器" class="headerlink" title="4. 实战：深入理解Graal编译器"></a>4. 实战：深入理解Graal编译器</h1><p>&emsp;从JDK10起，HotSpot就同时拥有3款不同的即时编译器，C1、C2和Graal编译器。</p><p>&emsp;Graal编译器支持提前编译和即时编译。JDK9事，Graal编译器以Jaotc提前编译工具的形式加入官方JDK，从JDK10起，Graal编译器可以替换服务端编译器C2，称为HotSpot分层编译中最顶层的即时编译器。</p><p>&emsp;实战略。graal源码编译失败。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之前端编译与优化</title>
    <link href="/2021/01/19/JVM%E4%B9%8B%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2021/01/19/JVM%E4%B9%8B%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>&emsp;编译期是一个很广泛的含义，它可能是指前端编译器（即“编译器的前端”）把<code>.java</code>文件转换为<code>.class</code>文件的过程。也可能是Java虚拟机的即时编译器（JIT编译器，Just In Time）运行期把字节码转变成本地机器码的过程。也有可能是静态的提前编译器（AOT编译器，Ahead Of Time Compile）直接把程序编译成目标机器指令集相关的二进制代码的过程。</p><p><img src="https://img2018.cnblogs.com/blog/1153954/202001/1153954-20200106092925007-1022314308.png"></p><ul><li>前端编译器：JDK的Javac、Eclipse <a href="http://www.eclipse.org/jdt">JDT</a>中的增量式编译器（ECJ）。</li><li>即时编译器：HotSpot的C1、C2编译器，Graal编译器。</li><li>提前编译器：JDK的Jaotc、GUN Compile for the Java（<a href="http://gcc.gnu.org/java">GCJ</a>）、Excelsior <a href="https://en.wikipedia.org/wiki/Excelsior_JET">JET</a>。</li></ul><p>&emsp;本章主要讨论的是第一种，前端编译器。</p><h2 id="1-Javac编译器"><a href="#1-Javac编译器" class="headerlink" title="1. Javac编译器"></a>1. Javac编译器</h2><p>&emsp;   <a href="https://github.com/openjdk/jdk/tree/master/src">openJDK源码</a>。jdk9之后，javac位于<code>src/jdk.compiler/share/classes/com/sun/tools/javac</code>目录下。<a href="https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java">源码查看</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//javac编译入口为com.sun.tools.javac.main.JavaCompiler.compile()，代码摘抄如下</span><br><span class="hljs-keyword">try</span> &#123;<br><br>  <span class="hljs-comment">// 0. 准备过程，初始化插入式注解处理器</span><br>  initProcessAnnotations(processors, sourceFileObjects, classnames);<br><br>  <span class="hljs-keyword">for</span> (String className : classnames) &#123;<br>    <span class="hljs-keyword">int</span> sep = className.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (sep != -<span class="hljs-number">1</span>) &#123;<br>      modules.addExtraAddModules(className.substring(<span class="hljs-number">0</span>, sep));<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (String moduleName : addModules) &#123;<br>    modules.addExtraAddModules(moduleName);<br>  &#125;<br><br>  <span class="hljs-comment">// These method calls must be chained to avoid memory leaks</span><br>  <span class="hljs-comment">// 2.执行注解处理</span><br>  processAnnotations(<br>    <span class="hljs-comment">// 1.2 enterTrees()输入到符号表</span><br>    enterTrees(<br>      stopIfError(CompileState.ENTER,<br>                  <span class="hljs-comment">//1.1 parseFiles()词法分析、语法分析</span><br>                  initModules(stopIfError(CompileState.ENTER, parseFiles(sourceFileObjects))))<br>    ),<br>    classnames<br>  );<br><br>  <span class="hljs-comment">// If it&#x27;s safe to do so, skip attr / flow / gen for implicit classes</span><br>  <span class="hljs-keyword">if</span> (taskListener.isEmpty() &amp;&amp;<br>      implicitSourcePolicy == ImplicitSourcePolicy.NONE) &#123;<br>    todo.retainFiles(inputFiles);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!CompileState.ATTR.isAfter(shouldStopPolicyIfNoError)) &#123;<br>    <span class="hljs-keyword">switch</span> (compilePolicy) &#123;<br>      <span class="hljs-keyword">case</span> ATTR_ONLY:<br>        attribute(todo);<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> CHECK_ONLY:<br>        flow(attribute(todo));<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> SIMPLE:<br>        generate(desugar(flow(attribute(todo))));<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> BY_FILE: &#123;<br>        Queue&lt;Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; q = todo.groupByFile();<br>        <span class="hljs-keyword">while</span> (!q.isEmpty() &amp;&amp; !shouldStop(CompileState.ATTR)) &#123;<br>          generate(desugar(flow(attribute(q.remove()))));<br>        &#125;<br>      &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> BY_TODO:<br>        <span class="hljs-keyword">while</span> (!todo.isEmpty())<br>          <span class="hljs-comment">// 3. 分析及字节码生成</span><br><span class="hljs-comment">// 3.1 attribute()标注</span><br>          <span class="hljs-comment">// 3.2 flow()数据流分析</span><br>          <span class="hljs-comment">// 3.3 desugar()解语法糖</span><br>          <span class="hljs-comment">// 3.4 generate()生成字节码</span><br>          generate(desugar(flow(attribute(todo.remove()))));<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">default</span>:<br>        Assert.error(<span class="hljs-string">&quot;unknown compile policy&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Abort ex) &#123;<br><span class="hljs-comment">//…………</span><br></code></pre></td></tr></table></figure><p>&emsp;从javac代码总体结构来看，编译过程大致分为1个准备过程和3个处理过程。</p><p>&emsp;准备过程：0. 初始化插入式注解处理器。</p><p>&emsp;处理过程：1. 解析与填充符号表。2. 插入式注解处理器的注解处理。3. 分析与字节码生成。</p><p>&emsp;如果注解处理器在处理注解期间对语法树进行了修改，编译器将回到解析和填充符号表的过程进行重新处理，直到注解处理器没有再对语法树进行修改为止。如下图所示。</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3098697451,1415732504&fm=15&gp=0.jpg" alt="javac编译过程"></p><blockquote><p>解析与填充符号表</p></blockquote><p>&emsp;词法、语法分析。将源码的字符流转变为标记集合，构造出抽象语法树。</p><p>&emsp;填充符号表。产生符号地址和符号信息。</p><blockquote><p>插入式注解处理器的注解处理</p></blockquote><blockquote><p>分析与字节码生成</p></blockquote><p>&emsp;标注检查。检查语法静态信息。</p><p>&emsp;数据流及控制流分析。检查程序动态运行过程。</p><p>&emsp;解语法糖。将简化代码编写的语法糖还原为原有形式。</p><p>&emsp;字节码生成。将前面各个步骤生成的信息转化为字节码。</p><h3 id="1-1-解析与填充符号表"><a href="#1-1-解析与填充符号表" class="headerlink" title="1.1 解析与填充符号表"></a>1.1 解析与填充符号表</h3><p>&emsp;Parse()解析字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> JCCompilationUnit <span class="hljs-title">parse</span><span class="hljs-params">(JavaFileObject filename, CharSequence content)</span> </span>&#123;<br>  <span class="hljs-comment">//……</span><br>  <span class="hljs-comment">//词法分析，生成Token集合</span><br>  Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,<br>                                            lineDebugInfo, filename.isNameCompatible(<span class="hljs-string">&quot;module-info&quot;</span>, Kind.SOURCE));<br>  <span class="hljs-comment">//语法分析，构造抽象语法树</span><br>    tree = parser.parseCompilationUnit();<br><span class="hljs-comment">//……</span><br>  <span class="hljs-keyword">return</span> tree;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>&emsp;将源代码的字符流转换为标记（Token）集合。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>&emsp;根据Token集合构造抽象语法树。语法树每一个节点代表着代码中的语法结构，比如包、类型、运算符等。</p><h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><p>&emsp;符号表=&lt;符号地址, 符号信息&gt;，它类似于哈希表。符号表中登记的信息在在编译的不同阶段都会用到。填充完后会产生一个待处理列表，其中包含了每一个抽象语法树的顶级节点以及package-info.java的顶级节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;JCCompilationUnit&gt; <span class="hljs-title">enterTrees</span><span class="hljs-params">(List&lt;JCCompilationUnit&gt; roots)</span> </span>&#123;<br>      <span class="hljs-comment">//……</span><br>       <span class="hljs-comment">//填充符号表</span><br>        enter.main(roots);<br>       <span class="hljs-comment">//填充结束</span><br>        enterDone();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-注解处理器"><a href="#1-2-注解处理器" class="headerlink" title="1.2 注解处理器"></a>1.2 注解处理器</h3><p>&emsp;插入式注解处理器，可以看作是一组编译器的插件。当这些插件工作时，允许读取、修改、增加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到是所有的注解处理器都不再对语法树进行修改为止。</p><p>&emsp;著名的效率工具Lombok就是通过注解来实现对编译过程中的字段的进行getter/setter等处理的。</p><h3 id="1-3-语义分析与字节码生成"><a href="#1-3-语义分析与字节码生成" class="headerlink" title="1.3 语义分析与字节码生成"></a>1.3 语义分析与字节码生成</h3><p>&emsp;<code>int a = 1;boolean b = true;char c = a + b;</code>这3条语句，在词法分析语法分析时都没有问题，可以生成合法的语法树，但是语句3是错误的。因此必须对抽象语法树进行语义分析。</p><p>&emsp;语义分析分为标注检查和数据流控制流分析2步。</p><h4 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h4><p>&emsp;这一步主要做的工作如下。</p><p>&emsp;检查：变量使用前是否已经被声明、变量与赋值之间的数据类型是否匹配</p><p>&emsp;优化：常量折叠。比如<code>int a = 1 + 2;</code>会优化成<code>int a = 3;</code></p><h4 id="数据流及控制流分析"><a href="#数据流及控制流分析" class="headerlink" title="数据流及控制流分析"></a>数据流及控制流分析</h4><p>&emsp;检查：局部变量在使用前是否已经赋值，方法的每条路径是否有返回值、受检异常是否做了正确处理等。</p><p>&emsp;这一步检查和类加载时的数据和控制流检查的目的是一致的，但是有些检查只能在语义分析时检查出来。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fo1</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> arg)</span></span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span> = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fo2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;以上2个方法的编译出来的字节码是一样的，因为局部变量在常量池中没有CONSTAN_Fieldref_info的引用，因此不可能存访问标志信息，自然在Class文件中不可能判断一个局部变量是否被声明为final了。变量的不变性只能由javac在编译意见进行数据流及控制流分析的时候来保证。</p><h4 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h4><p>&emsp;语法糖其实是对语法的简化，Java最常见的语法糖是泛型、变长参数、自动装拆箱等。java虚拟机在运行时并不直接支持这些语法，因此在编译阶段他们必须被还原成基础语法结构。这个还原的过程被称为解语法糖。具体如何解请看下一节。</p><h4 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h4><p>&emsp;该阶段主要是把前面各个步骤生成的信息语法树和符号表转化为字节码指令写到磁盘中。此外，还会进行少量的代码添加和转换工作。</p><p>&emsp;比如，实例构造器的<code>&lt;init&gt;()</code>和类构造器的<code>&lt;clinit&gt;()</code>方法就是在这个阶段被添加的。注意：这不是默认的构造函数，默认构造函数生成这一步在填充符号表阶段就已经完成。</p><p>&emsp;<code>&lt;init&gt;()</code>和<code>&lt;clinit&gt;()</code>实际上是代码收敛的过程。编译器会把语句块<code>&#123;&#125;</code>、实例变量初始化、调用父类的实例构造器等操作收敛到<code>&lt;init&gt;()</code>中，把语句块<code>static&#123;&#125;</code>、类变量初始化、调用<code>java.lang.lang.Object的&lt;init&gt;</code>方法等操作都收敛到<code>&lt;clinit&gt;()</code>中，并且保证无论源码中顺序出现如何，都一定按照先执行父类的实例构造器、然后初始化变量、最后执行语句块的顺序进行。</p><p>&emsp;再比如，吧字符串的<code>+</code>操作替换为StringBuffer或StringBuilder的append操作。</p><p>&emsp;完成了对语法树的遍历和调整之后，就会把填充了所需信息的符号交到类<code>com.sun.tools.javac.jvm.ClassWriter</code>中，有这个类的<code>writeClass()</code>方法输出字节码，生成最终的Class文件，到此，整个编译过程结束。</p><h2 id="2-Java语法糖"><a href="#2-Java语法糖" class="headerlink" title="2. Java语法糖"></a>2. Java语法糖</h2><h3 id="2-1-泛型"><a href="#2-1-泛型" class="headerlink" title="2.1 泛型"></a>2.1 泛型</h3><p>&emsp;泛型，就是”参数化类型“，将类型由原来的具体的类型参数化，类似于变量参数。</p><p>&emsp;<em>泛型</em>类就是把<em>泛型</em>定义在类上，用户使用该类的时，才把类型明确下来。</p><p>&emsp;Java中的集合是支持协变的，泛型出现之前就有ArrayList、HashMap等类型，这类集合里面，可以存放不同类型的值，比如<code>ArrayList list = new ArrayList();list.add(1);list.add(&quot;x&quot;);</code>程序运行没有任何问题。但是在取数据时，必须对每一个数据进行类型转换，如果转换出错容易造成程序崩溃，比如<code>(Integer)list.get(i)</code>对第一个元素没问题，取第二个元素时会报错。因此，为了保证集合的<strong>类型安全</strong>，<strong>消除强制类型转换</strong>，<strong>提高jvm性能</strong>，诞生了泛型这个概念。</p><p>&emsp;java要求引入泛型必须对原有的JDK向下兼容，为了满足这个条件，引入泛型有2种兼容方式</p><ol><li>需要泛型化的类型（主要是容器），原有的保持不变，然后平行的加一套泛型化版本的新类型。</li><li>直接把已有的类型泛型化，即原地泛型化。</li></ol><p>&emsp;C#选择了第一种，System.Collections和System.Collections.Specialized容器类并行存在。而java则选择了第2种。因为当时由于历史原因，java中存在Vecto、ArrayList等新旧集合类，如果采用方式一的话，则会出现<code>Vector</code>、<code>ArrayList</code>、<code>Vector&lt;T&gt;</code>和<code>ArrayList&lt;T&gt;</code>等，一个类型出现4种类这样的容器集合，会被开发者骂死吧。</p><p>&emsp;基于此java选择了上述第二种原地泛型化，实现上采用了<strong>类型擦除</strong>。</p><blockquote><p>类型擦除</p></blockquote><p>&emsp;已有类型泛型化，为了兼容性，保证<code>ArrayList</code>和<code>ArrayList&lt;T&gt;</code>在同一个容器里面，因此必须使得泛型化类<code>ArrayList&lt;T&gt;</code>是裸类型<code>ArrayLsit</code>的子类，否则类型转换就是不安全的。</p><p>&emsp;裸类型如何实现呢？有2种方式，第1种是运行期由java虚拟机来自动、真实的构造出<code>ArrayList&lt;Integer&gt;</code>这样的类型，并且自动实现从<code>ArrayList&lt;Integer&gt;</code>继承自<code>ArrayList</code>来满足裸类型定义。第2种是直接在编译时，把<code>ArrayList&lt;Integer&gt;</code>还原成<code>ArrayList</code>，只在元素访问、修改时自动插入一些强制类型转换和检查指令。java选择了后者，也就是<strong>类型擦除</strong>。</p><p>&emsp;比如以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;苏&quot;</span>);<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;文&quot;</span>);<br>System.out.println(map.get(<span class="hljs-string">&quot;a&quot;</span>));<br>System.out.println(map.get(<span class="hljs-string">&quot;b&quot;</span>));<br><br><span class="hljs-comment">//将以上代码编译后，再反编译回来，显示代码如下，比如直接在IDEA里面打开test.class文件即可看到</span><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;苏&quot;</span>);<br>map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;文&quot;</span>);<br>System.out.println((String)map.get(<span class="hljs-string">&quot;a&quot;</span>));<br>System.out.println((String)map.get(<span class="hljs-string">&quot;b&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p> 类型擦除的缺点</p></blockquote><p>&emsp;<strong>泛型慢</strong></p><p>&emsp;我们知道<code>&lt;ArrayList&lt;int&gt;&gt;</code>这种写法是不允许的，编译器会直接报错。那是因为如果允许的话，比如以下代码，由于泛型信息被擦除了，由于java不支持int、long和Object之间的类型转换，所以强制转换无法进行。为此，设计者干脆设计成泛型必须使用Integer等包装类型，不支持原生类型的泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;<span class="hljs-keyword">int</span>&gt; l1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//编译报错</span><br>ArrayList&lt;<span class="hljs-keyword">long</span>&gt; l2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">//编译报错</span><br>ArrayList l;<br>l = l1;<br>l = l2;<br><br><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>ArrayList&lt;Integer&gt; l1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>l1.add(a);<br>l1.add(b);<br><br><span class="hljs-comment">//class文件反编译后看到是</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>ArrayList&lt;Integer&gt; l1 = <span class="hljs-keyword">new</span> ArrayList();<br>l1.add(Integer.valueOf(a));<br>l1.add(Integer.valueOf(b));<br></code></pre></td></tr></table></figure><p>&emsp;设计者觉得既然都做了自动类型的强制转换，那就把原生类型的装箱、拆箱都做了，于是泛型出现了无数的拆箱、包装的开销，这也是导致java泛型慢的重要原因。</p><p>&emsp;<strong>运行期无法获取泛型信息</strong></p><p>&emsp;由于类型擦除，运行期是无法获取泛型信息的，这样会导致一些代码变得很复杂。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType)&#123;<br>T[] array = (T[])Array.newInstance(componentType, list.size());<br> <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;对重载也会产生影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译会报错，这两个方法无法共存，因为类型擦除后，他们的特征签名一模一样</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tt</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tt</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//but添加不同返回值后，可以共存，</span><br><span class="hljs-comment">//并不是因为返回值参与了重载，方法的重载要求方法具备不同的特征签名，返回值不包括在签名中</span><br><span class="hljs-comment">//而是class文件中只要描述符不是完全一致的方法，就可以共存</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tt</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">tt</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>&emsp;java泛型的引入，对虚拟机的解析、反射等都有可能产生影响，为此JCP修改了java虚拟机规范，引入了<code>Signature、LocalVariableTypeTable</code>等新的属性，用于解决伴随泛型而来的参数类型的识别问题。</p><h3 id="2-2-自动装箱、拆箱和遍历循环"><a href="#2-2-自动装箱、拆箱和遍历循环" class="headerlink" title="2.2 自动装箱、拆箱和遍历循环"></a>2.2 自动装箱、拆箱和遍历循环</h3><p>&emsp;自动拆箱、装箱在编译之后会被转换为对应的包装<code>Integer.valueOf(a)</code>和还原方法<code>int i = (Integer)var4.next();</code>。遍历则是把代码还原成迭代器的实现，所以我们可以看到可以遍历循环的集合全部都实现了Iterable接口。<code>ArrayList implements List extends Collection extends Iterable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>List&lt;Integer&gt; list = Arrays.asList(a, b);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : list) &#123;<br>System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">1</span>;<br>Integer b = <span class="hljs-number">2</span>;<br>Integer c = <span class="hljs-number">3</span>;<br>Integer d = <span class="hljs-number">3</span>;<br>Integer e = <span class="hljs-number">321</span>;<br>Integer f = <span class="hljs-number">321</span>;<br>Long g = <span class="hljs-number">3L</span>;<br>#1 System.out.println(c == d);//true<br>#2 System.out.println(e == f);//false<br>#3 System.out.println(c == (a + b));//true<br>#4 System.out.println(c.equals(a + b));//true<br>#5 System.out.println(g == (a + b));//true<br>#6 System.out.println(g.equals(a + b));//false<br></code></pre></td></tr></table></figure><p>&emsp;上述abcdefg在定义时就会发生装箱行为，<code>Integer a = Integer.valueOf(1)</code>，先看valueOf和intValue代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//valueOf</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br><span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br><br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//equals</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>    <span class="hljs-keyword">return</span> value == ((Integer)obj).intValue();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">//拆箱</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intValue</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;从代码我们可以看到，默认情况下，-127到128这256个数字，是存放在IntegerCache的cache[]数组里面的，因此在范围内的数字，实际上都是取得数组里的值，范围之外的是新对象，因此#1为true，#2为false。</p><p>&emsp;其他Long、Short、Boolean、Byte和Character的valueOf类似于Integer，因为是有限的。而Double和FLoat则是无法确定范围内数字的个数，因此每一个Double和Float都是一个新的对象。</p><p>&emsp;当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而<strong>如果其中有一个操作数是表达式则比较的是数值</strong>（即会触发自动拆箱的过程）。因此#3、#5均为true。</p><p>&emsp;从equals的代码可以看出，不仅比较数值，还比较类型。因此#4 true，#6 false。</p><h3 id="2-3-条件编译"><a href="#2-3-条件编译" class="headerlink" title="2.3 条件编译"></a>2.3 条件编译</h3><p>&emsp;条件编译是指：编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃。比如C的 <code>#ifdef</code></p><p>&emsp;java的条件编译只发生在条件为常量的if语句中。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>)&#123;A&#125;<br><span class="hljs-keyword">else</span>&#123;B&#125;<br><span class="hljs-comment">//编译之后只剩</span><br>A<br>  <br>  <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">false</span>)&#123;A&#125; <br><span class="hljs-comment">//编译之后直接删掉</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节码指令简介</title>
    <link href="/2021/01/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/01/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>&emsp;java虚拟机的指令由一个字节长度的，代表某种含义的数字（操作码，Opcode），以及跟在后面的若干参数组成。由于java虚拟机采用基于栈的指令集机构，因此大多数指令都只有操作码，参数则存在于操作数栈中。</p><p>&emsp;字节码指令集只占1个字节，因此不会最多256条（0~255）。class文件编译后不会执行操作数长度对齐，因此在处理超过一个字节的数据时，必须重建出具体的数据结构，比如将1个16位长度的无符号整数使用2个无符号字节存起来。这种操作某种程度上会损失一些性能，但是由于放弃了长度对齐，可以节省大量的填充和符号间隔。</p><p>&emsp;忽略掉异常，Java虚拟机解释器的执行模型大概如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">do</span>&#123;<br>  pc寄存器值+<span class="hljs-number">1</span><br>  根据pc寄存器指示的位置，从字节码流中取出操作码<br>  <span class="hljs-keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数<br>  执行操作码所定义的操作<br>&#125;<span class="hljs-keyword">while</span>(字节码流长度 &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="1-加载和存储指令"><a href="#1-加载和存储指令" class="headerlink" title="1. 加载和存储指令"></a>1. 加载和存储指令</h2><p>&emsp;将局部变量加载到操作数栈：<code>iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;</code>均以下省略_n，代表槽</p><p>&emsp;将数值从操作数栈存储到局部变量表：<code>istore、lstore、fstore、dstore、astore</code></p><p>&emsp;将常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst、lconst、fconst、dconst</code></p><p>&emsp;扩充局部变量表的访问索引指令：<code>wide</code></p><h2 id="2-运算指令"><a href="#2-运算指令" class="headerlink" title="2. 运算指令"></a>2. 运算指令</h2><p>&emsp;加法：<code>iadd、ladd、fadd、dadd</code><br>&emsp;减法：<code>isub、lsub、fsub、dsub</code><br>&emsp;乘法：<code>imul、lmul、fmul、dmul</code><br>&emsp;除法：<code>idiv、ldiv、fdiv、ddiv</code><br>&emsp;取余：<code>irem、lrem、frem、drem</code><br>&emsp;取反：<code>ineg、lneg、fneg、dneg</code><br>&emsp;位移：<code>ishl、ishr、iushr、lshl、lshr、lushr</code><br>&emsp;按位或：<code>ior、lor</code><br>&emsp;按位与：<code>iand、land</code><br>&emsp;按位异或：<code>ixor、lxor</code><br>&emsp;局部变量自增：<code>iinc</code><br>&emsp;比较：<code>dcmpg、dcmpl、fcmpg、fcmpl、lcmp</code></p><h2 id="3-类型转换指令"><a href="#3-类型转换指令" class="headerlink" title="3. 类型转换指令"></a>3. 类型转换指令</h2><p>&emsp;java虚拟机直接支持小范围到大范围的安全转换，比如int -&gt; long、float、double等。</p><p>显示转换指令：<code>i2b、i2c、i2s、l2i、f2l、d2i、d2l、d2f</code></p><h2 id="4-对象创建指令"><a href="#4-对象创建指令" class="headerlink" title="4. 对象创建指令"></a>4. 对象创建指令</h2><p>&emsp;创建类实例：<code>new</code><br>&emsp;创建数组：<code>newarray、anewarray、multianewarray</code><br>&emsp;访问类字段：<code>getstatic、putstatic</code><br>&emsp;访问实例字段：<code>getfield、putfield</code><br>&emsp;加载数组元素到操作数栈：<code>baload、caload、saload、iaload、laload、faload、daload、aaload</code><br>&emsp;存储操作数栈的值到数组元素中：<code>bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore、</code><br>&emsp;取数组长度：<code>arraylength</code><br>&emsp;检查实例类型：<code>instanceod、checkcast</code></p><h2 id="5-操作数栈管理指令"><a href="#5-操作数栈管理指令" class="headerlink" title="5. 操作数栈管理指令"></a>5. 操作数栈管理指令</h2><p>&emsp;弹出操作数栈栈顶1到2个元素：<code>pop、pop2</code><br>&emsp;复制栈顶1或2个元素并重新入栈：<code>dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</code><br>&emsp;栈顶两个数值互换：<code>swap</code></p><h2 id="6-控制转移指令"><a href="#6-控制转移指令" class="headerlink" title="6. 控制转移指令"></a>6. 控制转移指令</h2><p>&emsp;条件分支：<code>ifeg、iflt、ifne、ifgt、ifnull、ifnonnull、if_icmp eq、if_icmp ne、if_icmp lt、if_icmp gt、if_icmp le、if_icmp ge、if_acmp eq、if_acmp ne</code></p><p>&emsp;符合条件分支：<code>tableswitch、lookupswitch</code></p><p>&emsp;无条件分支：<code>goto、goto_w、jsr、jsr_w、ret</code></p><h2 id="7-方法调用和返回指令"><a href="#7-方法调用和返回指令" class="headerlink" title="7. 方法调用和返回指令"></a>7. 方法调用和返回指令</h2><ul><li>调用指令</li></ul><p>&emsp; <code>invokevirtual</code>：实例方法<br>&emsp; <code>invokeinterface</code>：接口方法<br>&emsp; <code>invokeinspecial</code>：构造方法、私有方法、父类方法<br>&emsp; <code>invokestatic</code>：静态方法<br>&emsp; <code>invokedynamic</code>：运行时动态解析出调用点限定符所引用的方法</p><ul><li>返回指令</li></ul><p>&emsp;<code>ireturn、lreturn、freturn、dreturn、areturn</code>注意：返回值为boolean、byte、char、short、int时采用ireturn指令</p><h2 id="8-异常指令"><a href="#8-异常指令" class="headerlink" title="8. 异常指令"></a>8. 异常指令</h2><p>&emsp;显示抛出的异常：<code>athrow</code><br>&emsp;catch中捕获的异常不是字节码指令实现的，而是采用异常表。</p><h2 id="9-同步指令"><a href="#9-同步指令" class="headerlink" title="9. 同步指令"></a>9. 同步指令</h2><p>&emsp;方法级的同步无需字节码指令控制，它实现在方法调用和返回之中。当调用时会检查方法表结构中的ACC_SYNCHRONIZED权限，如果设置了则会先获取管程（锁），执行完毕释放管程。如果抛出异常且没有处理此异常，管程将会在异常抛到方法边界之外时自动释放。</p><p>&emsp; synchronized语句块指令：<code>monitorenter、monitorexit</code></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java内存模型</title>
    <link href="/2021/01/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/01/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-硬件内存架构"><a href="#1-硬件内存架构" class="headerlink" title="1. 硬件内存架构"></a>1. 硬件内存架构</h1><p>&emsp;我们知道，在计算机中，由于处理器和存储设备之间的运算速度有着数量级的差距，为了解决这个问题，现代计算机会加入一或多层告诉缓存（Cache）来作为内存和处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，运算结束后再从缓存同步会内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>&emsp;<strong>运作原理</strong>：通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。</p><p><img src="https://pic1.zhimg.com/80/v2-bfb5daff43e7f6593057f8871f5e5888_1440w.jpg" alt="硬件内存架构"></p><h2 id="现代硬件内架构出现的问题："><a href="#现代硬件内架构出现的问题：" class="headerlink" title="现代硬件内架构出现的问题："></a>现代硬件内架构出现的问题：</h2><p>&emsp;主要出现在多线程的情况下。</p><h3 id="emsp-缓存一致性问题"><a href="#emsp-缓存一致性问题" class="headerlink" title="&emsp;缓存一致性问题"></a>&emsp;<strong>缓存一致性问题</strong></h3><p>&emsp;在多核处理器中，每个处理器都有自己的高速缓存，他们共享同一主内存，因此有可能会导致各自缓存数据不一致问题。为了解决一致性问题，需要各个处理器访问缓存时遵循一些协议，读写时根据协议操作，比如MSI、MESI、MOSI、Dragon Protocol等。</p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1006537827,1146975882&fm=11&gp=0.jpg" alt="处理器、高速缓存和主内存的交互"></p><h3 id="emsp-指令重排序问题"><a href="#emsp-指令重排序问题" class="headerlink" title="&emsp;指令重排序问题"></a>&emsp;<strong>指令重排序问题</strong></h3><p>&emsp;为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p><h1 id="2-Java内存模型"><a href="#2-Java内存模型" class="headerlink" title="2. Java内存模型"></a>2. Java内存模型</h1><p> &emsp;<strong>内存模型</strong>可以理解为在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，java虚拟机也有自己的内存模型（Java Memory Model， JMM）。</p><p>&emsp;java内存模型的主要目的是定义程序中各种变量的访问规则，关注点在虚拟机把变量值存储到内存和从内存中取出来的底层细节。</p><p><img src="https://pic2.zhimg.com/80/v2-bd607bd9a5598a8330ad329033e04b91_1440w.jpg" alt="java内存模型"></p><p><img src="https://pic3.zhimg.com/80/v2-a1a75c9f7264cf78d0927663371ca9d2_1440w.jpg" alt="java内存模型"></p><ul><li>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</li><li>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</li><li>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在线程栈上，即使这些方法所属的对象存放在堆上。</li><li>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</li><li>静态成员变量跟随着类定义一起也存放在堆上。</li><li>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。</li></ul><h2 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h2><p>&emsp;</p><p><img src="https://pic3.zhimg.com/80/v2-037270b0876b6af680d1832bcc9dca32_1440w.jpg" alt="主内存与工作内存"></p><p>&emsp;JMM规定了所有的变量都存储在主内存中，内存保存了被该线程使用的变量的主内存副本。<strong>线程对变量的所有操作都会必须在工作内存中完成</strong>，不能直接读写主内存数据。不同线程之间无法直接访问对方线程的变量，他们之间的通讯需要通过主内存来完成。</p><p>&emsp;这里的内存不同于虚拟机运行时内存，这两者没什么联系。如果非要联系，从定义看，主内存对应于java堆中的对象实例数据部分，工作内存对应于虚拟机栈（因为虚拟机栈是线程私有的）。从基础层面看，主内存对应于物理机的主内存，工作内存对应于寄存器或者高速缓存。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Fproduct%2Fed0252f86ffe4ec78ecdc72089ec3f48.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1616308476&t=97a82dff545580e8c4b4574c91189d5e" alt="虚拟机运行时内存"></p><h2 id="2-2-线程间通信"><a href="#2-2-线程间通信" class="headerlink" title="2.2 线程间通信"></a>2.2 线程间通信</h2><p>&emsp;线程间通信必须要经过主内存。如果线程A与线程B之间要通信的话，必须要经历2个步骤：</p><ul><li><p>线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p></li><li><p>线程B到主内存中去读取线程A之前已更新过的共享变量。</p></li></ul><p>&emsp;主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><p><b style="color:red">lock（锁定）</b>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p><p><b style="color:red">unlock（解锁）</b>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p><p><b style="color:red">read（读取）</b>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p><p><b style="color:red">load（载入）</b>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p><p><b style="color:red">use（使用）</b>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p><p><b style="color:red">assign（赋值）</b>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p><p><b style="color:red">store（存储）</b>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p><p><b style="color:red">write（写入）</b>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p><p>&emsp;把变量从主内存拷贝到工作内存中需要按顺序执行<code>read</code>和<code>load</code>操作，从工作内存同步回主内存需要按顺序执行<code>store</code>和<code>write</code>操作。只要求这两者顺序，但是中间可以穿插其他操作。比如，read a、read b、load b、load a。</p><p>&emsp;以上8种操作必须满足以下规则：</p><ul><li><code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>必须成对出现，不允许出现单一操作。比如主内存读取了，但是工作内存不接受操作🈲</li><li>不允许一个线程丢弃它的最近<code>assign</code>的操作，即变量在工作内存中改变了之后必须同步到主内存中</li><li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从工作内存同步回主内存中</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量。即对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作</li><li>一个变量在同一时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。<code>lock</code>和<code>unlock</code>必须成对出现</li><li>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值</li><li>不允许<code>unlock</code>一个未被<code>lock</code>的变量，不允许<code>unlock</code>一个被其他线程锁定的变量</li><li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步到主内存中（执行<code>store</code>和<code>write</code>操作）</li></ul><h2 id="2-3-Java内存模型解决的问题"><a href="#2-3-Java内存模型解决的问题" class="headerlink" title="2.3 Java内存模型解决的问题"></a>2.3 Java内存模型解决的问题</h2><p>&emsp;在Java多线程中，Java提供了一系列与并发处理相关的关键字，比如<code>volatile</code>、<code>synchronized</code>、<code>final</code>、<code>concurren</code>包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>&emsp;Java内存模型的本质是围绕着Java并发过程中的如何处理<code>原子性</code>、<code>可见性</code>和<code>顺序性</code>这三个特征来设计的。</p><p>&emsp;Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与<strong>可见性</strong>（多线程缓存与指令重排序）、多线程写同步问题与<strong>原子性</strong>（多线程竞争race condition）。</p><h4 id="多线程读同步问题与可见性"><a href="#多线程读同步问题与可见性" class="headerlink" title="多线程读同步问题与可见性"></a>多线程读同步问题与可见性</h4><blockquote><p>可见性：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。</p></blockquote><p><b style="color:red">线程缓存导致的可见性问题</b></p><p>&emsp;如果两个或多个线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，线程的更新操作对其他线程是不可见的，因为共享变量没有被同步回主内存中。这样可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。由此导致了共享变量不可见。JMM中解决这个内存可见性问题可以使用如下两种方式：</p><ul><li>使用<code>volatile</code>关键字：<ul><li>volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。</li><li>volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。</li><li>关于volatile请细看下一小节</li></ul></li><li>使用<code>synchronized</code>关键字：<ul><li>synchronized实际上是对代码块执行了lock和unlock操作，前面关于lock和unlock的规则中，“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”、”lock操作会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值“这两条决定了其可见性。</li></ul></li><li>使用<code>final</code>关键字：<ul><li>被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）。</li></ul></li></ul><p><b style="color:red">重排序导致的可见性问题</b></p><p>&emsp;为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行，比如对于那些没有依赖关系的指令，处理器可能会把他们进行重排序。重排序一般有3种类型：编译器优化的重排序、指令级并行的重排序和内存系统的重排序。</p><p>&emsp;在多线程环境下，重排序可能会导致一些可见性问题，比如以下，线程A的步骤1和2没有依赖关系所以有可能被重排，导致步骤2先于步骤1执行。这样会导致：线程B在步骤4读共享变量时，不一定能看到写线程A在执行1时对共享变量的修改，因为由于重排，1的操作被延后到4之后了。</p><p><img src="https://pic4.zhimg.com/80/v2-8ef063a1b514d9cfbdf059984f83ed2f_1440w.jpg" alt="线程执行时序"></p><p>&emsp;Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性：</p><ul><li><code>volatile</code>关键字本身就包含了禁止指令重排序的语义</li><li><code>synchronized</code>则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入</li></ul><h3 id="多线程写同步问题与原子性"><a href="#多线程写同步问题与原子性" class="headerlink" title="多线程写同步问题与原子性"></a>多线程写同步问题与原子性</h3><p>&emsp;当多个线程在访问未被同步机制保护的代码时，可能会发生同步写的问题。比如A和B线程都对变量i进行++操作，A先读i，接着B读i，然后A++i同步回主内存，B++i同步回主内存。此时i的预期+2实际+1，这就出现了不同步的问题。</p><blockquote><p>原子性：指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。</p></blockquote><p>&emsp;<strong>使用原子性保证多线程写同步问题</strong></p><p>&emsp;原子性的实现：<code>read</code>、<code>load</code>、<code>assign</code>、<code>use</code>、<code>store</code>、<code>write</code>这6种操作都是原子性的。</p><ul><li><p>java中基本数据类型变量（long和double除外）、引用类型变量、声明为volatile的任何类型变量的访问读写是具备原子性的</p></li><li><p><code>long</code>和<code>double</code>则不一定。java虚拟机允许<strong>未被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行</strong>，这样可能导致多个线程读取到的变量是”半个变量“，即第一次32位更新了但后一次32位没有。目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此写代码是不必专门声明<code>volatile long</code>等。</p></li><li><p><code>++ / --</code>等符合操作不具备原子性</p></li><li><p>同步代码块可以保证更大范围的原子性。<code>lock</code>和<code>unlock</code>操作可以满足，对应于<code>monitorenter</code>和<code>monitorexist</code>指令来使用这两个操作。反应到java代码中就是<code>synchronized</code>关键字。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>a=<span class="hljs-number">1</span>; b=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-4-volatile关键字"><a href="#2-4-volatile关键字" class="headerlink" title="2.4 volatile关键字"></a>2.4 volatile关键字</h2><p>&emsp;volatile型变量特点：</p><ul><li><p>保证此变量对所有线程的可见性，原因上一节有讲到。</p></li><li><p>禁止指令重排序优化</p></li></ul><p><b style="color:red">volatile变量对所有线程可见，但是却不一定能保证并发安全</b></p><p>&emsp;比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntVolatile</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        a++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                        increase();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-comment">//等待所有线程结束</span><br>        <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">1</span>)<br>            Thread.yield();<br><br>        System.out.println(a);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//increase()字节码         </span><br> 0: getstatic     #2                  // Field a:I<br>         <span class="hljs-number">3</span>: iconst_1<br>         <span class="hljs-number">4</span>: iadd<br>         5: putstatic     #2                  // Field a:I<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>&emsp;执行可以发现，最后的结果是一个小于200000的值。说明volatile并不能保证并发安全。问题出在<code>a++</code>自增运算上。从上述字节码我们可以看到，<code>getstatic</code>指令把a的值取到操作数栈栈顶，此时volatile可以保证取到的a是正确的，但是在执行后续操作<code>iconst_、idd</code>操作时，其他线程可能已经把a的值改变了，而栈顶的数就变成了过期数据，<code>putstatic</code>指令执行后可能把较小的值同步回主内存之中了。</p><p>&emsp;注意：一条字节码指令也不一定是原子的，因为它解释器可能运行多条代码。</p><p>&emsp;以上例子说明，<code>volatile</code>只保证可见性，并不保证原子性。当程序的运行结果不依赖volatile变量当前值，或者变量不需要其他状态变量共同参与不变约束的时候，必须加锁来保证其原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> shutdown;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>&#123;<br>  shutdown = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">do</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!shutdown)&#123;<br>    <span class="hljs-comment">//业务代码</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;以上例子就适合使用<code>volatile</code>来控制并发。</p><p><b style="color:red">volatile禁止指令重排序优化</b></p><p>&emsp;对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，<strong>插入特定类型的内存屏障</strong>（Memory Barriers，Intel称之为Memory Fence）指令，<strong>通过内存屏障指令来禁止特定类型的处理器重排序</strong>。</p><p>&emsp;通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p>&emsp;<strong>内存屏障类型</strong>如下，其中StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代处理器大多支持该屏障，但执行该屏障开销昂贵，因为需要把写缓冲区中的数据全部刷新到内存中。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3424114361,3727957794&fm=11&gp=0.jpg"></p><p>&emsp;<strong>JMM针对编译器制定volatile重排序规则：</strong></p><ul><li><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。 </p></li><li><p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。 </p></li><li><p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p></li></ul><p>&emsp;为了实现上述规则，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。 </li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。 </li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。 </li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p><b style="color:red">volatile和synchronized对比</b></p><ul><li>volatile同步机制性能确实优于synchronized锁，但是虚拟机对锁进行了许多优化和消除，因此无法说volatile比synchronized快多少</li><li>volatile变量的读操作性能消耗和普通变量几乎无差别</li><li>volatile变量的写操作会比普通变量慢，因为需要加各种内存屏障。但是大多时候，仍然比锁快。</li></ul><h2 id="2-5-先行发生（happens-before）原则"><a href="#2-5-先行发生（happens-before）原则" class="headerlink" title="2.5 先行发生（happens before）原则"></a>2.5 先行发生（happens before）原则</h2><p>&emsp;在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系。java中先天存在不需要任何其他手段来保证的先行发生原则有：</p><ul><li>程序次序规则：一个线程内，控制流程中书写在前面的操作先行于书写在后的操作</li><li>管程锁定规则：unlock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：一个volatileb变量的写操作先行于任意后续对这个变量的读操作</li><li>线程启动规则：线程中所有的操作都先行于该线程的终止检测</li><li>线程中断规则：interrupt()的调用先行于被检测线程的代码检测到中断时间的发生</li><li>对象终结规则：对象的初始化完成（构造函数结束）先行于finalize()方法</li><li>传递性：如果A 先行于 B，且B先行于 C，那么A先行于 C。</li></ul><p><strong>时间先后顺序和先行发生之间没有因果关系，衡量并发以先行发生原则为准。</strong></p><h1 id="3-Java内存模型和硬件内存架构之间的桥接"><a href="#3-Java内存模型和硬件内存架构之间的桥接" class="headerlink" title="3.  Java内存模型和硬件内存架构之间的桥接"></a>3.  Java内存模型和硬件内存架构之间的桥接</h1><p>&emsp;硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。</p><p><img src="https://pic3.zhimg.com/80/v2-1a7b7bb752799b6c067a0eaca0a1a9b2_1440w.jpg" alt=" Java内存模型和硬件内存架构之间的桥接"></p><ul><li>线程之间的共享变量存储在主内存（Main Memory）中</li><li>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。</li><li>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li><li>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而<strong>JVM的静态内存储模型（JVM内存模型）只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存</strong>。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-30e6d810eb6a8700a87fc06756aab984_1440w.jpg" alt="JMM的控制模型图"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="/2020/12/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2020/12/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<p>&emsp;JAVA虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，尽管现在JVM的实现各不相同，有<strong>编译执行</strong>（通过即时编译器产生本地代码执行，如BEA JRockit）也有<strong>解释执行</strong>（通过解释器执行，如Sun Classic VM）。但是从概念模型的角度来看，所有JAVA虚拟机的执行引擎都是一致的：<strong>输入的是字节码二进制流，处理过程是字节码解析的等效过程，输出的是执行结果</strong>。</p><h2 id="1-运行时栈帧结构"><a href="#1-运行时栈帧结构" class="headerlink" title="1. 运行时栈帧结构"></a>1. 运行时栈帧结构</h2><p>&emsp;&emsp;每个栈帧的内部存储这以下数据：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MjA1NDQzOTkzLnBuZw?x-oss-process=image/format,png" alt="栈帧的内部结构"><br>&emsp;栈帧的大小取决于内部结构的大小。<strong>在编译java源程序的时候，栈帧中需要多大的局部变量表、需要多深的操作数栈都已经被计算出来，并且写入到了方法表的Code属性中。</strong></li></ul><h3 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h3><ul><li>局部变量表又被称之为局部变量数组或本地变量表。</li><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型(8种)、对象引用（reference），以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>方法调用结束，方法栈帧出栈，局部变量表也会销毁。</li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVariablesTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>#14    public static void main(String[] args) &#123;<br>#15        LocalVariablesTest test = new LocalVariablesTest();<br>#16        int num = 10;<br>#17//        test.test1();<br>#18    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;执行反汇编<code>javap -v LocalVariablesTest.class</code>得到字节码指令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(java.lang.String[]);<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: new           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// class com/hk7/memory/LocalVariablesTest</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">10</span>: istore_2<br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    LineNumberTable:<br>      line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">16</span>: <span class="hljs-number">8</span><br>      line <span class="hljs-number">18</span>: <span class="hljs-number">11</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>      <span class="hljs-number">12</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>          <span class="hljs-number">8</span>       <span class="hljs-number">4</span>     <span class="hljs-number">1</span>  test   Lcom/hk7/memory/LocalVariablesTest;<br>         <span class="hljs-number">11</span>       <span class="hljs-number">1</span>     <span class="hljs-number">2</span>   num   I<br></code></pre></td></tr></table></figure><p>&emsp;由上可知，<code>locals=3</code>代表局部变量表大小为3，分别为args参数、test对象和num变量。代码指令一共12行，<strong>LineNumberTable</strong>表示pc指令地址和源码所在行的对应关系。<strong>LocalVariableTable</strong>局部变量表，<em>start</em>表示当前变量的作用域，变量都是定义之后生效，比如test的start是8，从LineNumberTable表可知，8对应line16，也就是从16行开始test变量生效。<em>length</em>表示变量作用域的长度，从表中可看到三个变量起始位置+长度=12，因此所有变量作用域的结束都是方法的}。<br><br></p><h4 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a><strong>关于Slot的理解</strong></h4><ul><li>1、参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>2、<strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种）、引用类型、returnAddress类型的变量。</li><li>3、在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。byte、short、char和boolean在存储前都会被转化成int。</li><li>4、JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。占两个slot的变量使用起始索引访问。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MjEyNDU0NDQ1LnBuZw?x-oss-process=image/format,png" alt="变量槽的索引访问"></li><li>5、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong>。</li><li>6、<strong>如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列</strong>。如下图jclasslib插件中可以看到字节码文件信息，test2位实例方法，它的this占了index=0的插槽。由于静态方法中栈帧局部变量表没有存储this变量，因此静态方法中无法使用<code>this.xxx</code>。<br><img src="https://img-blog.csdnimg.cn/20201012182107466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="this变量存储"></li></ul><h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a><strong>Slot的重复利用</strong></h4><p>局部变量槽是可以重复利用的，如果一个局部变量过了其作用域被销毁了，则下一个局部变量可以利用这个局部变量槽。比如以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> test4() &#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//b出了作用域，变量b被销毁，但是数组已经分配，因此c可以利用这个slot</span><br>    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>    <span class="hljs-built_in">int</span> c = a + <span class="hljs-number">1</span>;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> test4();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: istore_1<br>         <span class="hljs-number">2</span>: iconst_0<br>         <span class="hljs-number">3</span>: istore_2<br>         <span class="hljs-number">4</span>: iload_1<br>         <span class="hljs-number">5</span>: iconst_1<br>         <span class="hljs-number">6</span>: iadd<br>         <span class="hljs-number">7</span>: istore_2<br>         <span class="hljs-number">8</span>: iload_1<br>         <span class="hljs-number">9</span>: iconst_1<br>        <span class="hljs-number">10</span>: iadd<br>        <span class="hljs-number">11</span>: istore_2<br>        <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">36</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">38</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">39</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">43</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">44</span>: <span class="hljs-number">12</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">4</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>     b   I<br>            <span class="hljs-number">0</span>      <span class="hljs-number">13</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/LocalVariablesTest;<br>            <span class="hljs-number">2</span>      <span class="hljs-number">11</span>     <span class="hljs-number">1</span>     a   I<br>           <span class="hljs-number">12</span>       <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     c   I<br></code></pre></td></tr></table></figure><p><font color=green>&emsp;局部变量表和性能调优密切相关，局部变量表占了栈帧的主要空间，因此它和栈溢出息息相关。局部变量表中的变量是垃圾回收的根节点，被局部变量表中的直接或间接引用的对象不会被回收。</font></p><h3 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h3><p>&emsp;栈帧中的操作数栈Operand Stack采用数组来具体实现，也可被称之为表达式栈。操作数栈在方法的执行过程中，根据字节码指令，往栈中写入（入栈）或者提取（出栈）数据。<br>&emsp;操作数栈是栈（虚拟机栈）中栈（栈帧的操作数栈），它主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。<strong>局部变量表中的变量被操作的时候（比如执行i+j），会被压入操作数栈，经过一些指令(iadd)后再推出去，存储到局部变量表中</strong>。上述反汇编代码中的<code>stack=2</code>表示的是操作数栈的深度。</p><p>&emsp;栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>操作数栈的具体实例可以看4.2</p><h4 id="栈帧之间的数据共享"><a href="#栈帧之间的数据共享" class="headerlink" title="栈帧之间的数据共享"></a><font color="red"><b>栈帧之间的数据共享</b></font></h4><p>&emsp;一般情况下，两个栈帧之间的内存区域是独立的，但是JVM在实现过程中会进行一些优化，使两个栈帧之间共用一部分内存区域。</p><p>&emsp;两个栈帧之间数据共享，主要体现在方法调用中有参数传递的情况，上一个栈帧的部分局部变量表与下一个栈帧的操作数栈共用一部分空间，这样既节约了空间，也避免了参数的复制传递。</p><p><a href="https://blog.csdn.net/weixin_45642014/article/details/110868636">https://blog.csdn.net/weixin_45642014/article/details/110868636</a></p><p><a href="https://www.cnblogs.com/snake23/archive/2019/01/28/10329149.html">https://www.cnblogs.com/snake23/archive/2019/01/28/10329149.html</a></p><h4 id="栈顶缓存-Top-of-Stack-Cashing-技术"><a href="#栈顶缓存-Top-of-Stack-Cashing-技术" class="headerlink" title="栈顶缓存(Top-of-Stack-Cashing)技术"></a><font color="red"><b>栈顶缓存(Top-of-Stack-Cashing)技术</b></font></h4><p>&emsp;jvm简单介绍文章里面提到过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候需要使用更多的入栈和出栈指令，操作数栈存储在内存中，因此会导致频繁的内存读写，影响执行速度。为了解决这个问题HotSpot的提出了栈顶缓存技术。<br>&emsp;栈顶缓存是指将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎执行效率。</p><h3 id="1-3-动态链接"><a href="#1-3-动态链接" class="headerlink" title="1.3 动态链接"></a>1.3 动态链接</h3><p>&emsp;栈帧里面的<strong>动态链接、方法返回地址和一些附加信息</strong>有些地方把它们统称为<strong>帧数据区</strong>。<br>&emsp;动态链接又叫<strong>指向运行时常量池的方法引用</strong>。</p><ul><li><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>区域</p></li><li><p>包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>java源文件被编译为字节码文件后，<strong>所有的变量和方法的引用都会被保存到class文件的常量池（映射着的内存结构为方法区的运行时常量池）里面</strong></p></li><li><p>动态链接的作用是：<strong>把这些方法的符号引用转换为直接引用</strong></p></li></ul><p>  &emsp;如下图所示，栈帧中有一个区域专门用来存储方法引用。方法区内存是多线程共享的，假设方法A和方法B都调用方法C，那么在运行时常量池会有方法C的方法引用，方法A和方法B对应的栈帧中的区域都会存储该方法引用。</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA2MTAxMjUxODQ3LnBuZw?x-oss-process=image/format,png" alt="动态链接"></p><p>  &emsp;以下代码，methodB()调用methodA()，反汇编之后的结果如下。从结果中我们可以看到，方法b中有指令<code>5: invokevirtual #5</code>，invokevirtual代表调用方法，<code>#5</code>为方法引用，表示常量池中的<code>#5 = Methodref          #28.#29</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicLink</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br>        methodA();<br>        num++;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//javap -v xxx.class</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">hk7</span>.<span class="hljs-title">memory</span>.<span class="hljs-title">DynamicLink</span></span><br>  minor version: 0<br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = Fieldref           #8.#24         // com/hk7/memory/DynamicLink.num:I<br>   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;<br>   #4 = String             #27            // methodA()....<br>   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V<br>   #6 = String             #30            // methodB()....<br>   #7 = Methodref          #8.#31         // com/hk7/memory/DynamicLink.methodA:()V<br>   #8 = Class              #32            // com/hk7/memory/DynamicLink<br>   #9 = Class              #33            // java/lang/Object<br>  #10 = Utf8               num<br>  #11 = Utf8               I<br>  #12 = Utf8               &lt;init&gt;<br>  #13 = Utf8               ()V<br>  #14 = Utf8               Code<br>  #15 = Utf8               LineNumberTable<br>  #16 = Utf8               LocalVariableTable<br>  #17 = Utf8               this<br>  #18 = Utf8               Lcom/hk7/memory/DynamicLink;<br>  #19 = Utf8               methodA<br>  #20 = Utf8               methodB<br>  #21 = Utf8               SourceFile<br>  #22 = Utf8               DynamicLink.java<br>  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V<br>  #24 = NameAndType        #10:#11        // num:I<br>  #25 = Class              #34            // java/lang/System<br>  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;<br>  #27 = Utf8               methodA()....<br>  #28 = Class              #37            // java/io/PrintStream<br>  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V<br>  #30 = Utf8               methodB()....<br>  #31 = NameAndType        #19:#13        // methodA:()V<br>  #32 = Utf8               com/hk7/memory/DynamicLink<br>  #33 = Utf8               java/lang/Object<br>  #34 = Utf8               java/lang/System<br>  #35 = Utf8               out<br>  #36 = Utf8               Ljava/io/PrintStream;<br>  #37 = Utf8               java/io/PrintStream<br>  #38 = Utf8               println<br>  #39 = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.hk7.memory.DynamicLink();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         7: putfield      #2                  // Field num:I<br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #4                  // String methodA()....<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #6                  // String methodB()....<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: aload_0<br>         9: invokevirtual #7                  // Method methodA:()V<br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        14: getfield      #2                  // Field num:I<br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        19: putfield      #2                  // Field num:I<br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">18</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h3><p>&emsp;当方法开始执行后，只有2种方式退出该方法：</p><ol><li>遇到return等字节码指令，正常退出，正常调用完成。</li><li>遇到异常athrow指令，异常退出，异常调用完成。</li></ol><p>&emsp;无论哪一种方式退出，都必须返回到方法被调用的位置。正常退出时，pc计数器的值作为返回地址，栈帧中会保存这个值；异常退出时，返回地址通过异常处理器表来确定，栈帧中不会保存该部分值。</p><p>&emsp;方法退出等同于栈帧出栈，因此退出时，需要执行的操作包括：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整pc计数器的值以指向调用方下一条指令等。</p><h3 id="1-5-一些附加信息"><a href="#1-5-一些附加信息" class="headerlink" title="1.5 一些附加信息"></a>1.5 一些附加信息</h3><p>&emsp;《java虚拟机规范》中没有描述到的一些信息也可以保存在栈帧之中。比如调试、性能搜集等相关信息，取决于虚拟机具体的实现。</p><h2 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h2><h3 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h3><p>&emsp;在类加载阶段，class文件里面存储的都是符号引用，在类加载的解析阶段，如果被调用的目标方法在<strong>编译期可知，且运行期保持不变</strong>时，则会直接将方法的符号引用转化为直接引用。这类方法的调用被称为<strong>解析</strong>（Resolution）。</p><p>&emsp;满足编译期可知，运行期不变的方法有：静态方法、私有方法、实力构造器、父类方法、+ final修饰的方法(由invokevirtual指令调用)。这5种方法会在类加载的时候就把符号引用解析为直接引用，统称为“<strong>非虚方法</strong>”，除此之外的称为“<strong>虚方法</strong>”</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">invokestatic</span>   <span class="hljs-string">调用静态方法</span><br><span class="hljs-attr">invokespecial</span><span class="hljs-string">调用构造器&lt;init&gt;()方法、私有方法和父类中的方法</span><br><br><span class="hljs-attr">invokevirtual</span><span class="hljs-string">调用所有的虚方法</span><br><span class="hljs-attr">invokeinterface</span><span class="hljs-string">调用接口方法，运行时再确定一个实现实现该接口的对象</span><br><span class="hljs-attr">invokedynamic</span><span class="hljs-string">运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</span><br></code></pre></td></tr></table></figure><p>&emsp;查看以下say方法的调用，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>say();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//javap -v Test.class</span><br>&#123;<br>  <span class="hljs-keyword">public</span> com.hk7.memory.StackFrameTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/StackFrameTest;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span> <span class="hljs-keyword">throws</span> java.lang.InterruptedException</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">0</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: invokestatic  #2                  // Method say:()V             LOOK THIS<br>         <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">3</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">4</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>    Exceptions:<br>      <span class="hljs-keyword">throws</span> java.lang.InterruptedException<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #4                  // String hello<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">18</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;解析调用是一个<strong>静态</strong>的过程。</p><h3 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h3><p>&emsp;和解析调用想对应的是分派调用，它可能是静态的，也可能是动态的。按照分派的宗量数可以分为单分派和多分派。以上2种分类方式组合，构成了静态单分派、静态多分派、动态单分派和动态多分派四种。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDispatchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Human guy)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, guy!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Man man)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, gentleman!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Woman woman)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, lady!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br><br>        StaticDispatchTest sd = <span class="hljs-keyword">new</span> StaticDispatchTest();<br>        sd.say(man);<span class="hljs-comment">//Hello, guy!</span><br>        sd.say(woman);<span class="hljs-comment">//Hello, guy!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;先说说2个概念。</p><p>&emsp;Human叫做<strong>静态类型</strong>(Static Type)或者外观类型(Apparent Type)，Man和Woman叫做<strong>实际类型</strong>(Actual Type)或者<strong>运行时类型</strong>(Runtime Type)。</p><p>&emsp;静态类型和实际类类型在运行中都可能发生变化，区别在于静态类型的变化仅仅在使用中发生，变量本身的静态类型不会发生变化，且最终的静态类型在编译时可知。</p><p>&emsp;实例类型变化的结果在运行期才可知，编译前并不会知晓。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实际类型变化，a b的值可能变化，无法确定到底是哪一种类型</span><br>Human human = (a == b) ? <span class="hljs-keyword">new</span> Woman() : <span class="hljs-keyword">new</span> Man();<br><br><span class="hljs-comment">//静态类型变化，强制转换，编译期间可以确定</span><br>sd.say((Woman) human);<br>sd.say((Man) human);<br></code></pre></td></tr></table></figure><p>&emsp;以上代码，<code>man</code>和<code>woman</code>两个变量静态类型相同、实际类型不同。<b style="color:red">虚拟机在重载时，通过参数的静态类型来作为判定依据</b>。静态类型在编译期可知，因此在javac编译时，选择了say(Human)作为调用目标，并把这个方法的符号引用写到main()方法里面的两条invokevirtual指令的参数中。</p><p>&emsp;<b style="color:red">所有依赖静态类型来决定方法执行版本的分派动作，都叫做静态分派</b>，最典型的引用就是方法的重载。静态分派动作发生在编译期，而不是由虚拟机来执行的，因此有些资料把它归入“解析”，而不是“分派”。</p><p>&emsp;javac虽然能匹配到方法的版本，但有时候并不是唯一的，它只能匹配出“相对更合适的”方法。比如以下代码：重载方法匹配优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Overload</span> </span>&#123;<br><span class="hljs-comment">// Object 参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Object arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello object&quot;</span>);<br>&#125;<br><span class="hljs-comment">// int 参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello int&quot;</span>);<br>&#125;<br><span class="hljs-comment">// long 参数 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(<span class="hljs-keyword">long</span> arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello long&quot;</span>);<br>&#125;<br><span class="hljs-comment">// char 参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(<span class="hljs-keyword">char</span> arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello char&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Character 参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Character arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello character&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 变长参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(<span class="hljs-keyword">char</span>... arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello char...&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// Serializable 参数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(Serializable arg)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello serializable&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  say(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">//char、int、</span><br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">假设依次注释掉最匹配的方法，代码输出如下，</span><br><span class="hljs-comment">char   =&gt;   &#x27;hello char&#x27;</span><br><span class="hljs-comment">int    =&gt;   &#x27;hello int&#x27;    此处发生了类型转换，&#x27;a&#x27; =&gt; 97</span><br><span class="hljs-comment">long   =&gt;   &#x27;hello long&#x27;   &#x27;a&#x27; =&gt; int 97  =&gt; long 97</span><br><span class="hljs-comment">Character   =&gt;   &#x27;hello Character&#x27;   此时发生了装箱行为，&#x27;a&#x27; =&gt; java.lang.Character</span><br><span class="hljs-comment">Serializable   =&gt;   &#x27;helloSerializable&#x27;   装箱后发现Character没找到，但是找到了它的接口类型.    public final class Character implements java.io.Serializable, Comparable&lt;Character&gt; &#123;</span><br><span class="hljs-comment">Object   =&gt;   &#x27;hello Object&#x27;   装箱后，父类为Object</span><br><span class="hljs-comment">char...=&gt;  &#x27;hello char...&#x27;  变长参数的重载优先级是最低的。</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>&emsp;注意，Character实现了多个接口，如果定义了多个接口重载方法，那么编译器无法选择，会提示“Type Ambiguous”并拒绝编译。此时必须显示指定，比如<code>say(Comparable&lt;Character&gt;&#39;a&#39;)</code>。继承父类，会按照由子到父的顺序逐层转换。</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDispatchTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, gentleman!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello, lady!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Human man = <span class="hljs-keyword">new</span> Man();<br>        Human woman = <span class="hljs-keyword">new</span> Woman();<br>        man.say();<span class="hljs-comment">//hello, gentleman</span><br>        woman.say();<span class="hljs-comment">//hello, lady</span><br>        man = <span class="hljs-keyword">new</span> Woman();<br>        man.say();<span class="hljs-comment">//hello, lady</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&emsp;从以上代码输出，我们可以猜测，<strong>重写的实质是根据方法实际类型来选择方法版本</strong>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//javap -v StaticDispatchTest.class</span><br>  <span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: new           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/hk7/memory/DynamicDispatchTest$Man</span><br>         <span class="hljs-number">3</span>: dup<span class="hljs-comment">/*复制操作数栈顶元素再入栈，因为invokesepcial执行init会使用到*/</span><br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Man.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">7</span>: astore_1<br>         <span class="hljs-number">8</span>: new           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class com/hk7/memory/DynamicDispatchTest$Woman</span><br>        <span class="hljs-number">11</span>: dup<br>        <span class="hljs-number">12</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Woman.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">15</span>: astore_2<br>        <span class="hljs-number">16</span>: aload_1<br>        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Human.say:()V</span><br>        <span class="hljs-number">20</span>: aload_2<br>        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Human.say:()V</span><br>        <span class="hljs-number">24</span>: new           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class com/hk7/memory/DynamicDispatchTest$Woman</span><br>        <span class="hljs-number">27</span>: dup<br>        <span class="hljs-number">28</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Woman.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">31</span>: astore_1<br>        <span class="hljs-number">32</span>: aload_1<br>        <span class="hljs-number">33</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method com/hk7/memory/DynamicDispatchTest$Human.say:()V</span><br>        <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>&emsp;分析以上字节码代码，<code>#0</code>~<code>#15</code>分别实例化了2个对象，<code>#16</code>和<code>#20</code>行aload指令分别把刚刚创建的两个对象的引用压入栈顶，这两个对象是即将要执行say()方法的所有者，称为”<strong>接收者</strong>“。<code>#17</code>和<code>#20</code>指令分别调用方法say，虽然他们的指令和参数一样，但是最终的执行的目标方法不同。<code>invokevirtual</code>指令的运行时解析过程如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 找到操作数栈顶的第一个元素指向的实际类型，记作C。<br><span class="hljs-number">2.</span> 如果在类型C中找到与常量中的描述符和简单名称都相同的方法，则进行权限校验，如果校验通过则返回这个方法的直接引用，查找结束。不通过则java.lang.IllegalAccessError异常。<br><span class="hljs-number">3.</span> 找不到则按照继承关系，从下往上依次对C的父类进行步骤<span class="hljs-number">2</span>的搜索。<br><span class="hljs-number">4.</span> 如果一直没找到，则java.lang.AbstractMethodError异常。<br></code></pre></td></tr></table></figure><p>&emsp;<b style="color:red">invokevirtual指令会在运行期确定接收者的实际类型，进行确定方法的版本，这就是java中方法重写的本质。</b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FieldHasNoPolymorphic</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Father</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">2</span>;<br>            show();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am father, i have $&quot;</span> + money);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> money;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>            money = <span class="hljs-number">4</span>;<br>            show();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;I am son, i have $&quot;</span> + money);<br>            <span class="hljs-comment">//I am son, i have $0</span><br>            <span class="hljs-comment">//I am son, i have $4</span><br>            <span class="hljs-comment">//this gay has $2</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father gay = <span class="hljs-keyword">new</span> Son();<br>        System.out.println(<span class="hljs-string">&quot;this gay has $&quot;</span> + gay.money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<code>new Son()</code>会先隐式调用父类的构造方法，因此Father的money被初始化为2。然后调用show时，调用son的show()，打印出<code>I am son, i have $0</code>，然后父类构造方法结束后会调用自己的构造方法，此时先赋值，再输出<code>I am son, i have $4</code>。<code>gay.money</code>字段并不存在多态性，因此直接访问gay的静态类型的值输出<code>this gay has $2</code>。</p><h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>&emsp;方法的接收者和方法的参数统称为<strong>宗量</strong>，分派时选择一个总量叫做单分派，选择&gt;1个总量叫做多分派。</p><p>比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleMultiDispatch</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQ</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_360</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;father choose QQ&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;father choose _360&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(QQ arg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;son choose QQ&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hardChoice</span><span class="hljs-params">(_360 arg)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;son choose 360&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Father father = <span class="hljs-keyword">new</span> Father();<br>        Father son = <span class="hljs-keyword">new</span> Son();<br>#1        father.hardChoice(new _360());//father choose 360<br>#2        son.hardChoice(new QQ());//son choose QQ<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<strong>目前Java语言的静态分派属于多分派类型；动态分派属于单分派类型；</strong></p><p>&emsp;先看静态分派过程，选择目标有2个：静态类型是Father还是Son，参数是QQ还是360，代码<code>#1</code>和<code>#2</code>在静态编译中产生了两条invokevirtual指令，两条指令的参数分别指向常量池中的Father::hardChoice(360)和Father::hardChoice(QQ)。<br>&emsp;再看动态运行时虚拟机的选择，也就是动态分派过程，此时选择目标只有1个，即实际类型。在执行<code>#1</code>时，发生重载，直接按照静态类型选择Father的参数为360的方法。在执行<code>#2</code>时，发生了重写，此时按照son的实际类型进行选择，因此选择Son的hardChoice方法，而选择哪一个，在静态分派过程已经选择好了，执行Son::hardChoice(QQ)。</p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>&emsp; 由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，虚拟机不可能每次都去搜索，因此在虚拟机的实际实现中，使用了为类型在方法区中建立一个虚方法表的方式。（invokevirtual 指令会搜索vtable，invokeinterface指令会搜索itable）</p><p><img src="https://img-blog.csdnimg.cn/20210112165717130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70"></p><h2 id="3-动态类型语言支持"><a href="#3-动态类型语言支持" class="headerlink" title="3. 动态类型语言支持"></a>3. 动态类型语言支持</h2><p>&emsp;<strong>变量无类型而变量值才有类型</strong>，比如php、python、ruby、javascript等。这种被称作<strong>动态类型语言</strong>。</p><h3 id="3-1-java和动态类型"><a href="#3-1-java和动态类型" class="headerlink" title="3.1 java和动态类型"></a>3.1 java和动态类型</h3><p>&emsp;在jdk7以前，调用方法的指令有4种<code>invokevirtual invokespecial invokestatic invokeinterface</code>，这4中指令的第一个参数都是被调用的方法的符号引用。但是动态类型在编译期是无法确定的，只有运行到该出才知道是什么类型，要处理这种情况很麻烦，为了解决这个问题，jdk7引入了新的指令<code>invokedynamic</code>指令以及<code>java.lang.invoke</code>包。</p><h3 id="3-2-java-lang-invoke"><a href="#3-2-java-lang-invoke" class="headerlink" title="3.2 java.lang.invoke"></a>3.2 java.lang.invoke</h3><p>&emsp;java.lang.invoke包是jdk7引入的包，主要目的是为了在之前单纯依靠符号引用来确定调用的目标方法这种方式之外，提供一种新的动态确定目标方法的机制名称为”<strong>方法句柄</strong>（Method Handle）“。</p><p>&emsp;方法句柄类似于C的函数指针。 <code>void sort(int list[], const int size, int (*compare)(int, int))</code>，java中无法单独把函数作为参数传递，一般都是设计带有compare()方法的接口，比如<code>sort(list, Comparator c)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hk7.jvm;<br><br><span class="hljs-keyword">import</span> java.lang.invoke.MethodHandle;<br><span class="hljs-keyword">import</span> java.lang.invoke.MethodType;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.invoke.MethodHandles.lookup;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodHandleTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;classA：&quot;</span> + x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//如果当前时间是2的倍数，则调用系统System.out.Println方法，否则调用ClassA的Println方法方法。</span><br>        Object obj = System.currentTimeMillis() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? System.out : <span class="hljs-keyword">new</span> ClassA();<br>        getMethodHandle(obj).invokeExact(<span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">//调用对象的方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodHandle <span class="hljs-title">getMethodHandle</span><span class="hljs-params">(Object receiver)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//方法的返回值和参数（参数可以有多个，从第2个参数开始算起）</span><br>        MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class, String.class);<br>        <span class="hljs-comment">//lookup()：在指定类中查找符合给定的方法方法名称、方法类型，并且符合权限的方法句柄</span><br>        <span class="hljs-comment">//findVirtual()：生成方法虚方法的方法句柄。</span><br>        <span class="hljs-comment">//被调用的方法的接受者（类或者接口）、方法名、方法的返回值和参数</span><br>        <span class="hljs-comment">//调用receiver的println方法，参数为String，返回值为空，即调用  public void println(String x)&#123;&#125;方法</span><br>        MethodHandle println = lookup().findVirtual(receiver.getClass(), <span class="hljs-string">&quot;println&quot;</span>, mt);<br>        <span class="hljs-comment">//bindTo：绑定方法句柄的第一个参数到receiver上，但是不调用它</span><br>        <span class="hljs-keyword">return</span> println.bindTo(receiver);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&emsp;但是有了MethodHandler之后则可以实现类似于C/C++函数传递了，<code>void sort(List list, MethodHandle compare)</code>。</p><p>&emsp;从以上代码可以看出，MethodHandle和Reflection类似，但是二者是有区别的。</p><ul><li>MethodHandle和Reflection本质都是模拟方法的调用，但是Reflection是模拟代码层面的调用，MethodHandle则是字节码层面的调用。<code>MethodHandles.Lookup</code>中的3个方法<code>findStatic() findVirtual() findSpecial()</code>对应于字节码指令<code>invokestatic invokevirtual/invokeinterface invokespecial</code>，这些底层细节在反射中并不关心。</li><li>Reflection包含的信息比MethodHandle多得多，它是方法在java端的全面映像。Reflection是重量级、MethodHandle是轻量级。</li><li>MethodHandle是对字节码方法指令的模拟，因此理论上虚拟机对字节码的优化等，MethodHandle也应该实现。但是发射调用不可能执行优化措施。</li><li>Reflection是为java语言服务的，MethodHandle则可以服务于所有基于虚拟机的语言。</li></ul><h3 id="3-3-invokedynamic"><a href="#3-3-invokedynamic" class="headerlink" title="3.3 invokedynamic"></a>3.3 invokedynamic</h3><p>&emsp;invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。它们两者的思路也是可类比的，可以把它们想象成为了达成同一个目的，一个采用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">invokestatic　　 <span class="hljs-regexp">//</span>调用静态方法<br>invokespecial　　<span class="hljs-regexp">//</span>调用私有方法、实例构造器方法、父类方法<br>invokevirtual　　<span class="hljs-regexp">//</span>调用实例方法<br>invokeinterface　<span class="hljs-regexp">//</span>调用接口方法，会在运行时再确定一个实现此接口的对象<br>invokedynamic　　<span class="hljs-regexp">//</span>先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的<span class="hljs-number">4</span>条调用指令，分派逻辑是固化在java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。<br></code></pre></td></tr></table></figure><p>&emsp;每一处含有invokedynamic指令的位置都称做“<strong>动态调用点</strong>”（Dynamic Call Site），这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 1.7新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：引导方法（Bootstrap Method，此方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。<b style="color:red">引导方法是有固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个代表真正要执行的目标方法调用</b>。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法。</p><p>​    详情看文章<a href="https://www.cnblogs.com/sheeva/p/6344388.html%EF%BC%8C%E8%AE%B2%E7%9A%84%E4%B8%8D%E9%94%99%E3%80%82">https://www.cnblogs.com/sheeva/p/6344388.html，讲的不错。</a></p><h3 id="3-4-掌握方法分派实战"><a href="#3-4-掌握方法分派实战" class="headerlink" title="3.4 掌握方法分派实战"></a>3.4 掌握方法分派实战</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hk7.jvm;<br><br><span class="hljs-keyword">import</span> java.lang.invoke.MethodHandle;<br><span class="hljs-keyword">import</span> java.lang.invoke.MethodHandles;<br><span class="hljs-keyword">import</span> java.lang.invoke.MethodType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.invoke.MethodHandles.lookup;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodDispatchTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;i am grandfather&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GrandFather</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;i am father&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thinking</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//            请在这里填入适当的代码(不能修改其他地方的代码)</span><br><span class="hljs-comment">//            实现调用祖父类的thinking() 方法，打印 &quot;i am grandfather&quot;</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//这种在jdk7之后，只能访问到father，因为有访问限制</span><br><span class="hljs-comment">//                MethodType mt = MethodType.methodType(void.class);</span><br><span class="hljs-comment">//                MethodHandle mh = lookup().findSpecial(GrandFather.class, &quot;thinking&quot;, mt, getClass());</span><br><span class="hljs-comment">//                mh.invokeExact(this);</span><br><br>                MethodType mt = MethodType.methodType(<span class="hljs-keyword">void</span>.class);<br>                Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="hljs-string">&quot;IMPL_LOOKUP&quot;</span>);<br>                lookupImpl.setAccessible(<span class="hljs-keyword">true</span>);<br>                MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="hljs-keyword">null</span>)).findSpecial(GrandFather.class, <span class="hljs-string">&quot;thinking&quot;</span>, mt, getClass());<br>                mh.invokeExact(<span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        (<span class="hljs-keyword">new</span> MethodDispatchTest().<span class="hljs-function">new <span class="hljs-title">Son</span><span class="hljs-params">()</span>).<span class="hljs-title">thinking</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-基于栈的字节码解释执行引擎"><a href="#4-基于栈的字节码解释执行引擎" class="headerlink" title="4. 基于栈的字节码解释执行引擎"></a>4. 基于栈的字节码解释执行引擎</h2><p>&emsp;前面讲的是虚拟机如何调用方法、进行方法版本的选择。接下来本节讨论虚拟机是如何执行方法里面的字节码指令的。</p><p>&emsp;java虚拟机的执行引擎在执行java代码的时候有<strong>解释执行</strong>(通过解释器执行)和<strong>编译执行</strong>(通过即时编译器产生本地代码执行)。</p><h3 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a>4.1 解释执行</h3><p>&emsp;不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行。<strong>其中绿色的模块可以选择性实现，中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript）</strong>，而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODE2MTYwNDUxOTk3?x-oss-process=image/format,png" alt="编译过程"></p><p>&emsp;对于具体的语言实现而言，词法、语法分析直至优化器和目标代码生成器，可以独立于执行引擎，形成一个完整的编译器去执行，比如C/C++。也可以把其中部分实现为半独立的编译器，比如Java。也可以把这些步骤和执行引擎集中在封闭的黑匣子之中，如多数JavaScript执行引擎。</p><p>&emsp;Java语言中，Javac编译器完成了程序代码~字节码指令流的不部分。这一部分是在java虚拟机之外进行的，而解释器在虚拟机内部，所以Java语言的编译是半独立的实现。</p><h3 id="4-2-基于栈的解释器执行过程"><a href="#4-2-基于栈的解释器执行过程" class="headerlink" title="4.2 基于栈的解释器执行过程"></a>4.2 基于栈的解释器执行过程</h3><p><strong>代码追踪实例</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> i = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">800</span>;<br>    <span class="hljs-keyword">int</span> k = i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>javap -v xxx.class之后得到字节码指令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br> <span class="hljs-number">0</span>: bipush        <span class="hljs-number">15</span><br> <span class="hljs-number">2</span>: istore_1<br> <span class="hljs-number">3</span>: sipush        <span class="hljs-number">800</span><br> <span class="hljs-number">6</span>: istore_2<br> <span class="hljs-number">7</span>: iload_1<br> <span class="hljs-number">8</span>: iload_2<br> <span class="hljs-number">9</span>: iadd<br><span class="hljs-number">10</span>: istore_3<br><span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>&emsp;以上代码的具体执行如下图，<strong>指令类型采用所能包含的值的最小整数类型指令</strong>：</p><ul><li><ol><li>当执行main函数时，创建好栈帧。pc寄存器的值为0，栈帧中初始化了局部变量表和操作数栈，值为空</li></ol></li><li><ol start="2"><li>执行地址为0的指令，bipush，pc=2，15入栈</li></ol></li><li><ol start="3"><li>执行地址为2的指令，istore_1，pc=3，15出栈，局部变量表slot1=15（实例方法，slot0存储的是this变量）</li></ol></li><li><ol start="4"><li>执行地址为3的指令，sipush（由于800超过了byte的范围，所以会使用sipush，short类型），pc=5，8入栈</li></ol></li><li><ol start="5"><li>执行地址为5的指令，istore_2，pc=6，8出栈，局部变量表slot2=8</li></ol></li><li><ol start="6"><li>执行地址为6的指令，iload_1，pc=7，从slot1中加载15，15入栈</li></ol></li><li><ol start="7"><li>执行地址为7的指令，iload_2，pc=8，从slot2中加载8，8入栈</li></ol></li><li><ol start="8"><li>执行地址为8的指令，iadd，pc=9，8和15出栈并执行相加操作，23入栈</li></ol></li><li><ol start="9"><li>执行地址为9的指令，istore_3，pc=10，23出栈，局部变量表slot3=23</li></ol></li><li><ol start="10"><li>执行地址为10的指令，return。函数结束，栈帧销毁。<br><img src="https://img-blog.csdnimg.cn/20201013115416401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="代码追踪"></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之内存分配与回收策略</title>
    <link href="/2020/12/28/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <url>/2020/12/28/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>&emsp;上一篇文章了解了<a href="https://happykite777.github.io/2020/12/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">内存分代理论</a>，这次来具体了解下内存分配和回收策略。</p><h3 id="1-对象优先在Eden区分配"><a href="#1-对象优先在Eden区分配" class="headerlink" title="1 对象优先在Eden区分配"></a>1 对象优先在Eden区分配</h3><p>&emsp;大多数对象都在Eden区分配，当Eden区没有足够的空间时，会发起一次Minor GC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* -Xmn10M:设置年轻代大小为10M</span><br><span class="hljs-comment">* -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEden</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">byte</span>[] a1, a2, a3, a4;<br>  a1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1M];<br>  a2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1M];<br>  a3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1M];<br>  a4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span> * _1M];<span class="hljs-comment">//出现一次Minor GC</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2 大对象直接进入老年代"></a>2 大对象直接进入老年代</h3><h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3 长期存活的对象进入老年代"></a>3 长期存活的对象进入老年代</h3><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4 动态对象年龄判定"></a>4 动态对象年龄判定</h3><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5 空间分配担保"></a>5 空间分配担保</h3>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="/2020/12/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2020/12/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-垃圾回收概述"><a href="#1-垃圾回收概述" class="headerlink" title="1. 垃圾回收概述"></a>1. 垃圾回收概述</h2><h3 id="1-1-哪些内存需要回收"><a href="#1-1-哪些内存需要回收" class="headerlink" title="1.1 哪些内存需要回收"></a>1.1 哪些内存需要回收</h3><p>&emsp;为了提高内存利用率，虚拟机可以对无用的内存进行回收清理。虚拟机的内存分配和内存回收技术已经很成熟，但是我们仍然需要了解垃圾回收相关原理，以便于在发生内存溢出、内存泄露等问题时，可以排定位查。</p><p>&emsp;前面说过，运行时内存区域分为程序计数器、虚拟机栈、本地方法栈、堆、方法区和运行常量池。其中pc计数器、虚拟机栈、本地方法栈区域随线程而生，随线程而死，因此这3个区域的内存分配和回收都具有确定性，不需要过多考虑垃圾回收问题。</p><p>&emsp;而java堆和方法区的内存分配是动态的，一个接口的多个实现类所需内存不一样，不同的分支语句所需要内存也不一样，这部分区域内存只有在运行期间才会确定，创建了多少个对象，需要分配多大内存等，这部分内存是动态分配和回收的，因此<strong>垃圾收集器关注的就是java堆和方法区的内存管理</strong>。</p><h3 id="1-2-如何判断对象需要回收"><a href="#1-2-如何判断对象需要回收" class="headerlink" title="1.2 如何判断对象需要回收"></a>1.2 如何判断对象需要回收</h3><p>&emsp;垃圾收集器处理的大多是死掉的对象，程序不再使用的对象，name如何判断对象已撕，需要回收呢？有两种方法：引用计数和可达性分析。</p><blockquote><p>引用计数法</p></blockquote><p>&emsp;为每一个对象配置一个计数器，当对象被其他地方引用时，计数器+1，引用失效时，计数器-1。当任何时刻计数器值为0时，说明对象不可能再被引用，该对象可以被回收。</p><p>&emsp;这种方式原理简单、判定效率高，大多数情况下，是个很好的方式。但是主流的JVM没有选择它，因为这种算法需要考虑的额外情况很多，比如循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCounts</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Object instance = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1M = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1M];<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        testGc();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGc</span><span class="hljs-params">()</span> </span>&#123;<br>        ReferenceCounts a = <span class="hljs-keyword">new</span> ReferenceCounts();<br>        ReferenceCounts b = <span class="hljs-keyword">new</span> ReferenceCounts();<br>        a.instance = b;<br>        b.instance = a;<br><br>        a = <span class="hljs-keyword">null</span>;<br>        b = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//此时发生回收</span><br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;执行<code>javac ReferenceCounts.java</code> <code>java -verbose:gc ReferenceCounts</code>可以看到内存从6767K-&gt;472K，并没有因为相互引用而不回收他们，说明jvm使用的并不是引用计数法。-XX:+PrintGCDetails可以看到更细节的内存变化。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-name">GC</span> (<span class="hljs-name">System.gc</span>()) [<span class="hljs-name">PSYoungGen:</span> <span class="hljs-number">6767</span>K-&gt;464K(<span class="hljs-name">38400K</span>)] <span class="hljs-number">6767</span>K-&gt;472K(<span class="hljs-name">125952K</span>), <span class="hljs-number">0.0019002</span> secs] [<span class="hljs-name">Times:</span> user=0.00 sys=0.00, real=0.00 secs] <br>[<span class="hljs-name">Full</span> GC (<span class="hljs-name">System.gc</span>()) [<span class="hljs-name">PSYoungGen:</span> <span class="hljs-number">464</span>K-&gt;0K(<span class="hljs-name">38400K</span>)] [<span class="hljs-name">ParOldGen:</span> <span class="hljs-number">8</span>K-&gt;396K(<span class="hljs-name">87552K</span>)] <span class="hljs-number">472</span>K-&gt;396K(<span class="hljs-name">125952K</span>), <br></code></pre></td></tr></table></figure><blockquote><p>可达性分析</p></blockquote><p>&emsp;可达性分析是指通过一系列叫做“GC Roots”的根对象，向下搜索对象，形成的链路叫做“引用链（Reference Chain）”，如果某个对象和GC Roots之间没有引用链，则说明对象已死，可被回收。比如下图中的Obj5、6、7。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg4.mukewang.com%2F5c513a070001490f06770312.jpg&refer=http%3A%2F%2Fimg4.mukewang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611309966&t=ab5355db30dc2078e9aa9c7f92397071" alt="可达性分析"></p><p>&emsp;可作为“GC Roots”的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象，各线程中被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI引用的对象；</li><li>jvm内部的引用，比如基本数据类型对应的class对象、常驻异常对象（NullPointException等）、系统类加载器</li><li>所有被同步锁(synchronized关键字)持有的对象；</li><li>反映虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>&emsp;除了以上固定的GC Roots，虚拟机还可以加入其它的对象作为GCRoots，各个虚拟机可自行实现。比如后面的分代收集和局部（Partial GC）回收等。</p><blockquote><p>引用</p></blockquote><p>JDK对引用的概念进行了扩充，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。</p><ul><li>强引用：Object A = new Object()；强引用关系在，垃圾收集器永远不回收A对象。</li><li>软引用：还有用但非必须的对象。软引用关系存在，在系统发生内存溢出前，会把这些对象列入回收范围内进行二次回收。<code>java.lang.ref.SoftReference</code>  具体分析参考<a href="https://www.jianshu.com/p/e46158238a77">https://www.jianshu.com/p/e46158238a77</a></li><li>弱引用：非必须对象。会存在到下次GC之前，即使没有发生内存溢出，GC时，也会回收掉这部分对象。</li><li>虚引用：“幽灵引用”或者“幻影引用”。为对象设置虚引用，唯一目的是发生GC时，对象会受到一个系统通知。<code>java.lang.ref.PhantomReference</code></li></ul><blockquote><p>对象的自救</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201223192608994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="对象的二次标记"></p><p>&emsp;如上图所示，对象第一次被判定会已死，并不会直接进入被GC，而是会做一次筛选，是否需要执行final()方法，如果对象已经执行过了，或者没有实现finalize()方法，则会进入“被回收”集合，下次gc时候被清理。如果实现了finalize()方法，则会进行调用，在finalize（）中如果重新建立连接，则会被移除“被回收”集合。否则会被GC回收掉。如下这个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 對象的自我拯救</span><br><span class="hljs-comment"> * @author Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FinalizeEscapeGC</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FinalizeEscapeGC SAVE_HOOK=<span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">//判斷是否還活著</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isAlive</span>(<span class="hljs-params"></span>)</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;我還活著&quot;</span>);<br>&#125;<br><br>@Override<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span>(<span class="hljs-params"></span>) throws Throwable</span> &#123;<br>super.finalize();<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;finalize方法执行了&quot;</span>);<br>FinalizeEscapeGC.SAVE_HOOK=<span class="hljs-keyword">this</span>;<span class="hljs-comment">//与对象简历联系，自救</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>SAVE_HOOK=<span class="hljs-keyword">new</span> FinalizeEscapeGC();<br><br><span class="hljs-comment">//第一次自救</span><br>SAVE_HOOK=<span class="hljs-literal">null</span>;<br>System.gc();<br><span class="hljs-comment">//因为finalize的优先级低，先等一下</span><br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">if</span>(SAVE_HOOK!=<span class="hljs-literal">null</span>)&#123;<br>SAVE_HOOK.isAlive();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;第一次自救失败&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//第二次自救  </span><br><span class="hljs-comment">//因为每个对象的finalize()方法只会被系统自动调用一次，所以第一次调用后，</span><br><span class="hljs-comment">//第二次自救时不会再调用finalize(),自然也就不会与其他的对象产生联系，从而自救失败</span><br>SAVE_HOOK=<span class="hljs-literal">null</span>;<br>System.gc();<br><span class="hljs-comment">//因为finalize的优先级低，先等一下</span><br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">if</span>(SAVE_HOOK!=<span class="hljs-literal">null</span>)&#123;<br>SAVE_HOOK.isAlive();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;第二次自救失败&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//finalize()虽然能够实现对象自救，但是不要轻易使用，因为他的运行代价太大，不确定性高，无法确定各个对象的调用顺序。</span><br><span class="hljs-comment">//而且finalize()能做的事，try-finally都能做，而且做得更好</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法区的回收</p></blockquote><p>&emsp;方法区存放的主要是class文件内容等信息，这部分区域需要回收的内容主要是 <strong>废弃的常量</strong> 和 <strong>不再使用的类型</strong>。比如常量池中“java”这个字符串，如果没有地方引用它，那么他就需要回收。类型也是如此。</p><p>&emsp;判断一个类型不再使用需要满足以下三个条件：</p><ul><li>该类的所有实例都已经被回收，java堆中不存在任何该类即派生类的实例。</li><li>加载该类的类加载器也已经被回收。</li><li>该类的java.lang.Class对象没有在任何地方被引用，任何地方无法通过反射访问该类的方法。</li></ul><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><h3 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 分代收集理论</h3><p>&emsp;根据对象的存货时长，把java堆划分为新生代（Young Generation）和老年代（Old Generation）区域，新生代中每次gc都有大量对象死去，少量存活的对象会移动到老年代区域中去。对不同的领域进行回收，主要分为：<strong>部分收集</strong>和<strong>整堆收集</strong>。</p><ul><li>部分收集（Partial GC）：对java堆中的部分进行GC。<ul><li>新生代收集（Minor GC/Young GC）：只收集新生代的垃圾。</li><li>老年代收集（Major GC/Old GC）：只收集老年代的垃圾。目前只有CMS会单独收集老年代。</li><li>混合收集（Mixed GC）：收集整个新生代和部分老年代的垃圾。目前只有G1收集器具有该行为。</li></ul></li><li>整堆收集（Full GC）：对整个java堆和方法区进行GC。</li></ul><h3 id="2-2-标记-清除算法"><a href="#2-2-标记-清除算法" class="headerlink" title="2.2 标记-清除算法"></a>2.2 标记-清除算法</h3><p>&emsp;标记所有可回收对象，然后统一回收。<strong>清除并不是真的置空,而是把需要清除的对象地址保存在空闲的地址列表里</strong>。如下图所示：</p><p><img src="https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514003846052-1501866867.png" alt="标记-清除"></p><p>&emsp;缺点：</p><ul><li>效率不算高</li><li>在进行GC的时候,需要停止整个应用程序,导致用户体验差</li><li>这种方式清理出来的空闲内存是不连续的,产生内存碎片。需要维护一个空闲列表</li></ul><h3 id="2-3-标记-复制算法"><a href="#2-3-标记-复制算法" class="headerlink" title="2.3 标记-复制算法"></a>2.3 标记-复制算法</h3><p>&emsp;将内存按容量等分为两块，每次只使用其中的一块。当这一块内存使用完的时候，就将所有存活的对象逐一复制到另一块内存，然后把这一块内存的空间一次性清理掉（只要移动堆指针，按顺序分配内存即可）。</p><p><img src="https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514004217106-218817469.png" alt="标记-复制"></p><p>&emsp;实现简单、运行高效、解决了内存碎片问题，但是<strong>内存缩小了一半</strong>。由于<strong>新生代</strong>中98%的对象是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存划分为一块较大的名为Eden的空间，两块较小的名为Survivor的空间。</p><p><strong>&emsp;每次将一块Survivor的空间保留，将另一块Survivor与Eden一起拿来使用。进行垃圾回收时，将所有存活的对象复制被到保留的那块Survivor的空间上，然后将Eden和之前使用的Survivor的空间清理掉。两块Survivor交替着与Eden一起使用。</strong>HotSpot虚拟机默认Eden和Survivor的大小比例为8:1，也就是说，浪费的空间由原来的50%降到10%。</p><p>&emsp;当surivivor的空间不足以存储时，这些对象会进入到老年代（Tenured）。</p><p><img src="https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514004232276-984785021.png" alt="gc前"></p><p><img src="https://img2020.cnblogs.com/blog/1689384/202005/1689384-20200514004237536-1710367861.png" alt="gc后"></p><h3 id="2-4-标记-整理算法"><a href="#2-4-标记-整理算法" class="headerlink" title="2.4 标记-整理算法"></a>2.4 标记-整理算法</h3><p>&emsp;标记清理后会产生大量碎片，标记-整理算法其实是对他的一个优化<strong>。不直接对可回收对象进行清理，而是让所有可用的对象都向一端移动。然后直接清理掉边界意外的内存。</strong></p><p><img src="https://img-blog.csdn.net/20161101222342412" alt="标记 - 整理"></p><p>&emsp;该种方式会花费额外的时间（整理时，整个程序都会暂停）来整理内存，但是相比标记-清除算法的内存碎片，这种方式会划算的多。CMS采用的是标记-清除和标记-整理的混合体，即刚开始使用标记-清除算法，当内存碎片达到一定阈值时，采用标记-整理算法进行碎片清理。</p><h3 id="2-4-GC触发条件"><a href="#2-4-GC触发条件" class="headerlink" title="2.4 GC触发条件"></a>2.4 GC触发条件</h3><p>&emsp;<strong>对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。</strong></p><p>&emsp;Full GC的触发条件有以下五种：</p><ul><li><strong>调用System.gc()</strong><ul><li>不建议使用，<code>-XX:+ DisableExplicitGC</code>来禁止RMI调用System.gc()。</li></ul></li><li><strong>老年代空间不足时会触发FullGC</strong></li><li><strong>空间分配担保失败</strong><ul><li>使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了<code>HandlePromotionFailure</code>担保失败，则会触发Full GC。</li></ul></li><li><strong>JDK 1.7及以前的永久代空间不足</strong><ul><li>HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。在1.8及其之后，元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。</li></ul></li><li><strong>Concurrent Mode Failure</strong><ul><li>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报<code>Concurrent Mode Failure</code>错误，并触发Full GC。</li></ul></li></ul><h2 id="3-HotSpot算法实现细节"><a href="#3-HotSpot算法实现细节" class="headerlink" title="3. HotSpot算法实现细节"></a>3. HotSpot算法实现细节</h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a>3.1 枚举根节点</h3><p>&emsp;虚拟机大多采用可达性分析算法判断对象是否需要回收，可作为GC Roots根节点的一般都是全局性的引用（常量、静态属性等）和执行上下文（栈帧中的局部变量表）。如果每次gc时，对内存进行遍历，那可就太耗时了，现在有可能一个方法就上百兆。因此遍历的方式不可取。虚拟机选择在类加载时就把这些引用类型存储起来，后面OopMap会详细解释。</p><h3 id="3-2-GC停顿（Stop-the-world）"><a href="#3-2-GC停顿（Stop-the-world）" class="headerlink" title="3.2 GC停顿（Stop  the world）"></a>3.2 GC停顿（Stop  the world）</h3><p>&emsp;为了保证可达性分析结果的准确性，必须保证分析过程中对象引用关系是一致的，因此此时必须停顿所有的java执行线程，这种行为被称为“stop the world”。枚举根节点的时候，必须stop the  world。</p><h3 id="3-3-准确式GC与OopMap"><a href="#3-3-准确式GC与OopMap" class="headerlink" title="3.3 准确式GC与OopMap"></a>3.3 准确式GC与OopMap</h3><p>&emsp;GC所关心的是<strong>某块数据是不是指针</strong>，通过能否直接判断数据是否属于指针，将GC分为保守式GC、半保守式GC和准确式GC。</p><blockquote><p>保守式GC：</p></blockquote><p>&emsp;    如果jvm在类加载时没有记录数据的类型，它就无法区分某个位置的数据到底是引用类型还是其他的类型，这时候进行GC时，jvm会从一些已知位置（比如虚拟机栈）开始扫描内存，检查它“是否属于一个指向GC堆中的指针”。会涉及上下边界检查（GC堆的上下界是已知的）、对齐检查（通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针）之类的。递归扫描。这种方式叫做保守式GC。</p><p>&emsp;简单概括就是，就是<strong>不能识别指针和非指针的GC，GC时通过GC Roots，从上到下扫描，需要回收的直接进行回收。</strong>保守式GC一般使用标记-清除算法。</p><ul><li>优点：实现简单。</li><li>缺点：部分对象本来应该已经死了，但有疑似指针指向它们，使它们逃过GC的收集。而且，由于有疑似指针，所以对象的值不敢随意更改，更改了疑似指针也需要修正。因此无法使用复制算法。</li><li>改进：为了在保守式GC时仍然可以修改对象，可以在中间加一层<strong>句柄池</strong>，修改对象后，更正句柄表即可，具体可见<a href="https://happykite777.github.io/2020/10/10/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">HotSpot对象访问定位</a>。但是这样对象的访问速度就降低了。Sun JDK的Classic VM用过这种全handle的设计，但效果实在不算好。</li></ul><p>&emsp;由于jvm支持丰富的反射功能，本身就需要了解对象本身结构，因此很少会有jvm采用保守式GC。</p><blockquote><p>半保守式GC</p></blockquote><p>&emsp;在对象上记录类型的信息，在扫描的时候进行判断进行回收。类型信息可能是类加载器或者对象模型的模块里计算得到的。由于保守式GC在堆内部的数据是准确的，所以即便是直接指针引用，它也可以实现部分对象的移动。将保守扫描到的对象设为不可移动，再从这些对象出发，接下来扫描到的对象都是可移动的。半保守式GC可以使用标记-清除、复制算法。</p><blockquote><p>准确式GC</p></blockquote><p>&emsp;为了让JVM准确判断出所有位置上的数据是不是指向GC堆里的引用（包括活动记录（栈+寄存器）里的数据），有三种方式：</p><ul><li>让数据自身带上标记（tag）。半保守式GC通常这样实现，jvm基本不使用这种方式。</li><li>让编译器为每个方法生成特别的扫描代码。jvm不使用。</li><li>从外部记录下类型信息，存成映射表。目前主流的jvm均使用该种方式，HotSpot把这种数据结构称为OopMap、JRockit里叫做livemap，J9和Apache Harmony的DRLVM把它叫做GC map。</li></ul><p>将类的信息存放到OopMap中，然后进行准确性的扫描。这种GC称为准确式GC。</p><blockquote><p>OopMap</p></blockquote><p>&emsp;oopMap可以简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了，oopMap就是一个附加信息，告诉你栈上哪个位置本来是什么东西。OopMap和编译器相关，类加载完成时，HotSpot会把对象内什么偏移量上是什么类型数据记录下来，在即时编译过程中，会在特定位置记录下栈和寄存器里，哪些位置是引用。有了OopMap，垃圾收集器在扫描时，不需要遍历GC Root，可以直接获取信息。</p><h3 id="3-4-安全点（Safepoint）"><a href="#3-4-安全点（Safepoint）" class="headerlink" title="3.4 安全点（Safepoint）"></a>3.4 安全点（Safepoint）</h3><p>&emsp;随着程序的执行，引用关系可能发生变化，如果为每一条指令都生成OopMap，那样会耗费大量额外空间，GC的成本会变高。因此HotSpot不为每条指令都生成OopMap，只在“特定的位置”记录这些信息，这些位置便被称为<strong>安全点（Safepoint）</strong>。</p><p>&emsp;程序并非在任何地方都可以停下来执行GC，只有在达到安全点时才能暂停。安全点的选择以“是否具有让程序<strong>长时间执行</strong>的特征”为标准选定，如果安全点太少GC等待时间过长，如果太多又会导致额外的符合。一般安全点的位置选在：</p><ul><li>循环的末尾</li><li>方法临返回前 / 调用方法的call指令后</li><li>可能抛异常的位置</li></ul><p>&emsp;每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</p><p>&emsp;当发生GC时，需要让所有线程（不包括执行JNI调用的线程）“跑”到最近的安全点上。有两种实现方式：</p><ul><li>抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li><li>主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，所有创建对象和其他需要在java堆上分配内存的地方也有轮询标志，这样当分配内存时先GC，尽量保证有内存可分配。</li></ul><h3 id="3-5-安全区域（Safe-Region）"><a href="#3-5-安全区域（Safe-Region）" class="headerlink" title="3.5 安全区域（Safe Region）"></a>3.5 安全区域（Safe Region）</h3><p>&emsp;安全点保证运行中的线程在GC时跑到安全点，但是当个线程处于阻塞或者休眠状态时，怎么办呢？这时候需要安全区域就发挥作用了。</p><p>&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。`我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p>&emsp;在线程执行到安全区域中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h3 id="3-6-记忆集（RememberedSet）与卡表（Card-Table）"><a href="#3-6-记忆集（RememberedSet）与卡表（Card-Table）" class="headerlink" title="3.6 记忆集（RememberedSet）与卡表（Card Table）"></a>3.6 记忆集（RememberedSet）与卡表（Card Table）</h3><p>&emsp;在新生代和老年代之间，经常会发生跨代引用，比如老年代对象引用了新生代中的某个对象，这时候如果我们需要对新生代进行GC，就比较麻烦，因为被引用的新生代不应该被回收掉。为了解决这个问题，虚拟机是在引用关系发生时，在新生代边上专门开辟一块空间来记录引用关系，这块空间被称为RememberedSet。因此“新生代的 GC Roots ” + “ RememberedSet 存储的内容”，才是新生代收集时真正的 GC Roots。据此再进行可达性分析。</p><p>&emsp;记忆集的实现方式有一下三种：</p><ul><li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象包含跨代指针。</li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象包含跨代指针。</li></ul><p>&emsp;其中第三种方式，卡精度使用的是“卡表”去实现记忆集。这是最常用的实现方式。卡表定义了记忆集的记录精度、与堆内存的映射关系等。HotSpot中的卡表具体实现如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CARD_TABLE [this<span class="hljs-built_in"> address </span>&gt;&gt; 9] = 0;<br></code></pre></td></tr></table></figure><p>&emsp;字节数组CARD_TABLE每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page），一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200315195004804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5NjUyOQ==,size_16,color_FFFFFF,t_70" alt="卡表与卡页对应关系"></p><p>&emsp;一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0。</p><p>GC时，只要<strong>筛选卡表中变脏的元素</strong>加入GCRoots。</p><h3 id="3-7-写屏障"><a href="#3-7-写屏障" class="headerlink" title="3.7 写屏障"></a>3.7 写屏障</h3><p>&emsp;当其他的分代区域引用本区域的对象， 本区域对应的卡表元素就应该变脏（即变为1）。理论上，当本区域对象被引用的时刻，就应该其卡表就应该变脏，但是卡表如何变脏，也就是卡表具体是如何维护的呢？</p><p>&emsp;在HotSpot里面，通过“写屏障”技术来维护卡表的状态。写屏障可以看做在虚拟机层面对“引用类型字段赋值”动作的AOP切面，在赋值时产生一个环形通知。赋值前后都属于写屏障，赋值前称为“<strong>写前屏障</strong>（Pre-Write Barrier）”，赋值后称为“<strong>写后屏障</strong>（Post-Write Barrier）”。在G1出现之前，其他的收集器均使用写后屏障。简化逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">oop_field_store</span><span class="hljs-params">(oop* field, oop new_value)</span></span>&#123;<br><span class="hljs-comment">//引用字段赋值操作</span><br>  *field = <span class="hljs-keyword">new</span> _value;<br><span class="hljs-comment">//写后屏障，在这里完成卡表状态更新</span><br>post_writer_barrier(field, new_value);<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;写屏障问题：</p><p>&emsp;1. 应用写屏障后，虚拟机会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代的引用，每次只要对引用进行更新，就会产生额外的开销。但是这个开销和Minor GC时扫描整个老年代相比还是低很多。</p><p>&emsp;2. <a href="https://blog.csdn.net/weixin_43696529/article/details/104884373">伪共享</a>问题：为了解决该问题，虚拟机会先检查卡表状态，当其未被标记时，才标记其变脏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (CARD_TABLE [<span class="hljs-keyword">this</span> address &gt;&gt; <span class="hljs-number">9</span>] != <span class="hljs-number">0</span>)    <br>CARD_TABLE [<span class="hljs-keyword">this</span> address &gt;&gt; <span class="hljs-number">9</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>&emsp;在JDK 7之后，HotSpot虚拟机增加了一个新的参数<code>-XX：+UseCondCardMark</code>，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</p><h3 id="3-8-并发的可达性分析"><a href="#3-8-并发的可达性分析" class="headerlink" title="3.8 并发的可达性分析"></a>3.8 并发的可达性分析</h3><p>&emsp;当用户线程和垃圾收集工作同时进行时，有可能发生错误标记的情况，比如本来被标记为已死的对象被错误标记为存活，这种可以忍受，但是如果把存货对象标记为已死，则整个程序可能发生崩溃，这可是严重事故不可容忍的。</p><p>&emsp;为了解决这个问题，我们先分析，“对象消失”可能产生的原因（具体参考网上的<strong>三色标记</strong>理论）：</p><ul><li>赋值器在存活对象中又引用了一条或多条其他其他新引用。</li><li>赋值器删除了全部本应该引用其他对象的直接或间接引用。</li></ul><p>&emsp;为了解决“对象消失”问题，破坏以上2个条件之一即可。由此产生了两种解决方案：<strong>增量更新</strong>和<strong>原始快照</strong>。</p><ul><li>增量更新：当插入新引用时，记录该新引用关系，等并发扫描结束后，再从引用关系中的GC Roots重新扫描一次。</li><li>原始快照：同上，记录新的引用关系，结束后再扫描一次。</li></ul><p>&emsp;CMS用到使用增量更新，G1和Shenandoah使用了原始快照。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h2><p>&emsp;下图所示，7种作用域不同分代的收集器，如果有连线，说明他们可以搭配使用。每种收集器适合不同的场景，目前并没有哪一款是最好的。</p><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3382388939,3371678992&fm=15&gp=0.jpg" alt="经典垃圾收集器关系"></p><blockquote><p>经典垃圾收集器</p></blockquote><h3 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a>4.1 Serial收集器</h3><p>&emsp;Serial收集器作用域新生代，采用复制算法进行gc，Serial Old作用域老年代，采用标记-整理算法。他们都是<strong>单线程</strong>的，gc时会暂停当前所有的用户线程，称之为“stop the world”。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=712008591,2317152046&fm=26&gp=0.jpg" alt="Serial/Serial Old收集器"></p><p>&emsp;Serial收集器简单高效，对于资源受限（单核）的环境（比如客户端模式下的虚拟机），是一个良好的选择。</p><h3 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h3><p>&emsp;ParNew也作用域新生代，它<strong>是Serial的多线程版本</strong>，他的可用参数（-XX: SurviviorRatio等）、收集算法、stop the world、对象分配规则、回收策略等都和Serial一样。正由于它支持多线程，因此它适合于服务端模式下的虚拟机。此外，它是<strong>唯一能和CMS配合的收集器</strong>。</p><p>&emsp;从本节开始的图中可以看到，收集器组合可以为：<del>Serial + CMS</del>、ParNew + CMS、<del>ParNew + Serial Old</del>。G1出世后，作为面向全堆的垃圾收集器，不需要和其他收集器配合使用。官方也希望G1取代其他收集器，JDK9后取消了Serial + CMS和ParNew + Serial Old的组合。因此ParNew成为唯一和CMS搭配使用的收集器。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F590264%2F201904%2F590264-20190403010633750-1366251816.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611369561&t=4b0e9da2b4ff481857a34a152c865a2c" alt="ParNew"></p><h3 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h3><p>&emsp;是一款新生代收集器，也支持多线程gc。类似于ParNew，但他的特别之处在于，他关注的是GC的吞吐量，其他的收集器关注点是如何减少stop the world的时间。</p><p>&emsp;<code>吞吐量 = 用户运行代码时间 / (用户运行代码时间 + gc时间)</code>。</p><p>&emsp;<code>-XX: MaxGCPauseMillis</code>gc最大耗时，尽量控制在该范围内。</p><p>&emsp;<code>-XX: GCTimeRatio</code>垃圾收集占总时间的比例，0~100.。假设为19，则gc最大耗时占比为<code>1 / (1 + 19) = 5%</code>。默认值为99，即<code>1 / (1 + 99) = 1%</code>。默认gc最大耗时占比为1%。</p><p>&emsp;<code>-XX: UseAdaptiveSizePolicy</code>，该参数被激活，虚拟机会根据系统运行情况，动态调整各个参数，无需手动设置。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=152607963,513947332&fm=26&gp=0.jpg" alt="Parallel Scavenge"></p><h3 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a>4.4 Serial Old收集器</h3><p>&emsp;Serial Old也是单线程收集器，作用域老年代。它主要供客户端模式下的HotSpot虚拟机使用。如果是服务器模式下，jdk5及其之前可与Parallel Scavenge收集器搭配，或者作为CMS收集器发生失败时的后备方案。</p><p>&emsp;Parallel Scaveng中自带有PS MarkSweep老年代收集器，它的实现与Serial Old几乎一样，因此大多数说法是Parallel Scaveng和Serial Old搭配使用，实质上不是直接掉Serial Old。</p><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=712008591,2317152046&fm=26&gp=0.jpg" alt="Serial/Serial Old收集器"></p><h3 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a>4.5 Parallel Old收集器</h3><p>&emsp; Parallel Old是老年代收集器，支持多线程gc，它的出现是为了搭配Parallel Scavenge。在它出现之前，Parallel Scavenge无法和CMS配合使用，只能搭配Serial Old，但是Serial Old是单线程，无法提高Parallel Scavenge的吞吐量控制。因此Parallel Old应运而生。<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3202644236,310743517&fm=26&gp=0.jpg" alt="Parallel Old"></p><h3 id="4-6-CMS收集器（Concurrent-Mark-Sweep）"><a href="#4-6-CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="4.6 CMS收集器（Concurrent Mark Sweep）"></a>4.6 CMS收集器（Concurrent Mark Sweep）</h3><p>&emsp;<strong>CMS是第一款支持并发的收集器，它可以让gc线程和用户线程同时工作，以上提到的所欲收集器则必须是stop the world。</strong><br>&emsp;CMS作用与老年代，基于标记-清除算法实现。它的gc过程分为四步：</p><ul><li>初始标记（CMS initial mark）：标记GC Roots能直接关联上的对象，速度很快，需要<strong>stop the world</strong>。</li><li>并发标记（CMS concurrent mark）：从上一步标记的对象开始遍历整个图，耗时，但不需要停顿用户线程。</li><li>重新标记（CMS remark）：更新并发标记期间因用户程序运作产生变动的标记，<strong>stop the world</strong>，且停顿时间比初始标记长，但短于并发标记时长。</li><li>并发清除（CMS concurrent sweep）：清理标记死亡的对象，无需暂停用户线程。</li></ul><p><strong>CMS优点</strong>：</p><ul><li>并发收集、低停顿。Oracle也称之为<strong>“并发低停顿收集器”</strong></li></ul><p><strong>CMS缺点</strong>：</p><ul><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾<ul><li>浮动垃圾：标记为存活对象但是由于用户线程同时在进行，清除之前变为了垃圾对象。这种只能在下一次GC回收。</li><li>浮点垃圾可能会使得虚拟机出现Concurrent Mode Failure失败，进而导致Full GC。</li></ul></li><li>收集结束时会有大量空间碎片产生<ul><li>由于它基于标记-清除算法，所以会产生大量空间碎片，由于大量的空间碎片可能会出现老年代无法找到大片连续的空间来分配对象，从而提前触发FullGC。</li><li><code>-XX: UseCMS-CompactAtFullCollection</code>参数开启，会让FullGC结束后进行碎片整理。JDK9移除。</li></ul></li></ul><h3 id="4-7-GarbageFirst收集器（G1）"><a href="#4-7-GarbageFirst收集器（G1）" class="headerlink" title="4.7 GarbageFirst收集器（G1）"></a>4.7 GarbageFirst收集器（G1）</h3><p>&emsp;<strong>G1收集器的是垃圾收集器的里程碑。</strong>它将新生代，老年代的物理空间划分取消了。取而代之的是Regin区域。</p><p>以往的垃圾回收算法，如CMS，使用的堆内存结构如下：</p><ul><li>新生代：eden space + 2个survivor</li><li>老年代：old space</li><li>持久代：1.8之前的perm space</li><li>元空间：1.8之后的metaspace</li></ul><p><img src="https://img2018.cnblogs.com/blog/825468/201901/825468-20190106234624900-376662990.png"></p><h4 id="Region"><a href="#Region" class="headerlink" title="Region"></a><b style="color:red">Region</b></h4><p>&emsp;在G1中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，结构如下：</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4069522971,3313952831&fm=26&gp=0.jpg"></p><p>&emsp;每个Region被标记了E、S、O、H等，说明region可以根据存储不同的数据。E代表该region存储的是Eden区数据，S是survivor、O是old。H是Humongous，表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H。</p><p>&emsp;堆内存中一个Region的大小可以通过<code>-XX:G1HeapRegionSize</code>参数指定，大小区间只能是1M、2M、4M、8M、16M和32M等2的幂次方。默认把堆内存按照2048份均分，最后得到一个合理的大小。</p><h4 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a><b style="color:red">GC模式</b></h4><p>&emsp;G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。</p><ul><li><p>young gc</p><ul><li>一般的对象发生在年轻代，当eden region中内存不够时，会触发一次young gc。活跃对象会被拷贝到survivor region或者晋升到old region中。</li></ul></li><li><p>mixed gc</p><ul><li><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收<strong>一部分</strong>的old region。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent=80</code>表示老年代的使用率达到80%会触发一次mixed gc</p></li><li><p>mixed gc的执行过程有点类似cms，主要分为以下几个步骤：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1.</span> initial mark: 初始标记过程，整个过程<span class="hljs-keyword">stop</span> the world，标记了从GC Root可达的对象<br><span class="hljs-number">2.</span> concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息<br><span class="hljs-number">3.</span> <span class="hljs-comment">remark: 最终标记过程，整个过程stop the world，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象</span><br><span class="hljs-number">4.</span> clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中<br></code></pre></td></tr></table></figure></li></ul></li><li><p>full gc</p><ul><li>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。</li></ul></li></ul><p><a href="https://www.jianshu.com/p/0f1f5adffdc1">参考</a></p><blockquote><p>4.2 低延迟垃圾收集器</p></blockquote><h3 id="4-8-Shenandoah收集器"><a href="#4-8-Shenandoah收集器" class="headerlink" title="4.8 Shenandoah收集器"></a>4.8 Shenandoah收集器</h3><p>&emsp;Shenandoah是一款非官方的收集器，只有OpenJDK包含，OracleJDK不包含。Shenandoah收集器同G1收集器一样，也是基于Region布局。Shenandoah相比G1，做了三个改进：</p><ul><li>支持并发的整理算法，Shenandoah的回收阶段可以和用户线程并发执行</li><li>目前不使用分代收集，Region就是Region，不会标记是否为OEDH</li><li>摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率。</li></ul><h4 id="连接矩阵"><a href="#连接矩阵" class="headerlink" title="连接矩阵"></a><b style="color:red">连接矩阵</b></h4><p>&emsp;连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向RegionM，就在表格的N行M列中打上一个标记，如图所示，如果Region 5中的对象Baz引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LTkyODY4ZDQyNDg4ZjgwNzQuanBn?x-oss-process=image/format,png"></p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><b style="color:red">工作流程</b></h4><p>&emsp;Shenandoah收集器工作分为一下9个阶段：</p><ol><li><p>初始标记（Initial Marking）：与G1一样，只标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</p></li><li><p><strong>并发标记（Concurrent Marking）</strong> ：与G1一样，从GC Root开始对堆中对象进行可达性分析，找出存活的对象，可与用户线程并发执行，不会造成停顿，时间的长度取决于堆中存活对象的数量和对象图的结构复杂度。</p></li><li><p>最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set），会有一小段短暂的停顿。</p></li><li><p>并发清理（Concurrent Cleanup）：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region）。</p></li><li><p><strong>并发回收（Concurrent Evacuation）</strong> ：首先把回收集里面的存活对象先复制一份到其他未被使用的Region之中，然后通过读屏障和Brooks Pointers转发指针技术来解决在垃圾回收期间用户线程继续读写被移动对象的问题，并发回收阶段运行的时间长短取决于回收集的大小。</p></li><li><p>初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。</p></li><li><p><strong>并发引用更新（Concurrent Update Reference）</strong> ：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</p></li><li><p>最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要修正存在于GCRoots中的引用。会产生一个非常短暂的停顿，停顿时间只与GC Roots的数量相关。</p></li><li><p>并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，所以最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</p></li></ol><h4 id="Brooks-Pointer转发指针技术"><a href="#Brooks-Pointer转发指针技术" class="headerlink" title="Brooks Pointer转发指针技术"></a><b style="color:red">Brooks Pointer转发指针技术</b></h4><p>&emsp;Brooks提出了使用转发指针技术来实现对象移动与用户程序并发的一种解决方案。Brooks 在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己（类似句柄，一个是放在句柄池中，一个是放在对象头前面），如图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LWJkYzk1YWU3ZDY3NWExMzIuanBn?x-oss-process=image/format,png"></p><p>&emsp;在对象移动的时候我们只需要将Brooks Pointer 指向新对象，在对象访问过程中，只通一条<code>mov</code>指令就可以完成对新对象的访问了，如图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LTE0YzlhYTc5NjFhN2Y5YjQuanBn?x-oss-process=image/format,png"></p><p>&emsp;当写操作发生时，Shenandoah收集器是通过CAS（Compare And Swap）操作，来保证收集器线程或者用户线程只有其中之一可以进行修改操作，以此来保证并发时对象访问的正确性。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><b style="color:red">优缺点</b></h4><ul><li>优点：延迟低</li><li>缺点：高运行负担使得吞吐量下降；使用大量的读写屏障，尤其是读屏障，增大了系统的性能开销；</li></ul><h3 id="4-9-ZGC收集器"><a href="#4-9-ZGC收集器" class="headerlink" title="4.9 ZGC收集器"></a>4.9 ZGC收集器</h3><p>&emsp;ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于<strong>动态Region</strong>内存布局，（暂时）<strong>不设年龄分代</strong>，使用了<strong>读屏障</strong>、<strong>染色指针</strong>和<strong>内存多重映射</strong>等技术来实现<strong>可并发的标记-整理算法</strong>的收集器。在JDK 11新加入，还在实验阶段，主要特点是：<strong>回收TB级内存（最大4T），停顿时间不超过10ms</strong>。</p><h4 id="动态Region"><a href="#动态Region" class="headerlink" title="动态Region"></a><b style="color:red">动态Region</b></h4><p>&emsp;ZGC的Region具有动态性——动态创建和销毁，区域动态容量。</p><ul><li><strong>小型Region（Small Region）</strong>：容量固定为2MB，用于放置小于256KB的小对象。</li><li><strong>中型Region（Medium Region）</strong>：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。·</li><li><strong>大型Region（Large Region）</strong>：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。<strong>每个大型Region中只会存放一个大对象</strong>，最小容量可低至4MB，因此大型Region可能小于中型Region。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LTY2ZDg0OGJkZjc5ZmY0NWUuanBn?x-oss-process=image/format,png" alt="动态容量"></p><h4 id="并发整理算法的实现——染色指针技术"><a href="#并发整理算法的实现——染色指针技术" class="headerlink" title="并发整理算法的实现——染色指针技术"></a><b style="color:red">并发整理算法的实现——染色指针技术</b></h4><p>&emsp;HotSpot虚拟机的<strong>标记</strong>实现方案有如下几种：</p><ol><li>把标记直接记录在对象头上（如Serial收集器）；</li><li>把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息）；</li><li>直接把标记信息记在引用对象的指针上（如ZGC）</li></ol><p>&emsp;<strong>染色指针</strong>是一种直接将少量额外的信息存储在指针上的技术。目前在Linux下64位的操作系统中高18位是不能用来寻址的，但是剩余的46为却可以支持64T的空间，到目前为止我们几乎还用不到这么多内存。于是ZGC将46位中的高4位取出，用来存储4个标志位，剩余的42位可以支持<strong>4T</strong>的内存，如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LWQ0ZTIyYWY3MDUwZTk5MDkucG5n?x-oss-process=image/format,png"></p><ul><li>Linux下64位指针的高18位不能用来寻址，所有不能使用；</li><li>Finalizable：表示是否只能通过finalize()方法才能被访问到，其他途径不行；</li><li>Remapped：表示是否进入了重分配集（即被移动过）；</li><li>Marked1、Marked0：表示对象的三色标记状态；</li><li>最后42用来存对象地址，最大支持4T；</li></ul><p>染色指针的三大优势：</p><ul><li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li><li>染色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ul><h4 id="内存多重映射"><a href="#内存多重映射" class="headerlink" title="内存多重映射"></a><b style="color:red">内存多重映射</b></h4><p>&emsp;将多个不同的虚拟内存地址映射到同一个物理内存地址上。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了，效果如图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LWZkNWM2YTdjNTEwYTc4ZTkucG5n?x-oss-process=image/format,png" alt="内存多重映射"></p><p>&emsp;ZGC的多重映射只是它采用染色指针技术的伴生产物</p><h4 id="ZGC运作流程"><a href="#ZGC运作流程" class="headerlink" title="ZGC运作流程"></a><b style="color:red">ZGC运作流程</b></h4><p>&emsp;可以分为四个阶段：</p><ol><li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记和最终标记也会出现短暂的停顿，整个标记阶段只会更新染色指针中的Marked 0、Marked 1标志位。</li><li>并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li><li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</li><li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82NDY0MDg2LWFjMTU5ZDdlMTQ3ZTM3ZDkucG5n?x-oss-process=image/format,png"></p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><b style="color:red">优缺点</b></h4><ul><li>优点：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小</li><li>缺点：浮动垃圾。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2020/10/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/29/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1、类加载机制概述"><a href="#1、类加载机制概述" class="headerlink" title="1、类加载机制概述"></a>1、类加载机制概述</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTMyMzMwNjgyLnBuZw?x-oss-process=image/format,png" alt="java虚拟机的结构图简图"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTQ1MzIxMjIyLnBuZw?x-oss-process=image/format,png" alt="java虚拟机的结构图详细图"><br>&emsp;java虚拟机的结构图如上所示，从详细图可以看出，字节码文件首先会被类加载器子系统加载到内存中，类加载器的工作分为三步：<strong>加载、链接和初始化</strong>。加载需要加载器，比如引导加载器、扩展加载器和应用加载器等。链接环节分为验证、准备、解析三个步骤，最后是初始化。文件被加载到内存中，内存中又分为不同区域。之后解释器和JIT即时编译器会把字节码翻译成成机器指令。当内存使用完毕后，GC收集器会对内存区域进行回收。</p><p>&emsp;从上图可以看出，如果自己手写虚拟机，需要考虑  <strong>类加载器</strong> 和 <strong>执行引擎</strong>。类加载是虚拟机极其重要的一个过程。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MDgxODEzNDA5LnBuZw?x-oss-process=image/format,png" alt="类加载器子系统"></p><p>&emsp;class文件中描述了各种信息，这些信息需要被加载到虚拟机之后才能被运行和使用。java虚拟机吧描述类的数据从Class文件加载到内存，并对其进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这个过程被称作虚拟机的类加载机制。<br>&emsp;java语言里面，类型的加载、连接和初始化实在程序运行期间完成的，而不是像某些语言一样，在编译阶段就完成了。这种策略虽然让提前编译多些困难，也让类加载稍微增加了性能开销，但是却为java应用提高了极高的扩展性和灵活性。<strong>java的动态扩展特性就是依赖于运行期动态加载和动态链接特点实现的。</strong>比如Applet、JSP和OSGI等技术，都依赖于运行期动态加载才实现。</p><h2 id="2、类加载的时机"><a href="#2、类加载的时机" class="headerlink" title="2、类加载的时机"></a>2、类加载的时机</h2><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3278574594,735796484&fm=26&gp=0.jpg" alt="类的生命周期"></p><p>&emsp;一个类型（类或接口）从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备和解析被统称为连接（Linking）。<br>&emsp;其中加载、验证、准备、初始化和卸载顺序是确定的，类加载必须按照此顺序开始，而解析则不一定，某些情况下它可以在初始化之后再开始（比如动态绑定时）。<br>&emsp;虚拟机规范明确规定了以下6种情况必须立即对类进行初始化。如果类型没有进行过初始化，则必须进行类的加载、验证、准备和初始化。</p><ul><li>遇到new、getstatic、putstatic和invokestatic 4条字节码指令。即实例化对象（new），读取静态字段和调用静态方法时。</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化类时发现父类还没初始化过，则必须先初始化父类</li><li>虚拟机启动时，需要执行主类（main），虚拟机会先初始化主类。</li><li>jdk7新加的动态语言支持，如果java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_newInvokeStatic和REF_newInvokeSpecial四种类型的方法句柄，且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>jdk8新加入的默认方法（default修饰的接口方法）。如果接口的实现类发生了初始化，则该接口必须先被初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hk7.memory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingSuper</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;super&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String val = <span class="hljs-string">&quot;JVM&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        LoadingSuper[] a = <span class="hljs-keyword">new</span> LoadingSuper[<span class="hljs-number">10</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;以上代码并不会输出super，是因为以上代码并没有触发LoadingSuper类的初始化阶段，但是它出发了[Lcom.hk7.memory.LoadingSuper初始化，数组的定义是由newarray指令触发的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(LoadingSuper.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;依旧不会输出super，因为以上代码也没有触发LoadingSuper类的初始化阶段。虽然确实引用了LoadingSuper类的常量，但是实际上，在编译阶段，由于常量传播优化，此常量的值”JVM“已经被存储在NotInitialization类中了。编译之后LoadingTest直接引用的是NotInitialization类，因此LoadingSuper并不会被初始化。</p><p>&emsp;对于接口的类初始化，区别在于以上第3种，接口初始化时不必初始化父类，父类只有被使用到才会初始化。</p><h2 id="3、类加载过程"><a href="#3、类加载过程" class="headerlink" title="3、类加载过程"></a>3、类加载过程</h2><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>&emsp;加载是类加载第一个阶段，这一阶段，jvm需要完成以下三件事：</p><ul><li>通过一个类的全限定（比如java.lang.Integer）名来获取定义此类的二进制字节流。</li><li>将获取到的字节流所代表的的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>&emsp;需要注意，类的二进制字节流文件不仅仅从磁盘加载，还可以从网络、数据库、压缩包或者运行时计算生成等。</p><ul><li><p>非数组类型的加载阶段，可以使用jvm内置的引导类加载器来完成，也可以使用自定义的类加载去完成。</p></li><li><p>对于数组类不通过类加载创建，而是jvm直接在内存中构造出来的。但是数组类的元素类型最终还是依靠类加载器来完成加载，它的创建规则如下：</p><ul><li>如果数组组件类型为引用类型，则递归的采用本节定义的加载过程加载组件类型。数组会被标识在该类加载的类名称空间上。</li><li>如果是直接类型，则把数组C标记为与引导类加载器关联。</li><li>数组类的可访问性和它的组件类型可访问性一致，如果不是引用类型，则为public。</li></ul></li></ul><p>&emsp;加载阶段结束后，二进制字节流就按照虚拟机所规定的格式存储在方法区里面了，方法区中的数据结构由虚拟机实现自行定义。类型数据妥善安置在方法区之后，会在java堆内存中实例化一个java.lang.Class类对象，这个对象是程序访问方法区中类型数据的外部接口。</p><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>&emsp;验证是一个很重要的阶段，必须确保class文件中的数据全都符合虚拟机规范，保证不会危害到虚拟机自身安全。验证阶段决定了虚拟机是否能承受恶意代码的攻击，在性能和代码量来说，占了类加载很大的比重。验证的东西特别多，主要分为文件格式验证、元数据验证、字节码验证和符号引用验证四种。</p><blockquote><p>文件格式验证</p></blockquote><p>&emsp;主要是验证class文件的格式是否符合虚拟机规范。比如是否0xCAFEBABE开头，版本号是否合理、常量池类型等。具体可看类文件结构分析。验证通过后字节流才被允许存储在jvm内存的方法区中。后面的阶段均基于方法区进行，不会再读取字节流。</p><blockquote><p>元数据验证</p></blockquote><p>&emsp;对字节码描述的信息进行语义分析。比如类是否有父类、是否继承了不被允许继承的类、类中的方法字段等是否和父类产生矛盾等。</p><blockquote><p>字节码验证</p></blockquote><p>&emsp;最复杂的验证，主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。元数据校验之后，这部分是对类的方法体（Class文件中的Code属性）进行校验。保证方法被运行时不会危害虚拟机。比如</p><ul><li><p>任意时刻操作数栈的数据类型和指令序列能操作的数据类型一致。比如iload  —  long不可。</p></li><li><p>任何跳转指令不会跳到方法体以外的字节码指令上。</p></li><li><p>方法体中的类型转换合法。比如Pig转Animal可，Pig转Food不可。</p><p>……</p></li></ul><p>&emsp;由于字节码验证复杂性很高，为了避免验证阶段耗费过多时间，jdk6之后的javac编译器进行了优化，把大量的辅助验证挪到javac编译器里进行。具体是：给方法体的Code属性属性表中新增了一块”StackMapTable“的新属性，该属性描述了方法的所有基本块开始时的本地变量表和操作栈应有的状态。在字节码验证阶段，只验证StackMapTable的合理性。这样就将类型推导变为了类型检查，大大节省时间。推导的过程编译时验证。</p><blockquote><p>符号引用验证</p></blockquote><p>&emsp;解析时，虚拟机会将符号引用转化为直接引用，这时需要对符号引用进行验证。验证内容为</p><ul><li><p>符号引用中通过字符的全限定名是否可以找到对应的类</p></li><li><p>指定类中是否存在符合方法的字段描述符以及简单名所描述的方法和字段</p></li><li><p>符号引用中的类、字段、方法的可访问性是否可被当前类访问</p><p>……</p></li></ul><p>&emsp;符号引用验证目的是确保解析能够正常执行。如果验证不通过，则会抛出java.lang.IncompatibleClassChangeError的子异常。</p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p>&emsp;准备阶段正式为类中定义的<strong>静态变量</strong>分配内存并设置零值。在JDK7及其之前，HotSpot使用永久代来实现方法区，内存分配在方法区上进行。JDK8及其之后，类变量会随着Class对象一起存放在Java堆中。</p><p>&emsp;准备阶段只是为类变量赋值，而且是赋零值。实例变量会随着对象的实例化和对象一起被分配在java堆中。比如<code>public static int val = 123</code>，准备阶段之后，val的值为0。给val赋值123的putstatic指令是程序编译后，存放在构造器clinit()方法中，因此真正赋值的动作要到类的初始化阶段才会被执行。java基本数据类型的零值如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>   <span class="hljs-number">0</span><br>long  <span class="hljs-number">0</span>L<br>short (short)<span class="hljs-number">0</span><br>char  <span class="hljs-string">&#x27;\u0000&#x27;</span><br>byte(byte)<span class="hljs-number">0</span><br><span class="hljs-built_in">bool</span>ean<span class="hljs-literal">false</span><br><span class="hljs-built_in">float</span> <span class="hljs-number">0.0f</span><br><span class="hljs-built_in">double</span><span class="hljs-number">0.0</span>d<br><span class="hljs-built_in">ref</span>erence<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>&emsp;一般而言，准备阶段会给类变量赋零值，但是也有例外。<strong>如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段类变量会被初始化为ConstantValue属性所指定的初始值</strong>。比如<code>public static final int val=123</code>，编译时javac会为val生成ConstantValue属性，在准备阶段虚拟机会把val赋值为123。</p><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>&emsp;该阶段主要工作：<strong>java虚拟机将常量池内的符号引用替换为直接引用</strong>。</p><ul><li>符号引用：用一组符号描述所引用的目标，比如Class文件中的CONSTANT_Class_info等常量。符号引用与虚拟机内存布局无关，引用的目标并不一定必须加载到内存中。</li><li>直接引用：可以直接执行目标的指针、相对偏移量或者是一个能简介定位到目标的句柄。直接引用和虚拟机实现的内存布局直接相关。</li></ul><p>&emsp;比如有以下代码，当加载A.class文件时，b.f()这一段代码块以符号的形式存在（比如f），标识这个地方引用的不是实际内存中存在的地址，这个叫符号引用。链接的时候，所有jvm会把所有f符号引用的代码块替换为实际内存地址，这个叫直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        B b = <span class="hljs-keyword">new</span> B();<br>      b.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;《java虚拟机规范》没有规定解析发生的具体时间，但是以下执行以下指令之前，必须对符号引用进行解析。以下指令有个共同点，都需要操作内存，因此在此之前必须完成解析。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">anewarray                       <span class="hljs-regexp">//</span>创建新数组<br>checkcast                       <span class="hljs-regexp">//</span>检查数组属性<br>getfield<span class="hljs-regexp">//</span>访问实例变量<br>getstatic<span class="hljs-regexp">//</span>访问类变量<br>instanceof<span class="hljs-regexp">//</span>判断类类型<br>invokedynamic<span class="hljs-regexp">//</span>动态调用方法<br>invokeinterface<span class="hljs-regexp">//</span>调用由接口实现的方法<br>invokespecial  <span class="hljs-regexp">//</span>根据编译时类型来调用实例方法<br>invokestatic<span class="hljs-regexp">//</span>调用命名类中的静态方法<br>invokevirtual<span class="hljs-regexp">//</span>调度对象的实例方法<br>ldc<span class="hljs-regexp">//</span>加载常量到操作数栈<br>ldc_w<span class="hljs-regexp">//</span>加载常量到操作数栈<br>ldc2_w<span class="hljs-regexp">//</span>加载常量到操作数栈<br>multianewarray<span class="hljs-regexp">//</span>创建新多维数组<br>new<span class="hljs-regexp">//</span>创建实例<br>putfield<span class="hljs-regexp">//</span>设置实例变量的值<br>putstatic<span class="hljs-regexp">//</span>设置类变量的值<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/3c710f7f62ad">https://www.jianshu.com/p/3c710f7f62ad</a></p><p>&emsp;虚拟机的实现可以根据需求自行判断，类被加载前就对常量池中的符号引用进行解析，还是等到符号引用将要被使用前才去解析它。</p><p>&emsp;同一个符号被多处引用，则会进行都次解析，除了invokedynamic指令，其他的指令第一次解析符号时，虚拟机会把解析结果缓存起来，后续再次解析符号时，会从缓存中直接读取。<strong>invokedynamic指令用于动态支持，必须程序运行到该条指令时，才会进行解析过程。</strong></p><blockquote><p>类或接口的解析</p></blockquote><p>&emsp;假设当前代码所处类为D，第一次解析符号引用N，将其解析为类或者接口C的直接饮用，步骤如下：</p><ol><li>C不是数组类型，虚拟机会N的全限定名传递给D的类加载器，D的类加载器会加载类C。过程中由于加载验证，可能会触发其他相关类的加载。</li><li>C是数组类型，且元素类型为对象，N的描述符类似于<code>[Ljava/lang/Integer</code>的形式，则按照规则1加载数组的元素类型，比如需要加载的元素类型为java.lang.Integre，虚拟机会生成一个代表该数组维度和元素的数组对象。</li><li>上述1和2正常加载后，C在虚拟机中实际上已经成为一个有效的类或者接口了，但是还需要进行符号引用验证，即验证D是否具备对C的访问权限。权限不符合会报java.lang.IllegalAccessError异常。</li></ol><p>&emsp;字段解析、方法解析、接口方法解析很简单，主要是解析符号，按照顺序层层解析，具体的解析例子可以看上一篇文章，类文件结构中的例子。</p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>&emsp;初始化时类加载过程的最后一个步骤，初始化阶段，虚拟机会根据程序员主观计划去初始化变量和其他资源，即执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法不是直接在java代码中定义的，而是javac编译器生成的。</p><p>&emsp;<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，收集顺序是和语句在代码中的顺序一致，<strong>静态语句块中只能访问到静态语句块之前的变量，之后的变量，可以赋值，但不能访问</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>  i = <span class="hljs-number">0</span>;                  <span class="hljs-comment">//正常编译通过</span><br>  System.out.println(i);  <span class="hljs-comment">//报错，Illegal forward reference</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>&emsp;由于父类的<code>&lt;clinit&gt;()</code>方法先执行，因此父类中定义的静态语句块优先于子类的变量赋值操作。java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法类型肯定是java.lang.Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Parent:<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">static</span>&#123;<br>    A = <span class="hljs-number">2</span>;<br>  &#125;<br>Child:<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> B = A; <span class="hljs-comment">//在B赋值前，A的值已经被赋值为2</span><br><br>Main:<br>System.out.println(Sub.B); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>&emsp;<code>&lt;clinit&gt;()</code>方法对于类或接口来说非必须，如果类中无static{}，没有类似static int = 1代码，也没有构造方法，则编译不会生成clinit方法。多线程环境中，只会有一个线程去执行这个类的clinit方法，其他线程会阻塞直至clinit执行结束。</p><h2 id="4、类加载器"><a href="#4、类加载器" class="headerlink" title="4、类加载器"></a>4、类加载器</h2><h3 id="4-1-类和类加载器"><a href="#4-1-类和类加载器" class="headerlink" title="4.1 类和类加载器"></a>4.1 类和类加载器</h3><p>&emsp;类加载器用于实现类的加载工作。类由类本身和加载它的类加载器来确定唯一性，同一个class文件被同一个虚拟机加载，但是如果加载他们的加载器不同，则这2个类不就不相等。比如以下例子，一个是由虚拟机的应用程序类加载器加载，一个是由自定义加载器加载，虽然来自同一个class文件com.hk7.memory.ClassLoadingTest.class，但java虚拟机中同时存在2个com.hk7.memory.ClassLoadingTest类，其instanceof结果不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;<br>  ClassLoader loader = <span class="hljs-keyword">new</span> ClassLoader() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        String fileName = name.substring(name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.class&quot;</span>;<br>        InputStream is = getClass().getResourceAsStream(fileName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == is) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.loadClass(name);<br>        &#125;<br><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];<br>        is.read(b);<br>        <span class="hljs-keyword">return</span> defineClass(name, b, <span class="hljs-number">0</span>, b.length);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>      &#125;<br><br>    &#125;<br>  &#125;;<br><br>  Object obj = loader.loadClass(<span class="hljs-string">&quot;com.hk7.memory.ClassLoadingTest&quot;</span>).newInstance();<br>  System.out.println(obj.getClass()); <span class="hljs-comment">//class com.hk7.memory.ClassLoadingTest</span><br>  System.out.println(obj <span class="hljs-keyword">instanceof</span> ClassLoadingTest);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-双亲委派机制"><a href="#4-1-双亲委派机制" class="headerlink" title="4.1 双亲委派机制"></a>4.1 双亲委派机制</h3><p>&emsp;类加载器除了能用来加载类，还能用来作为类的层次划分。Java自身提供了3种类加载器：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：属于虚拟机自身的一部分，用C++实现，负责加载<code>&lt;JAVA_HOME&gt;\lib</code>目录中或被-Xbootclasspath指定的路径中的并<strong>且文件名是被虚拟机识别</strong>的文件。自己放进去的类无法被加载。</li><li>扩展类加载器(Extension ClassLoader)：java实现，独立于虚拟机。主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中或被java.ext.dirs系统变量所指定的路径的类库。</li><li>应用程序类加载器(Application ClassLoader)：java实现，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器，那它就是我们程序中的默认加载器。</li></ul><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1605693998967&di=50d862ec9c7975e89fb3497c632504c6&imgtype=0&src=http://img-blog.csdnimg.cn/img_convert/18ea18c886353f393e9c501b7ac6f4e9.png" alt="双亲委派模型"></p><p>&emsp;上图就类加载的双亲委派模型。如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。双亲委派的实现及其简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class loadClass&lt;T&gt;(String name, <span class="hljs-keyword">boolean</span> resolve) &#123;&#123;<br>  <span class="hljs-comment">//先判断class是否已经被加载过了</span><br>  Class&lt;T&gt; c = findLoadedClass(name);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">long</span> t0 = System.nanoTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);  <span class="hljs-comment">//找父类去加载</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        c = findBootstrapClassOrNull(name);  <span class="hljs-comment">//没父类说明是顶层了就用Bootstrap ClassLoader去加载</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>      <span class="hljs-comment">// from the non-null parent class loader</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>      <span class="hljs-comment">// to find the class.</span><br>      <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>      c = findClass(name);    <span class="hljs-comment">//最后如果没找到，那就自己自家</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (resolve) &#123;<br>    resolveClass(c);<br>  &#125;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;<strong>双亲委派机制使得类之间具有了优先级的层次关系，可以保证java体系的基础行为的正确性</strong>。比如，类java.lang.Object，它存放于<code>&lt;JAVA_HOME&gt;\lib</code>的rt.jar之中，无论哪一个加载器加载该类，最后都是委派给Bootstrap ClassLoader加载，因此Object类在程序的各个加载环境之中都是同一个类。如果不遵循双亲委派机制，由各个加载器自行加载，如果有不法分子自行构造java.lang.Object类，嵌入了危害代码，那么构造的Object类会被加载进虚拟机，会导致虚拟机中各个Object类不一致，甚至会导致整个应用程序崩溃，因此为了保证程序的争取运行，推荐使用双亲委派机制。双亲委派机制中，自行编写的基础类，可以被编译，但无法被加载运行。</p><h3 id="4-1-破坏双亲委派机制"><a href="#4-1-破坏双亲委派机制" class="headerlink" title="4.1 破坏双亲委派机制"></a>4.1 破坏双亲委派机制</h3><p>&emsp;<strong>双亲委派模型不是一种强制性约束，也就是你不这么做也不会报错怎样的，它是一种JAVA设计者推荐使用类加载器的方式。</strong>有时也可能违背双亲委派机制，比如JDBC。</p><p>&emsp;我们知道SPI，它不同于API，是由各个厂商实现的，java只需要定义SPI的标准，mysql有mysql的jdbc实现，oracle有oracle的jdbc实现，只需遵循标准，java就能调动数据库。JDBC的实现必须违背双亲委派机制，因为遵循的话Boostrap ClassLoader无法自行加载各个厂商的类，只能委托子类来加载厂商提供的具体实现。为了解决这个问题，java设计团队引入了<strong>线程上下文类加载器</strong>（Thread Context ClassLoader）。</p><p>&emsp;这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果线程创建时还未设置，会从父类线程中继承一个，如果应用程序的全局范围内都没有设置过，这个类加载默认就是应用程序类加载器。java中涉及到SPI的加载基本都是使用该方式完成，比如JDBC、JNDI、JCE、JAXB和SPA等。但这种方式不太优雅，jdk6提供了java.util.ServiceLoader类，结合META-INF/services中的配置信息，辅以责任链模式来解决。</p><p>&emsp;再比如商家对动态部署的需求，比如OSGI的模块坏热部署，使得双亲委派机制被打破。OSGI热部署的关键是它自定义的类加载器实现，每一个程序模块都有自己的类加载器，当需要更坏模块时，把模块和类加载器一起换掉以实现代码的热替换。</p><h2 id="5、Java模块化系统"><a href="#5、Java模块化系统" class="headerlink" title="5、Java模块化系统"></a>5、Java模块化系统</h2><p>&emsp;为了实现<strong>可配置的封装隔离机制</strong>，JDK引入了Java模块化系统（Java Platform Module System，JPMS）。java虚拟机对类加载架构也做了响应的变动调整。Java模块包括以下内容（类似于modejs的包的概念）：</p><ul><li>代码的容器</li><li>依赖其他模块的列表</li><li>导出的包列表，即其他模块可以使用的列表</li><li>开放的包列表，即其他模块可反射访问模块的列表</li><li>使用的服务列表</li><li>提供服务的实现列表</li></ul><p>&emsp;模块化之前，类加载主要依靠类路径，如果类路径中缺失了依赖的类型，那么只能等到程序运行到该类型的加载、链接时才会报出运行时异常。JDK9之后，如果启用了模块化封装，模块可以申明对其他模块的显示依赖，这样虚拟机就能够在启动时验证程序运行需要的依赖关系在运行期是否完备，如果缺失则启动失败，这样可以避免大部分的由依赖引发的运行时异常。</p><p><a href="https://zhuanlan.zhihu.com/p/167729732">模块化优点</a>具体的JDK9的模块化系统可以读读其他文章。</p><h3 id="5-1-模块的兼容"><a href="#5-1-模块的兼容" class="headerlink" title="5.1 模块的兼容"></a>5.1 模块的兼容</h3><p>&emsp;java里面有“类路径（ClassPath）”的概念，JDK9为了兼容，提出了“模块路径（ModulePath）”的概念。</p><p>&emsp;某个类库到底是模块还是传统的jar包，取决于它存放在哪种路径上。只要是处于类路径上的，即便包含了模块信息也会被当做传统jar包对待。而放在模块路径上的包，即使不包含JMOD后缀，不包含module-info.class文件，也会被当做模块来对待。</p><p>&emsp;JPMS的向下兼容规则：</p><ul><li>jar文件在类路径的访问规则：所有类路径下的jar文件及其他资源，被视为自动打包在一个匿名模块中（Unamed Module）里，匿名模块没有任何隔离，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块导出的包。</li><li>模块在模块路径访问规则：具名模块（Named Module）只能访问它列明的模块和包。不可访问匿名模块，即具名模块看不见传统jar内容。</li><li>jar文件在模块路径的访问规则：传统的jar包放到模块路径下，它会变成一个自动模块（Automatic Module）。不包含module-info.class文件，但默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，也默认导出自己所有的包。</li></ul><p><img src="http://imgconvert.csdnimg.cn/aHR0cHM6Ly9yZXMuaW5mb3EuY29tL2FydGljbGVzL2phdmE5LW9zZ2ktZnV0dXJlLW1vZHVsYXJpdHktcGFydC0yL2VuL3Jlc291cmNlcy8yZmlndXJlLmpwZw?x-oss-process=image/format,png" alt="OSGI和JPMS的交互"></p><h3 id="5-2-模块下的类加载器"><a href="#5-2-模块下的类加载器" class="headerlink" title="5.2 模块下的类加载器"></a>5.2 模块下的类加载器</h3><p>&emsp;模块化之后，扩展类加载器被平台类加载器取代。平台类加载器之后依然是自定义类加载器（图中未画出）。模块化之后整个java类库都满足可扩展的需求，因此无需再保留<code>&lt;java_home&gt;\lib/ext</code>目录，<br><img src="https://www.freesion.com/images/996/c62a8f3caf451578f58630c0e55ce61c.JPEG" alt="JDK9之后的双亲委派模型"><br>&emsp;平台类或者程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如可以就优先委派给负责那个模块的加载器。</p><p>&emsp;在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块。<br>&emsp;启动类加载器负责加载的模块：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.base</span>                        <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.sasl</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.datatransfer</span>                <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.xml</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.desktop</span>                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.httpserver</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.instrument</span>                  <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.vm</span><span class="hljs-selector-class">.ci</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.logging</span>                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.management</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.management</span>                  <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.agent</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.rmi</span>              <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.rmi</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.naming</span>                      <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.net</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.prefs</span>                       <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.sctp</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.rmi</span>                         <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.unsupported</span><br></code></pre></td></tr></table></figure><p>&emsp;平台类加载负责加载的模块：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.activation</span>*                <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.accessibility</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.compiler</span>*                  <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.charsets</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.corba</span>*                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.crypto</span><span class="hljs-selector-class">.cryptoki</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.scripting</span>                  <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.crypto</span><span class="hljs-selector-class">.ec</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.se</span>                         <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.dynalink</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.se</span><span class="hljs-selector-class">.ee</span>                      <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.incubator</span><span class="hljs-selector-class">.httpclient</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.jgss</span>              <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.vm</span><span class="hljs-selector-class">.compiler</span>*<br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.smartcardio</span>                <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jsobject</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.sql</span>                        <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.localedata</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.sql</span><span class="hljs-selector-class">.rowset</span>                 <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.naming</span><span class="hljs-selector-class">.dns</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.transaction</span>*               <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.scripting</span><span class="hljs-selector-class">.nashorn</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.bind</span>*                  <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.auth</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.crypto</span>                 <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.jgss</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.ws</span>*                    <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.dom</span><br><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.ws</span><span class="hljs-selector-class">.annotation</span>*         <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.zipfs</span><br></code></pre></td></tr></table></figure><p>&emsp;应用程序类加载器负责加载的模块：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.aot</span>                         <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jdeps</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.attach</span>                      <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jdi</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.compiler</span>                    <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jdwp</span><span class="hljs-selector-class">.agent</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.editpad</span>                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jlink</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.hotspot</span><span class="hljs-selector-class">.agent</span>               <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jshell</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.ed</span>                 <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jstatd</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.jvmstat</span>            <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.pack</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.le</span>                 <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.policytool</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.opt</span>                <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.rmic</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jartool</span>                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.scripting</span><span class="hljs-selector-class">.nashorn</span><span class="hljs-selector-class">.shell</span><br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.javadoc</span>                     <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.bind</span>*<br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jcmd</span>                        <span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.xml</span><span class="hljs-selector-class">.ws</span>*<br><span class="hljs-selector-tag">jdk</span><span class="hljs-selector-class">.jconsole</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类文件结构分析</title>
    <link href="/2020/10/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <url>/2020/10/10/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p> 参考：<a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7.5">https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7.5</a> jdk11</p><p>&emsp;前面说过，任何语言只要能被编译成符合规范的字节码文件，就可以在虚拟机上运行。字节码文件是java规范中规定的，一个class文件必定对应着一个类或者接口的信息，但是反过来则不一定，因为类或者接口可以动态生成，直接被类加载器加载。</p><p><strong>&emsp;class文件是一组以8字节为基础单位的二进制流，代码中各个部分严格按照顺序排列在文件中，没有任何分隔符。当遇到需要占用8字节以上空间的数据项时，会按照高位在前的方式分割成若干个8字节进行存储。</strong></p><p>&emsp;class文件由表中所展示的这些项组成。u1、u2……代表1个字节、2个字节等。“_info”结尾的代表是表，复合数据结构。</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3184539622,2942284202&fm=26&gp=0.jpg" alt="class文件结构"></p><h2 id="1-魔数和版本号"><a href="#1-魔数和版本号" class="headerlink" title="1 魔数和版本号"></a>1 魔数和版本号</h2><p>&emsp;class文件的头4个字节被称为魔数(Magic Number)，它用来标识该文件是否为有效的class文件，class文件的魔数值为“0xCAFABABE”，我们可以看到任何class文件都是以“0xCAFABABE”开头。</p><p>&emsp;魔数之后是java的版本号，第5、6字节为次版本号，第7、8字节为主版本号。jdk版本号从45开始，jdk版本号和java版本的对应规则如下图所示。魔数版本号在验证阶段，都会对其进行校验。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">JDK版本版本号<br>JDK <span class="hljs-number">6</span><span class="hljs-number">50</span><br>JDK <span class="hljs-number">7</span><span class="hljs-number">51</span><br>JDK <span class="hljs-number">8</span><span class="hljs-number">52</span><br>JDK <span class="hljs-number">9</span><span class="hljs-number">53</span><br>JDK <span class="hljs-number">10</span><span class="hljs-number">54</span><br>JDK <span class="hljs-number">11</span><span class="hljs-number">55</span><br>JDK <span class="hljs-number">12</span><span class="hljs-number">56</span><br>JDK <span class="hljs-number">13</span><span class="hljs-number">56</span><br></code></pre></td></tr></table></figure><p>&emsp;<a href="https://img-blog.csdnimg.cn/20201013180326577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70">jdk版本号对应关系图</a></p><p>&emsp;比如有以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hk7.memory;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HelloWorld</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhoumi</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/10/13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&emsp;使用010editor打开，可以看到以<code>0xCAFEBABE</code>开头，主版本号是0x0034 = 52，表示该class文件可以被jdk8及其以上版本的虚拟机执行。</p><p><img src="https://img-blog.csdnimg.cn/20201015191651490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="字节码文件"></p><h2 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2 常量池"></a>2 常量池</h2><p>&emsp;在版本号之后是常量池，是class文件结构中与其他项目关联最多的数据，也是占用class文件空间最大的数据项目之一。</p><p>&emsp;由于常量池中常量的数量是不固定的，所以在常量池的入口处必须放一个2字节的数表示常量池中常量的个数。上图中可以看出该class文件常量池中常量的个数为<code>0x0018</code> = 24，表示有23个常量，索引范围为1~23。索引从1开始是因为设计者将0位置空出来以满足“不引用常量池中的任何项目”需求。<strong>常量池是唯一一个索引从1开始计算的集合。</strong></p><p>&emsp;常量池中存放的内容为：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic References）。</p><p>&emsp;字面量表示文本字符串、被声明为final的常量值等。</p><p>&emsp;符号引用包括以下几类：</p><ul><li>被模块导出或者开放的包</li><li>类和接口的全限定名</li><li>字段的名称和描述符（Description）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul><p>&emsp;常量池中吗，每一个常量项都是一个表，最初有11种结构，后面为了支持动态语言调用、支持模块化系统又加入了6种，截止JDK13，常量表中有17种不同类型的常量，每种常量类型的结构都不同，如下表所示：</p><table>  <tr>    <td>常量</td>    <td>描述</td>    <td>项目</td>    <td>类型</td>    <td>描述</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_utf8_info</td>    <td rowspan=3>Utf-8编码的字符串</td>    <td>tag</td>    <td>u1</td>    <td>值为1</td>  </tr>  <tr>    <td>length</td>    <td>u2</td>    <td>utf-8编码的字符串长度</td>  </tr>  <tr>    <td>bytes</td>    <td>u1</td>    <td>长度为length的utf-8编码的字符串</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Integer_info</td>    <td rowspan=2>整形字面量</td>    <td>tag</td>    <td>u1</td>    <td>值为3</td>  </tr>  <tr>    <td>bytes</td>    <td>u4</td>    <td>高位在前存储的int值</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Float_info</td>    <td rowspan=2>浮点型字面量</td>    <td>tag</td>    <td>u1</td>    <td>值为4</td>  </tr>  <tr>    <td>bytes</td>    <td>u4</td>    <td>高位在前存储的float值</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Long_info</td>    <td rowspan=2>长整形字面量</td>    <td>tag</td>    <td>u1</td>    <td>值为5</td>  </tr>  <tr>    <td>bytes</td>    <td>u8</td>    <td>高位在前存储的long值</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Double_info</td>    <td rowspan=2>双精度浮点型字面量</td>    <td>tag</td>    <td>u1</td>    <td>值为6</td>  </tr>  <tr>    <td>bytes</td>    <td>u8</td>    <td>高位在前存储的double值</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Class_info</td>    <td rowspan=2>类或者接口的符号引用</td>    <td>tag</td>    <td>u1</td>    <td>值为7</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向全限定名常量项的索引</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_String_info</td>    <td rowspan=2>字符串类型字面量</td>    <td>tag</td>    <td>u1</td>    <td>值为8</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向字符串字面量的索引</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_Fieldref_info</td>    <td rowspan=3>字段的符号引用</td>    <td>tag</td>    <td>u1</td>    <td>值为9</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向字段描述符CONSTANT_NameAndType_info的索引项</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_Methodref_info</td>    <td rowspan=3>类中方法的符号引用</td>    <td>tag</td>    <td>u1</td>    <td>值为10</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向声明方法的类描述符CONSTANT_Class_info的索引项</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向名称及类型描述符CONSTANT_NameAndType_info的索引项</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_InterfaceMethodref_info</td>    <td rowspan=3>接口中方法的符号引用</td>    <td>tag</td>    <td>u1</td>    <td>值为11</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向声明方法的接口描述符CONSTANT_Class_info的索引项</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向名称及类型描述符CONSTANT_NameAndType_info的索引项</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_NameAndType_info</td>    <td rowspan=3>字段或方法的部分符号引用</td>    <td>tag</td>    <td>u1</td>    <td>值为12</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向该字段或方法名称常量项的索引</td>  </tr>  <tr>    <td>index</td>    <td>u2</td>    <td>指向该字段或方法描述符常量项的索引</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_MethodHandle_info</td>    <td rowspan=3>表示方法句柄</td>    <td>tag</td>    <td>u1</td>    <td>值为15</td>  </tr>  <tr>    <td>reference_kind</td>    <td>u1</td>    <td>值在[1,9]，决定方法句柄的类型。方法句柄类型的值表示方法句柄的字节码行为</td>  </tr>  <tr>    <td>reference_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_MethodType_info</td>    <td rowspan=2>表示方法类型</td>    <td>tag</td>    <td>u1</td>    <td>值为16</td>  </tr>  <tr>    <td>descriptor_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用，且必须为CONSTANT_utf8_info结构，表示方法的描述符</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_Dynamic_info</td>    <td rowspan=3>表示一个动态计算常量</td>    <td>tag</td>    <td>u1</td>    <td>值为17</td>  </tr>  <tr>    <td>bootstrap_method_attr_index</td>    <td>u2</td>    <td>值必须是对当前class文件中引导方法表的boostrap_methods[]数据的有效索引</td>  </tr>  <tr>    <td>name_and_type_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用，且必须为CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td>  </tr>  <tr>    <td rowspan=3>CONSTANT_InvokeDynamic_info</td>    <td rowspan=3>表示一个动态方法调用点</td>    <td>tag</td>    <td>u1</td>    <td>值为18</td>  </tr>  <tr>    <td>bootstrap_method_attr_index</td>    <td>u2</td>    <td>值必须是对当前class文件中引导方法表的boostrap_methods[]数据的有效索引</td>  </tr>  <tr>    <td>name_and_type_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用，且必须为CONSTANT_NameAndType_info结构，表示方法名和方法描述符</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Module_info</td>    <td rowspan=2>表示一个模块</td>    <td>tag</td>    <td>u1</td>    <td>值为19</td>  </tr>  <tr>    <td>name_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用，且必须为CONSTANT_utf8_info结构，表示模块名字</td>  </tr>  <tr>    <td rowspan=2>CONSTANT_Package_info</td>    <td rowspan=2>表示一个模块中开放或者导出的包</td>    <td>tag</td>    <td>u1</td>    <td>值为20</td>  </tr>  <tr>    <td>name_index</td>    <td>u2</td>    <td>值必须是对常量池的有效引用，且必须为CONSTANT_utf8_info结构，表示包名称</td>  </tr></table><p>&emsp;我们还是看上面的例子，<code>0A 00 04 00 13</code>,常量池常量个数位之后tag是 0x0A = 10，可知这是一个CONSTANT_Methodref_info类中方法的符号引用常量。再后面是2个index，类型为u2、u2，也就是0x0004 = 4 和 0x0013 = 19，分别指向常量池中的第4个常量项和第19个常量项，翻译完整个字节码，发现第4个常量是CONSTANT_Class_info类型，第19个常量是CONSTANT_NameAndType_info类型，符合定义，以此类推直至解析完整个常量池。</p><p>&emsp;我们采用<code>javap -v xxx.class</code>来解析字节码如下，可以看到第1个常量是Methodref，第4个是Class，第19个是NameAndType，和我们手动计算的一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs class">Constant pool:<br>   #1 &#x3D; Methodref          #4.#19         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 &#x3D; Fieldref           #3.#20         &#x2F;&#x2F; com&#x2F;hk7&#x2F;memory&#x2F;ClassTest.num:I<br>   #3 &#x3D; Class              #21            &#x2F;&#x2F; com&#x2F;hk7&#x2F;memory&#x2F;ClassTest<br>   #4 &#x3D; Class              #22            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object<br>   #5 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;io&#x2F;Serializable<br>   #6 &#x3D; Utf8               num<br>   #7 &#x3D; Utf8               I<br>   #8 &#x3D; Utf8               &lt;init&gt;<br>   #9 &#x3D; Utf8               ()V<br>  #10 &#x3D; Utf8               Code<br>  #11 &#x3D; Utf8               LineNumberTable<br>  #12 &#x3D; Utf8               LocalVariableTable<br>  #13 &#x3D; Utf8               this<br>  #14 &#x3D; Utf8               Lcom&#x2F;hk7&#x2F;memory&#x2F;ClassTest;<br>  #15 &#x3D; Utf8               add<br>  #16 &#x3D; Utf8               ()I<br>  #17 &#x3D; Utf8               SourceFile<br>  #18 &#x3D; Utf8               ClassTest.java<br>  #19 &#x3D; NameAndType        #8:#9          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V<br>  #20 &#x3D; NameAndType        #6:#7          &#x2F;&#x2F; num:I<br>  #21 &#x3D; Utf8               com&#x2F;hk7&#x2F;memory&#x2F;ClassTest<br>  #22 &#x3D; Utf8               java&#x2F;lang&#x2F;Object<br>  #23 &#x3D; Utf8               java&#x2F;io&#x2F;Serializable<br></code></pre></td></tr></table></figure><h2 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3 访问标志"></a>3 访问标志</h2><p>&emsp;常量池之后紧接着的是访问标志，占2个字节，用于识别一些类或者接口层次的访问信息。标识符的类型和含义如下表所示：</p><table>  <tr>    <td>标志名称</td>    <td>标志值</td>    <td>含义</td>  </tr>  <tr>    <td>ACC_PUBLIC</td>    <td>0x0001</td>    <td>是否为public类型</td>  </tr>  <tr>    <td>ACC_FINAL</td>    <td>0x0010</td>    <td>是否被声明为final，只有类可设置</td>  </tr>  <tr>    <td>ACC_SUPER</td>    <td>0x0020</td>    <td>是否允许使用invokespecial字节码指令的新语义。jdk1.1之后该值必须为真</td>  </tr>  <tr>    <td>ACC_INTERFACE</td>    <td>0x0200</td>    <td>标识这是一个接口</td>  </tr>  <tr>    <td>ACC_ABSTRACT</td>    <td>0x0400</td>    <td>是否为abstract类型。接口和抽象类为真，其他为假</td>  </tr>  <tr>    <td>ACC_SYNTHETIC</td>    <td>0x1000</td>    <td>标识这个类并非由用户代码产生的</td>  </tr>  <tr>    <td>ACC_ANNOTATION</td>    <td>0x2000</td>    <td>标识这是一个注解</td>  </tr>  <tr>    <td>ACC_ENUM</td>    <td>0x4000</td>    <td>表示这是一个枚举</td>  </tr>  <tr>    <td>ACC_MODEULE</td>    <td>0x8000</td>    <td>标识这是一个模块</td>  </tr></table><p>&emsp;标志符占2字节，16位，但是目前只定义了9个，未使用到的标志位一律为0。再看前面说到的字节码常量池之后是<code>0x0021 = 0x0001|0x0020</code>，查上表可知public类型，可使用invokespecial指令。</p><p>   ACC_SUPDER：<a href="https://blog.csdn.net/dshf_1/article/details/105787923">https://blog.csdn.net/dshf_1/article/details/105787923</a> </p><h2 id="4-类索引、父类索引和接口索引集合"><a href="#4-类索引、父类索引和接口索引集合" class="headerlink" title="4 类索引、父类索引和接口索引集合"></a>4 类索引、父类索引和接口索引集合</h2><p>&emsp;访问标志之后接着是类索引（this_class）和父类索引（super_class），它们都是u2类型的数据，接口索引集合（interfaces）是一组u2类型的数据集合，<strong>Class文件中这三项确定该类型的继承关系</strong>。</p><ul><li>类索引：确定该类的全限定名。</li><li>父类索引：确定该类父类的全限定名。除了java.lang.Object之外，所有的类都有父类（java只能继承一个父类，因此父类索引只有一个，而接口可以实现多个，因此接口索引是个集合），因此除了Object，其他类的父类索引都不为0。</li><li>接口索引：描述该类实现的接口（implements之后的所有接口，顺序排列，如果是接口则是extends之后的接口），可以有多个，是接口集合。</li></ul><p>&emsp;this_class和super_class均指向CONSGANT_class_info的的类描述符常量，通过指向的CONSGANT_class_info类型的常量中的索引值，可以找到定义在CONSGANT_utf8_info类型常量中的全限定名字符串。</p><p>&emsp;还是上面那个例子，访问标志之后的4个字节为<code>0x0003</code>和<code>0x0004</code>，表示类索引和父类索引指向常量池中的<code>#3</code>和<code>#4</code>个常量，查常量池可以看到，他们确实是class类型的常量，<code>#3</code>又指向<code>#21</code>，<code>#21</code>为utf8类型常量，值为<code>com/hk7/memory/ClassTest</code>s。<code>#4</code>指向<code>#22</code>，<code>#22</code>为utf8常量，值为<code>java/lang/Object</code>。这与规定的一致。</p><p>&emsp;再之后是接口索引个数，值为<code>0x0001</code>，说明本类没有实现了1个接口，接口索引个数之后紧接着接口的引用<code>0x0005</code>，查常量表#5指向#23，#23为utf8的字符串java/io/Serializable，说明它实现了java/io/Serializable接口，和源码一致。</p><h2 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5 字段表集合"></a>5 字段表集合</h2><p>&emsp;接口索引之后是字段表（field_info）信息，它描述类或者接口声明的变量，描述作用域（public、private）、变量类型（static静态变量、实例变量）、可变性（final）、并发可见性（volatile）、序列化（transient）、字段数据类型（基本类型、对象、数据）等信息。修饰符等可以用标志位来表示，而字段名、字段类型等无法固定，只能指针指向常量池中的常量来表示。具体的字段表结构如下：</p><table>   <tr>      <td>名称</td>      <td>类型</td>      <td>说明</td>      <td>数量</td>      <td>具体</td>   </tr>   <tr>      <td>access_flags</td>      <td>u2</td>      <td>类或接口的的某些修饰符</td>      <td>1</td>      <td><img src="http://moguhu.com/images/DBF985CE-1743-4BBF-B1FD-9029972F7B2C.png" width="100%" height="100%" /></td>   </tr>   <tr>      <td>name_index</td>      <td>u2</td>      <td>字段的简单名称</td>      <td>1</td>      <td></td>   </tr>   <tr>      <td>descriptor_index</td>      <td>u2</td>      <td>字段描述符</td>      <td>1</td>      <td><img src="https://img-blog.csdnimg.cn/20201015185855914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" width="100%" height="100%" /></td>   </tr>   <tr>      <td>attributes_count</td>      <td>u2</td>      <td>字段属性个数</td>      <td>1</td>      <td></td>   </tr>   <tr>      <td>attributes</td>      <td>attributes_info</td>      <td>字段属性集合</td>      <td>attributes_count</td>      <td>具体看1.7属性表集合</td>   </tr></table><p>&emsp;由于java语法限制，<strong>访问标志</strong>必须满足以下规则：</p><ul><li>ACC_PUBLIC、ACC_PRIVATE和ACC_PROTECTED只能三选一</li><li>ACC_FINAL和ACC_VOLATILE只能二选一</li><li>ACC_PUBLIC、ACC_STATIC、ACC_FINAL必须有</li></ul><p>&emsp;字段或方法的<strong>简单名称</strong>是指去掉类型和参数修饰的名字，比如例子中没有字段，只有方法main()方法的简单名称就是main。</p><p>&emsp;字段或者方法的<strong>描述符</strong>是用来描述字段的数据类型、方法参数列表和返回值的，上图可以看到描述符和类型的对应关系。数组类型，每个维度都会有一个前置的<code>[</code>来描述，比如<code>java.lang.String[][]</code>类型的二维数组被描述为<code>[[Ljava/lang/String;</code>，再比如一个整型数组<code>int[]</code>会描述为<code>[I</code>。</p><p>&emsp;字段的<strong>属性</strong>是指final、static等修饰符。后面1.7会具体讲解。</p><p>&emsp;再继续看上面的例子，接口描述之后是字段长度位，可以看到值为<code>0x0001</code>=1，说明方法只有1个变量。后面跟着变量的具体描述，access_flags<code>0x0002</code>表示private修饰；name_index<code>0x0006</code>表示指向常量池#6，查常量表看到#6为utf8的字符串num；<code>descriptor_index</code>0x0007表示指向常量池#7，查常量表可知#7是utf8的I，上图看到了，I是int的描述符，再后面是字段属性个数 <code>0x0000</code>=0，代表没有属性修饰。因此我们推断这一段代码为<code>private int m;</code>。</p><h2 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6 方法表集合"></a>6 方法表集合</h2><p>&emsp;字节码文件中，方法表的结构和上述字段表一致，依次是访问标志（access_flag）、名称索引（name_index）、描述符索引（descriptor_index）和属性表集合。区别在于访问标志选项有差别，volatile和transient无法修饰方法，方法表中没有相应标志，多了synchronized、native、strictfp和abstract相关标志，具体结构如下：</p><table>   <tr>      <td>名称</td>      <td>类型</td>      <td>说明</td>      <td>数量</td>      <td>具体</td>   </tr>   <tr>      <td>access_flags</td>      <td>u2</td>      <td>方法的修饰符</td>      <td>1</td>      <td><img src="http://moguhu.com/images/5CA68567-403F-491A-AD03-168800C5C90D.png" width="100%" height="100%" /></td>   </tr>   <tr>      <td>name_index</td>      <td>u2</td>      <td>方法名称</td>      <td>1</td>      <td></td>   </tr>   <tr>      <td>descriptor_index</td>      <td>u2</td>      <td>方法描述符</td>      <td>1</td>      <td><img src="https://img-blog.csdnimg.cn/20201015185855914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" width="100%" height="100%" /></td>   </tr>   <tr>      <td>attributes_count</td>      <td>u2</td>      <td>方法属性个数</td>      <td>1</td>      <td></td>   </tr>   <tr>      <td>attributes</td>      <td>attributes_info</td>      <td>方法属性集合</td>      <td>attributes_count</td>      <td>具体看1.7属性表集合</td>   </tr></table><p>&emsp;继续分析例子，attributes_count之后是方法个数<code>0x0002</code>表示有2个方法。</p><ul><li>method1：access_flag<code>0x0001</code>=1表示public方法。name_index<code>0x0008</code>指向常量池#8，#8是utf8常量<code>&lt;init&gt;</code>，descriptor_index<code>0x0009</code>指向常量池#9，#9是utf8<code>()V</code>。再后面attributes_count<code>0x0001</code>表示init方法有1个属性修饰，后面是具体的属性结构<code>0x0001</code>=10，查常量池#10位utf8的<code>Code</code>，code里面存储的是方法里面具体的代码。这部分东西很多，具体请看1.7 属性表集合。通过上述我们推断方法1部分源码为<code>public void init()</code>。</li><li>method2：ccess_flag<code>0x0001</code>=1表示public方法。name_index<code>0x000F</code>指向常量池#15，#15是utf8常量<code>add</code>，descriptor_index<code>0x0010</code>指向常量池#16，#16是utf8<code>()I</code>。再后面attributes_count<code>0x0001</code>表示init方法有1个属性修饰，后面是具体的属性结构<code>0x000A</code>=10，查常量池#10位utf8的<code>Code</code>，code里面存储的是方法里面具体的代码。通过上述我们推断方法2部分源码为<code>public int add()</code>。与源码一致。【可使用010editor的class模板打开class文件查看具体字节码】</li></ul><h2 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7 属性表集合"></a>7 属性表集合</h2><p>&emsp;属性表在class文件、字段表和方法表中都会出现，用来描述专有的信息。《java虚拟机规范》对属性表没有像字段表、方法表那样严格限制顺序，只要不和已有属性名重复，都可以编译器都可以写入自己定义的属性信息，java虚拟机运行时会忽略掉它不认识的属性。</p><p>&emsp;属性的名称必须从常量池中引用uft8常量来表示，但是属性值的结构则不用，用长度说明属性值所占的位数即可。属性值的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">attribute_info &#123;<br>    u2 attribute_name_index;       # 属性名称<br>    u4 attribute_length;           # 属性表长度<br>    u1 info[attribute_length];     # 属性表具体内容<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;java虚拟机预定义的属性如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ruby">属性名                                      含义                                                                                     使用位置<br>ConstantValue                         <span class="hljs-params">||</span> 由final关键字定义的常量值                                                                  <span class="hljs-params">||</span>   字段表<br>Code                                  <span class="hljs-params">||</span> java代码编译成的字节码指令                                                                  <span class="hljs-params">||</span>  方法表<br>StackMapTable                         <span class="hljs-params">||</span> jdk6新增属性，验证局部变量和操作数栈类型是否匹配                                               <span class="hljs-params">||</span>  Code属性<br>Exceptions                            <span class="hljs-params">||</span> 方法抛出的异常列表                                                                         <span class="hljs-params">||</span>  方法表<br>InnerClasses                          <span class="hljs-params">||</span> 内部类列表                                                                                <span class="hljs-params">||</span>  类文件<br>EnclosingMethod                       <span class="hljs-params">||</span> 只有局部类和匿名类才拥有该属性，标志这个类所在的外围方法                                         <span class="hljs-params">||</span>  类文件<br>Synthetic                             <span class="hljs-params">||</span> 标识方法或字段为编译器自动生成的                                                             <span class="hljs-params">||</span>  类、方法表、字段表<br>Signature                             <span class="hljs-params">||</span> jdk5新增属性，用于支持泛型的类、方法、字段的签名                                               <span class="hljs-params">||</span>   类、方法表、字段表<br>SourceFile                            <span class="hljs-params">||</span> 记录源文件名称                                                                             <span class="hljs-params">||</span>   类文件<br>SourceDebugExtension                  <span class="hljs-params">||</span> jdk5新增属性，存储额外的调试信息                                                             <span class="hljs-params">||</span>   类文件<br>LineNumberTable                       <span class="hljs-params">||</span> java源码行号与字节码指令的对应关系                                                           <span class="hljs-params">||</span>   Code属性<br>LocalVariableTable                    <span class="hljs-params">||</span> 方法的局部变量描述                                                                          <span class="hljs-params">||</span>  Code属性<br>LocalVariableTypeTable                <span class="hljs-params">||</span> jdk5新增属性，使用特征签名代替描述符，为支持泛型添加的属性                                       <span class="hljs-params">||</span>  类文件<br>Deprecated                            <span class="hljs-params">||</span> 被声明为deprecated的方法和字段                                                              <span class="hljs-params">||</span>  类、方法表、字段表<br>RuntimeVisibleAnnotations             <span class="hljs-params">||</span> jdk5新增属性，为动态注解提供支持                                                             <span class="hljs-params">||</span>  类、方法表、字段表<br>RuntimeInvisibleAnnotations           <span class="hljs-params">||</span> 同上相反                                                                                  <span class="hljs-params">||</span>   类、方法表、字段表<br>RuntimeVisibleParameterAnnotations    <span class="hljs-params">||</span> 类似于RuntimeVisibleAnnotations，作用于方法                                                 <span class="hljs-params">||</span>  方法表<br>RuntimeInvisibleParameterAnnotations  <span class="hljs-params">||</span> 同上相反                                                                                   <span class="hljs-params">||</span>  方法表<br>RuntimeVisibleTypeAnnotations         <span class="hljs-params">||</span> jdk8新增属性，用于指明哪些类是运行时（即反射调用）可见的                                         <span class="hljs-params">||</span>  类、方法表、字段表<br>RuntimeInvisibleTypeAnnotations       <span class="hljs-params">||</span> 同上相反                                                                                   <span class="hljs-params">||</span>  类、方法表、字段表<br>AnnotationDefault                     <span class="hljs-params">||</span> jdk5新增属性，用于记录注解类元素的默认值                                                       <span class="hljs-params">||</span>  方法表<br>BootstrapMethods                      <span class="hljs-params">||</span> jdk7新增属性，用于保存invokedynamic指令引用的引导方法限定符                                     <span class="hljs-params">||</span>  类文件<br>MethodParameters                      <span class="hljs-params">||</span> jdk8新增属性，编译时加上-parameters参数可以将方法名称编译进Class文件中，并可运行时获取             <span class="hljs-params">||</span>  方法表<br>Module                                <span class="hljs-params">||</span> jdk9新增属性，用于记录一个Module的名称以及相关信息（requires、exports、opens、uses、provides）   <span class="hljs-params">||</span>  类文件<br>ModulePackages                        <span class="hljs-params">||</span> jdk9新增属性，用于记录一个模块中所有被exports或者opens的包                                      <span class="hljs-params">||</span>  类文件<br>ModuleMainClass                       <span class="hljs-params">||</span> jdk9新增属性，用于指定一个模块的主类                                                           <span class="hljs-params">||</span>  类文件<br>NestHost                              <span class="hljs-params">||</span> jdk11新增属性，用于支持嵌套类的反射和访问控制的API，内部类通过该属性得知自己的宿主类                 <span class="hljs-params">||</span>  类文件<br>NestMembers                           <span class="hljs-params">||</span> jdk11新增属性，用于支持嵌套类的反射和访问控制的API，内部宿主类通过该属性得知自己有哪些内部类          <span class="hljs-params">||</span>  类文件<br></code></pre></td></tr></table></figure><h3 id="7-1-ConstantValue属性"><a href="#7-1-ConstantValue属性" class="headerlink" title="7.1 ConstantValue属性"></a>7.1 ConstantValue属性</h3><p>&emsp;ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static修饰的变量才能使用该属性。实例变量(int x = 123)和静态变量(static int x = 123)的赋值方式和时机不同。前者是在实例构造器<code>&lt;init()&gt;</code>中赋值的。而静态变量的赋值有2种方式：</p><ul><li>在类构造器<code>&lt;cinit()&gt;</code>中赋值</li><li>使用ConstantValue属性赋值</li></ul><p>&emsp;目前Oracle实现的javac编译器的实现方式是：如果变量同时使用final和static修饰（java语法上的常量）且类型为基本类型或者String类型，则使用ConstantValue属性赋值。否则会在<code>&lt;cinit()&gt;</code>中赋值。</p><p>&emsp;《java虚拟机规范》中没有强制要求final修饰的变量必须设置ACC_FINAL标志，只要求具有ConstantValue属性的字段必须设置ACC_STATIC标志。final关键字的要求是javac编译器自己加入的。</p><p>&emsp;ConstantValue的结构如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ConstantValue_attribute</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">attribute_name_index;</span><br>    <span class="hljs-attr">u4</span> <span class="hljs-string">attribute_length;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">constantvalue_index;     // 对常量池中字面量常量的引用。</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>&emsp;上述提到被final和static修饰的基本类型以及String类型的变量，才拥有ConstantValue属性，因此constantvalue_index指向的字面量常量只能是以下几种：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">CONSTANT_Integer(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">short</span>, <span class="hljs-keyword">char</span>, <span class="hljs-keyword">byte</span>, <span class="hljs-keyword">boolean</span>)<br>CONSTANT_Float（<span class="hljs-keyword">float</span>）<br>CONSTANT_Long（<span class="hljs-keyword">long</span>）<br>CONSTANT_Double（<span class="hljs-keyword">double</span>）<br>CONSTANT_String（<span class="hljs-keyword">String</span>）<br></code></pre></td></tr></table></figure><h3 id="7-2-Code属性"><a href="#7-2-Code属性" class="headerlink" title="7.2 Code属性"></a>7.2 Code属性</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Code_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 max_stack<span class="hljs-comment">;</span><br>    u2 max_locals<span class="hljs-comment">;</span><br>    u4 code_length<span class="hljs-comment">;</span><br>    u1 code[code_length]<span class="hljs-comment">;</span><br>    u2 exception_table_length<span class="hljs-comment">;</span><br>    &#123;   u2 start_pc<span class="hljs-comment">;</span><br>        u2 end_pc<span class="hljs-comment">;</span><br>        u2 handler_pc<span class="hljs-comment">;</span><br>        u2 catch_type<span class="hljs-comment">;</span><br>    &#125; exception_table[exception_table_length]<span class="hljs-comment">;</span><br>    u2 attributes_count<span class="hljs-comment">;</span><br>    attribute_info attributes[attributes_count]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;从上面Code属性结构可以看到如下信息</p><ul><li>attributes_name_index（u2）：指向CONSTANT_Utf8_info常量的索引，此常量值固定为“Code”，它代表该属性的名称</li><li>attributes_length（u4）：指示了属性值长度，属性值长度=整个属性表长度 - 6，6是attributes_name_index和attributes_length所占长度</li><li>max_stack（u2）：操作数栈的深度。方法执行的任意时刻，操作数栈都不会超过这个深度。jvm运行时候根据该值分配栈帧中操作数栈的深度。</li><li>max_locals（u2）：局部变量表所需要的存储空间。max_locals的单位是槽Slot，是虚拟机为局部变量分配内存的最小单位。具体可看<a href="https://happykite777.github.io/2020/09/29/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">jvm之内存管理</a>中的栈帧局部变量表部分。</li><li>code_length（u4）：code_length和code用来存储源码编译后生成的字节码指令。code_length代表字节码长度。理论上是u4长度，但是实际上只使用了u2长度。《规范》规定了一个方法不允许超过65535条字节码指令，超过javac编译器会拒绝编译。</li><li>code（u2）：存储用于虚拟机字节码指令的一系列字节流。每个字节码指令是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就知道这个字节码的含义，以及它的携带的参数和如何解析。u1类型取值范围为0x00~0xFF，即一共可以表达256条指令。目前《java虚拟机规范》定义了约200条编码值对应的指令含义。具体可查 <a href="https://www.cnblogs.com/magexi/p/11822910.html">虚拟机字节码指令表</a>。</li><li>exception_table_length（u2）：异常表长度</li><li>exception_table（exception_info）：异常表由4个项组成，分别是start_pc（u2）、end_pc（u2）、handler_pc（u2）和catch_type（u2）。</li><li>attributes_count（u2）：略</li><li>attributes（attributes_info）：字段属性表的具体内容详细见7.</li></ul><p>&emsp;Code属性是Class文件中最重要的属性，如果把java程序中的信息分为代码（Code，方法体中的代码）和元数据（类、字段、方法定义等），那么在整个class文件中，Code属性用于描述代码，其他所有数据都用于描述元数据。</p><p>&emsp;继续前面的例子分析。继续分析add()的Code部分，attribute_name_index<code>0x000A</code>=10表示指向常量池#10，查常量池得#10为<code>Code</code>，表示这是Code代码，后面进入具体的代码结构。紧接着attribute_length<code>0x00000031</code>=49表示代码长度为49。再后max_stack<code>0x0002</code>=2表示add方法操作数栈最大深度为2，再后面max_locals<code>0x0001</code>=1表示局部变量表所需存储空间为1个槽。再后面code_length<code>0x00000007</code>=7表示字节码长度为7，即7个指令。接下来具体的7个字节码指令和气代表的含义分别为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">0x2A</span>    aload_0       将第一个引用类型本地变量推送至栈顶，也就是加载num<br><span class="hljs-number">0xB4</span>    getfield      获取指定类的实例域，并将其值压入栈顶，将num入栈<br><span class="hljs-number">0x00</span>    nop           什么都不做<br><span class="hljs-number">0x02</span>    iconst_m1     将<span class="hljs-built_in">int</span>型<span class="hljs-number">-1</span>推送至栈顶，这是啥？num的默认值吗？<br><span class="hljs-number">0x04</span>    iconst_1      将<span class="hljs-built_in">int</span>型<span class="hljs-number">1</span>推送至栈顶<br><span class="hljs-number">0x60</span>    iadd          将栈顶两<span class="hljs-built_in">int</span>型数值相加并将结果压入栈顶，num+<span class="hljs-number">1</span><br><span class="hljs-number">0xAC</span>    ireturn       从当前方法返回<span class="hljs-built_in">int</span>，<span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>&emsp;在之后是关于异常表的信息exception_table_length<code>0x0000</code>表示没有异常。在之后是attributes_count<code>0x0002</code>表示属性长度为2，之后</p><p>&emsp;使用javap -v ClassTest.class反汇编，可以得到如下关于add的信息。args_size=1是this所占的Slot。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> add();<br>    descriptor: ()I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>         <span class="hljs-number">4</span>: iconst_1<br>         <span class="hljs-number">5</span>: iadd<br>         <span class="hljs-number">6</span>: ireturn<br>      LineNumberTable:<br>        line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/ClassTest;<br></code></pre></td></tr></table></figure><h3 id="7-3-StackMapTable属性"><a href="#7-3-StackMapTable属性" class="headerlink" title="7.3 StackMapTable属性"></a>7.3 StackMapTable属性</h3><p>&emsp;StackMapTable属性是jdk6新增的属性，它很复杂，位于Code属性的属性表中。它会在虚拟机类加载的字节码验证阶段被类型检查器（Type Checker）使用，其目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器（加快类加载的字节码验证阶段）。</p><p>&emsp;StackMapTable属性中包含零到多个栈映射帧（Stack Map Frame），每个栈帧代表一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。类型检查器会检查StackMapTable来确定一段字节码指令是否符合逻辑约束。StackMapTable的结构如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">StackMapTable_attribute</span> &#123;<br>    <span class="hljs-attribute">u2</span>              attribute_name_index;<br>    <span class="hljs-attribute">u4</span>              attribute_length;<br>    <span class="hljs-attribute">u2</span>              number_of_entries;<br>    <span class="hljs-attribute">stack_map_frame</span> entries[number_of_entries];<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;规定版本号&gt;=50.0的class文件，Code属性必须带有StackMapTable属性，如果没有则表示默认带了一个number_of_entries=0的StackMapTable属性。一个方法的Code属性只有一个StackMapTable属性，否则抛出异常。</p><p>&emsp;StackMapTable具体见栈帧的内部结构。</p><h3 id="7-4-Exceptions属性"><a href="#7-4-Exceptions属性" class="headerlink" title="7.4 Exceptions属性"></a>7.4 Exceptions属性</h3><p>&emsp;Exceptions属性和Code属性平级，不同于Code属性中的异常表。Exceptions的作用主要是列举方法中可能抛出的受检异常（Checked Exceptions），也就是throws后面的异常。它的结构如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Exceptions_attribute</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">attribute_name_index;</span><br>    <span class="hljs-attr">u4</span> <span class="hljs-string">attribute_length;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">number_of_exceptions;//受检异常数量</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">exception_index_table[number_of_exceptions];   //指向常量池中CONSTANT_Class_info型的索引，代表该异常类型</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7-5-InnerClass属性"><a href="#7-5-InnerClass属性" class="headerlink" title="7.5 InnerClass属性"></a>7.5 InnerClass属性</h3><p>&emsp;InnerClass属性用于记录内部类和宿主类之间的关联。它的结构如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">InnerClasses_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 number_of_classes<span class="hljs-comment">; //需要记录的内部类信息个数</span><br>&#123;   u2 inner_class_info_index<span class="hljs-comment">;     //指向常量池中的CONSTANT_Class_info型索引</span><br>        u2 outer_class_info_index<span class="hljs-comment">;     //指向常量池中的CONSTANT_Class_info型索引</span><br>        u2 inner_name_index<span class="hljs-comment">; //指向常量池中的CONSTANT_Utf8_info型索引</span><br>        u2 inner_class_access_flags<span class="hljs-comment">;</span><br>    &#125; classes[number_of_classes]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;inner_class_access_flags是内部类的访问标志，取值范围如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Flag</span> NameValueInterpretation<br><span class="hljs-attribute">ACC_PUBLIC</span><span class="hljs-number">0</span>x<span class="hljs-number">0001</span>内部类是否为public<br><span class="hljs-attribute">ACC_PRIVATE</span><span class="hljs-number">0</span>x<span class="hljs-number">0002</span>private<br><span class="hljs-attribute">ACC_PROTECTED</span><span class="hljs-number">0</span>x<span class="hljs-number">0004</span>protected<br><span class="hljs-attribute">ACC_STATIC</span><span class="hljs-number">0</span>x<span class="hljs-number">0008</span>static<br><span class="hljs-attribute">ACC_FINAL</span><span class="hljs-number">0</span>x<span class="hljs-number">0010</span>final<br><span class="hljs-attribute">ACC_INTERFACE</span><span class="hljs-number">0</span>x<span class="hljs-number">0200</span>接口<br><span class="hljs-attribute">ACC_ABSTRACT</span><span class="hljs-number">0</span>x<span class="hljs-number">0400</span>abstract<br><span class="hljs-attribute">ACC_SYNTHETIC</span><span class="hljs-number">0</span>x<span class="hljs-number">1000</span>内部类是否自动生成（非用户代码生成）<br><span class="hljs-attribute">ACC_ANNOTATION</span><span class="hljs-number">0</span>x<span class="hljs-number">2000</span>注解<br><span class="hljs-attribute">ACC_ENUM</span><span class="hljs-number">0</span>x<span class="hljs-number">4000</span>枚举<br></code></pre></td></tr></table></figure><h3 id="7-6-EnclosingMethod属性"><a href="#7-6-EnclosingMethod属性" class="headerlink" title="7.6 EnclosingMethod属性"></a>7.6 EnclosingMethod属性</h3><p>&emsp;EnclosingMethod属性标识当前匿名内所在的外部方法。结构如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">EnclosingMethod_attribute</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">attribute_name_index;</span><br>    <span class="hljs-attr">u4</span> <span class="hljs-string">attribute_length;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">class_index;//指向常量池中的CONSTANT_Class_info型索引</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">method_index;//指向常量池中的CONSTANT_NameAndType_info型索引</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;如果不是内部类，则method_index必须为0。</p><h3 id="7-7-Synthetic和Deprecated属性"><a href="#7-7-Synthetic和Deprecated属性" class="headerlink" title="7.7 Synthetic和Deprecated属性"></a>7.7 Synthetic和Deprecated属性</h3><p>&emsp;Synthetic标识方法或字段为编译器自动生成（即不是源码定义的）的。Deprecated标志方法是否过时，只有是和否，没有值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Synthetic_attribute &#123;<br>    u2 attribute_name_index;   <span class="hljs-regexp">//</span>指向常量池中的CONSTANT_Utf8_info型索引<br>    u4 attribute_length; <span class="hljs-regexp">//</span>值固定为：<span class="hljs-number">0</span>x00000000<br>&#125;<br>Deprecated同上<br></code></pre></td></tr></table></figure><h3 id="7-8-Signature"><a href="#7-8-Signature" class="headerlink" title="7.8 Signature"></a>7.8 Signature</h3><p>&emsp;<strong>由于Java的泛型采用擦出法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息。</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">Signature_attribute</span> &#123;<br>    <span class="hljs-attribute">u2</span> attribute_name_index;<br>    <span class="hljs-attribute">u4</span> attribute_length;<br>    <span class="hljs-attribute">u2</span> signature_index;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-9-SourceFile和SourceDebugExtension属性"><a href="#7-9-SourceFile和SourceDebugExtension属性" class="headerlink" title="7.9 SourceFile和SourceDebugExtension属性"></a>7.9 SourceFile和SourceDebugExtension属性</h3><p>&emsp;SourceFile记录生成这个class文件的源码文件名称。SourceDebugExtension存储额外的代码调试信息。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">SourceFile_attribute</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">attribute_name_index;</span><br>    <span class="hljs-attr">u4</span> <span class="hljs-string">attribute_length;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">sourcefile_index;    //CONSTANT_Utf8_info</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">SourceDebugExtension_attribute</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">u2</span> <span class="hljs-string">attribute_name_index;</span><br>    <span class="hljs-attr">u4</span> <span class="hljs-string">attribute_length;</span><br>    <span class="hljs-attr">u1</span> <span class="hljs-string">debug_extension[attribute_length];</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7-10-LineNumberTable属性"><a href="#7-10-LineNumberTable属性" class="headerlink" title="7.10 LineNumberTable属性"></a>7.10 LineNumberTable属性</h3><p>&emsp;描述java源码行号和字节码行号之间的对应关系。非运行必须属性，可以使用<code>javc -g: none XXX.java</code>或者<code>javac -g: lines XXX.java</code>来取消，这样生成的class文件不含LineNumberTable属性，报错时也不会显示行号信息。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">LineNumberTable_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 line_number_table_length<span class="hljs-comment">;</span><br>    &#123;   u2 start_pc<span class="hljs-comment">;//字节码行号</span><br>        u2 line_number<span class="hljs-comment">;      //源码行号</span><br>    &#125; line_number_table[line_number_table_length]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-11-LocalVariableTable和LocalVariableTypeTable属性"><a href="#7-11-LocalVariableTable和LocalVariableTypeTable属性" class="headerlink" title="7.11 LocalVariableTable和LocalVariableTypeTable属性"></a>7.11 LocalVariableTable和LocalVariableTypeTable属性</h3><p>&emsp;LocalVariableTable用于描述栈帧中局部变量表的变量与java源码中定义的变量之间的关系，不是运行时必须属性。编译时使用<code>javac -g: none XXX.java</code>或者<code>javac -g: vars XXX.java</code>来忽略，这样会导致所有的参数名称丢失，IDE会使用args0、args1来代替原有参数名。不影响程序运行。其结构如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs abnf">LocalVariableTable_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 local_variable_table_length<span class="hljs-comment">;</span><br>    &#123;   u2 start_pc<span class="hljs-comment">;//局部变量生命周期开始的字节码偏移量</span><br>        u2 length<span class="hljs-comment">;                //局部变量生命周期开始范围长度</span><br>        u2 name_index<span class="hljs-comment">;  //局部变量名称，指向CONSTANT_Utf8_info</span><br>        u2 descriptor_index<span class="hljs-comment">;      //局部变量描述符</span><br>        u2 index<span class="hljs-comment">;//局部变量在栈帧的局部变量表中变量槽的位置</span><br>    &#125; local_variable_table[local_variable_table_length]<span class="hljs-comment">;</span><br>&#125;<br><br>LocalVariableTypeTable_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 local_variable_type_table_length<span class="hljs-comment">;</span><br>    &#123;   u2 start_pc<span class="hljs-comment">;</span><br>        u2 length<span class="hljs-comment">;</span><br>        u2 name_index<span class="hljs-comment">;</span><br>        u2 signature_index<span class="hljs-comment">;   //记录泛型</span><br>        u2 index<span class="hljs-comment">;</span><br>    &#125; local_variable_type_table[local_variable_type_table_length]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;LocalVariableTypeTable是jdk5引入的，作用同LocalVariableTable，记录泛型。</p><h3 id="7-12运行时注解相关属性"><a href="#7-12运行时注解相关属性" class="headerlink" title="7.12运行时注解相关属性"></a>7.12运行时注解相关属性</h3><p>&emsp;JDK5引入了注解，Class文件也增加注解相关的属性。RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、RuntimeVisibleParameterAnnotations、RuntimeInvisibleParameterAnnotations、RuntimeVisibleTypeAnnotations、RuntimeInvisibleTypeAnnotations这6个注解功能类似。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs crystal">RuntimeVisibleAnnotations_attribute &#123;<br>    u2         attribute_name_index;<br>    u4         attribute_length;<br>    u2         num_annotations;<br>    <span class="hljs-keyword">annotation</span> <span class="hljs-title">annotations</span>[<span class="hljs-title">num_annotations</span>];<br>&#125;<br><br><span class="hljs-keyword">annotation</span> &#123;<br>    u2 type_index;<span class="hljs-regexp">//</span> 指向CONSTAN_Utf8_info的索引，描述注解的字段描述符<br>    u2 num_element_value_pairs;<span class="hljs-regexp">//</span> 注解数量<br>    &#123;   u2            element_name_index;<span class="hljs-regexp">//</span> 该注解的参数<br>        element_value value;                        <span class="hljs-regexp">//</span> 该注解的值<br>    &#125; element_value_pairs[num_element_value_pairs];<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;RuntimeVisibleAnnotations记录了类、字段或方法运行时的可见注解，当反射获取注解时，就是通过这个属性获取到的。其他5种注解的结构和它一致，功能类似。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><br>RuntimeInvisibleAnnotations_attribute &#123;<br>    u2         attribute_name_index;<br>    u4         attribute_length;<br>    u2         num_annotations;<br>    <span class="hljs-keyword">annotation</span> <span class="hljs-title">annotations</span>[<span class="hljs-title">num_annotations</span>];<br>&#125;<br><br>RuntimeVisibleParameterAnnotations_attribute &#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u1 num_parameters;<br>    &#123;   u2         num_annotations;<br>        <span class="hljs-keyword">annotation</span> <span class="hljs-title">annotations</span>[<span class="hljs-title">num_annotations</span>];<br>    &#125; parameter_annotations[num_parameters];<br>&#125;<br><br>RuntimeInvisibleParameterAnnotations_attribute &#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u1 num_parameters;<br>    &#123;   u2         num_annotations;<br>        <span class="hljs-keyword">annotation</span> <span class="hljs-title">annotations</span>[<span class="hljs-title">num_annotations</span>];<br>    &#125; parameter_annotations[num_parameters];<br>&#125;<br><br>RuntimeVisibleTypeAnnotations_attribute &#123;<br>    u2              attribute_name_index;<br>    u4              attribute_length;<br>    u2              num_annotations;<br>    type_annotation annotations[num_annotations];<br>&#125;<br><br>RuntimeInvisibleTypeAnnotations_attribute &#123;<br>    u2              attribute_name_index;<br>    u4              attribute_length;<br>    u2              num_annotations;<br>    type_annotation annotations[num_annotations];<br>&#125;<br><br>AnnotationDefault_attribute &#123;<br>    u2            attribute_name_index;<br>    u4            attribute_length;<br>    element_value default_value;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;AnnotationDefault记录注解中的默认值，也就是value参数。</p><h3 id="7-13BootstrapMethods属性"><a href="#7-13BootstrapMethods属性" class="headerlink" title="7.13BootstrapMethods属性"></a>7.13BootstrapMethods属性</h3><p>&emsp;JDK7新增属性，用于保存invokeddynamic指令引用的引导方法限定类。如果类文件结构的常量池中出现过CONSTANT_InvokeDynamic_info常量，则类文件必须存在BoostrapMethod属性，最多一个。结构如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">BootstrapMethods_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br>    u2 num_bootstrap_methods<span class="hljs-comment">;</span><br>    &#123;   u2 bootstrap_method_ref<span class="hljs-comment">;//指向CONSTANT_MethodHandle_info类型常量</span><br>        u2 num_bootstrap_arguments<span class="hljs-comment">;                     </span><br>        u2 bootstrap_arguments[num_bootstrap_arguments]<span class="hljs-comment">;//有点类似链表，一个接一个</span><br>    &#125; bootstrap_methods[num_bootstrap_methods]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-14模块相关属性"><a href="#7-14模块相关属性" class="headerlink" title="7.14模块相关属性"></a>7.14模块相关属性</h3><p>&emsp;主要是是为了支持JDK9引入的模块系统，用得少不看了，详情查看官网。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Module_attribute &#123;<br>    u2 attribute_name_index<span class="hljs-comment">;</span><br>    u4 attribute_length<span class="hljs-comment">;</span><br><br>    u2 module_name_index<span class="hljs-comment">;</span><br>    u2 module_flags<span class="hljs-comment">;</span><br>    u2 module_version_index<span class="hljs-comment">;</span><br><br>    u2 requires_count<span class="hljs-comment">;</span><br>    &#123;   u2 requires_index<span class="hljs-comment">;</span><br>        u2 requires_flags<span class="hljs-comment">;</span><br>        u2 requires_version_index<span class="hljs-comment">;</span><br>    &#125; requires[requires_count]<span class="hljs-comment">;</span><br><br>    u2 exports_count<span class="hljs-comment">;</span><br>    &#123;   u2 exports_index<span class="hljs-comment">;</span><br>        u2 exports_flags<span class="hljs-comment">;</span><br>        u2 exports_to_count<span class="hljs-comment">;</span><br>        u2 exports_to_index[exports_to_count]<span class="hljs-comment">;</span><br>    &#125; exports[exports_count]<span class="hljs-comment">;</span><br><br>    u2 opens_count<span class="hljs-comment">;</span><br>    &#123;   u2 opens_index<span class="hljs-comment">;</span><br>        u2 opens_flags<span class="hljs-comment">;</span><br>        u2 opens_to_count<span class="hljs-comment">;</span><br>        u2 opens_to_index[opens_to_count]<span class="hljs-comment">;</span><br>    &#125; opens[opens_count]<span class="hljs-comment">;</span><br><br>    u2 uses_count<span class="hljs-comment">;</span><br>    u2 uses_index[uses_count]<span class="hljs-comment">;</span><br><br>    u2 provides_count<span class="hljs-comment">;</span><br>    &#123;   u2 provides_index<span class="hljs-comment">;</span><br>        u2 provides_with_count<span class="hljs-comment">;</span><br>        u2 provides_with_index[provides_with_count]<span class="hljs-comment">;</span><br>    &#125; provides[provides_count]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM之内存管理</title>
    <link href="/2020/10/10/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2020/10/10/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>&emsp;java中内存的管理是由JVM负责的，程序员new了一个对象后无需处理对象的释放删除等工作，较C/C++来说，开发轻松了不少。但是JVM不是万能的，一旦内存出现泄漏等问题，程序员需要排查原因，所以有必要好好理解JVM的内存管理机制。</p><p>1.2 jvm线程</p><p><strong>jvm线程</strong></p><ul><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li>在Hotspot JVM里，<strong>每个线程都与操作系统的本地线程直接映射</strong></li><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li><li>如果一个线程抛异常，并且该线程是进程中最后一个守护线程，那么进程将停止</li></ul><p><strong>jvm系统线程</strong><br>又叫后台线程，它不包括调用public static void main(String [])的main线程以及所有这个main线程自己创建的线程。</p><p>后台线程在HotSpot中主要有以下几个：</p><ul><li>虚拟机线程：jvm达到安全点时出现的线程（安全点是和垃圾回收相关的一个概念，后续会讲到）。</li><li>周期任务线程：用于周期性操作的调度执行</li><li>GC线程：专门负责垃圾回收</li><li>编译线程：运行时会将字节码编译成到本地代码</li><li>信号调度线程：接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ul><h2 id="1-jvm的内存布局"><a href="#1-jvm的内存布局" class="headerlink" title="1. jvm的内存布局"></a>1. jvm的内存布局</h2><p>&emsp;jvm内存布局又叫做运行时数据区域，主要是Java虚拟机在运行时，对不同部分的内存划分。<br>&emsp;jvm定义了在程序执行期间使用的各种运行时数据区域。其中一些数据区域是在Java虚拟机启动时创建的，只有在Java虚拟机退出时才会被销毁。其他数据区域是每个线程的。每线程数据区域在创建线程时创建，在线程退出时销毁。主要分为程序计数器、虚拟机栈、堆、方法区和运行常量池。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MTExNjQwNTExLnBuZw?x-oss-process=image/format,png" alt="HotSpot架构"><br>&emsp;每个JVM只有一个Runtime实例，即为运行时环境，也就是上图中间蓝色的框框。<br>&emsp;不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，本文主要探讨经经典的JVM（HotSpot）内存布局。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MTEyNDE2MTAxLnBuZw?x-oss-process=image/format,png" alt="java详细内存模型"><br>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：程序计数器、虚拟机栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MTEyNjAxMjExLnBuZw?x-oss-process=image/format,png" alt="java内存模型"></li></ul><h3 id="1-1-程序计数器（pc寄存器）"><a href="#1-1-程序计数器（pc寄存器）" class="headerlink" title="1.1 程序计数器（pc寄存器）"></a>1.1 程序计数器（pc寄存器）</h3><p>&emsp;程序计数器是一块很小的内存区域，可以看作是当前线程所执行字节码的行号指示器。<br>&emsp;pc寄存器用来<strong>存储指向下一条指令的地址</strong>，也就是即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。程序的控制流，分支、循环、异常跳出等都是通过改变这个计数器来实现的。</p><p style="color: red">&emsp;<b>java虚拟机支持多线程，cpu在不同的线程之间切换，在每个线程中指令是顺序执行的，某个确定的时刻，只会执行一条指令，因此为了保证多线程里面，指令执行的正确性，程序计数器必须是独立的，因此这块区域被称为“线程私有”内存</b></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MTU1NzI4NTU3LnBuZw?x-oss-process=image/format,png" alt="pc寄存器作用"><br>&emsp;上图栈帧其实对应一个方法，方法1中调用2方法，方法2再调用……一直到调用n方法，调用就压入栈，红色区域是指当前方法。方法里面具体的指令都有行号标识，pc寄存器就相当于行号标识，记录了下一条要执行的指令的地址。</p><p>&emsp;如果程序正在执行的是一个java方法，则计数器的值为虚拟机字节码指令的地址。如果正在执行的是本地方法，则计数器的值为空。<strong>此区域是唯一一个不会发生OOM的内存区域</strong>。</p><p><strong>举例</strong><br><img src="https://img-blog.csdnimg.cn/20201012154521652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="image"><br>&emsp;使用<code>javap -v xxx.class</code>得到反编译代码，如上图所示，左边的行号即为指令地址（或者偏移地址），右边的为jvm操作指令，pc寄存器存储的是下一条要执行的指令地址（5），执行引擎会取得该地址，操作对应的局部变量表、操作数栈等，然后把jvm指令翻译成机器指令，供cpu执行。</p><h3 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h3><p>以前叫java栈，是java虚拟机内存中的一块区域。</p><h4 id="栈概述"><a href="#栈概述" class="headerlink" title="栈概述"></a>栈概述</h4><p>&emsp;栈是运行时的单位，堆是存储的单位。</p><ul><li>栈解决程序的运行问题，即程序如何执行，如何处理数据.</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里.</li></ul><p><strong>栈的运行原理：</strong><br>&emsp;<strong>虚拟机栈存储的是java方法相关的数据和操作</strong>。线程被创建时，虚拟机会同步创建一个虚拟机栈，其<strong>内部保存的是一个个的栈帧</strong>，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>&emsp;方法的调用代表一个栈帧入栈，方法调用结束代表栈帧出栈，<strong>方法从开始调用到执行完毕，对应着入栈到出栈的过程</strong>。如下图，执行引擎执行methodA时，methodA的栈帧入栈，然后调用methodB，methodB栈帧入栈（简画，实际栈帧存储的东西不止局部变量）。<strong>栈顶的栈帧代表的是当前栈帧，栈帧对应的方法叫当前方法，方法对应的类叫当前类</strong>。<br><img src="https://img-blog.csdnimg.cn/20201012161928311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="java虚拟机栈"></p><p>&emsp;不同线程中所包含的栈帧是不允许存在相互引用的，即一个栈帧之中不可以引用另外一个线程的栈帧。</p><p>&emsp;java方法有两种返回函数的方式，但不管使用哪种方式，都会导致栈帧被弹出</p><ul><li>正常的函数返回，使用return指令。</li><li>抛出异常。如果当前方法A发生了异常但是没有捕获，则当前栈帧会被弹出，如果调用A的方法B的栈帧也没有捕获异常，则B栈帧被弹出，继续往外层执行，假设直至main方法均没有捕获异常，则程序会报错中断。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MjAzMTQyNTQ1LnBuZw?x-oss-process=image/format,png" alt="方法的调用"></li></ul><p>&emsp;java虚拟机栈属于线程私有内存，生命周期和线程相同。</p><p><strong>虚拟机栈作用：</strong></p><blockquote><p>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</p></blockquote><p><strong>虚拟机栈优点：</strong></p><blockquote><p>1、快速有效的内存分配方式，访问速度仅次于程序计数器。<br>2、jvm对栈的操作简单：入栈和出栈。<br>3、不存在垃圾回收的问题（GC、OOM，但会发生栈溢出）。</p></blockquote><p>&emsp;java虚拟机规范对这块内存区域定义了2种异常：</p><ul><li><ul><li>如果线程申请的栈深度大于虚拟机允许的深度，抛出StackOverflowError栈溢出异常。</li></ul></li><li><ul><li>如果栈可以动态扩展，扩展时无法申请到足够的内存，则抛出OutOfMemoryError内存溢出异常。</li></ul></li></ul><p>&emsp;使用<code>-Xss</code>来设置线程的最大栈空间，栈的大小决定了函数可达的最大深度。</p><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>&emsp;每个栈帧的内部存储这以下数据：</p><ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MjA1NDQzOTkzLnBuZw?x-oss-process=image/format,png" alt="栈帧的内部结构"><br>&emsp;栈帧的大小取决于内部结构的大小。<strong>在编译java源程序的时候，栈帧中需要多大的局部变量表、需要多深的操作数栈都已经被计算出来，并且写入到了方法表的Code属性中。</strong></li></ul><blockquote><ol><li>局部变量表</li></ol></blockquote><ul><li>局部变量表又被称之为局部变量数组或本地变量表。</li><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型(8种)、对象引用（reference），以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>方法调用结束，方法栈帧出栈，局部变量表也会销毁。</li></ul><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalVariablesTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>#14    public static void main(String[] args) &#123;<br>#15        LocalVariablesTest test = new LocalVariablesTest();<br>#16        int num = 10;<br>#17//        test.test1();<br>#18    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;执行反汇编<code>javap -v LocalVariablesTest.class</code>得到字节码指令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(java.lang.String[]);<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: new           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// class com/hk7/memory/LocalVariablesTest</span><br>       <span class="hljs-number">3</span>: dup<br>       <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">7</span>: astore_1<br>       <span class="hljs-number">8</span>: bipush        <span class="hljs-number">10</span><br>      <span class="hljs-number">10</span>: istore_2<br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    LineNumberTable:<br>      line <span class="hljs-number">15</span>: <span class="hljs-number">0</span><br>      line <span class="hljs-number">16</span>: <span class="hljs-number">8</span><br>      line <span class="hljs-number">18</span>: <span class="hljs-number">11</span><br>    LocalVariableTable:<br>      Start  Length  Slot  Name   Signature<br>          <span class="hljs-number">0</span>      <span class="hljs-number">12</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>          <span class="hljs-number">8</span>       <span class="hljs-number">4</span>     <span class="hljs-number">1</span>  test   Lcom/hk7/memory/LocalVariablesTest;<br>         <span class="hljs-number">11</span>       <span class="hljs-number">1</span>     <span class="hljs-number">2</span>   num   I<br></code></pre></td></tr></table></figure><p>&emsp;由上可知，<code>locals=3</code>代表局部变量表大小为3，分别为args参数、test对象和num变量。代码指令一共12行，<strong>LineNumberTable</strong>表示pc指令地址和源码所在行的对应关系。<strong>LocalVariableTable</strong>局部变量表，<em>start</em>表示当前变量的作用域，变量都是定义之后生效，比如test的start是8，从LineNumberTable表可知，8对应line16，也就是从16行开始test变量生效。<em>length</em>表示变量作用域的长度，从表中可看到三个变量起始位置+长度=12，因此所有变量作用域的结束都是方法的}。<br><br></p><p><strong>关于Slot的理解</strong></p><ul><li>1、参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>2、<strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种）、引用类型、returnAddress类型的变量。</li><li>3、在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型占用两个slot（1ong和double）。byte、short、char和boolean在存储前都会被转化成int。</li><li>4、JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。占两个slot的变量使用起始索引访问。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MjEyNDU0NDQ1LnBuZw?x-oss-process=image/format,png" alt="变量槽的索引访问"></li><li>5、当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制到局部变量表中的每一个slot上</strong>。</li><li>6、<strong>如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列</strong>。如下图jclasslib插件中可以看到字节码文件信息，test2位实例方法，它的this占了index=0的插槽。由于静态方法中栈帧局部变量表没有存储this变量，因此静态方法中无法使用<code>this.xxx</code>。<br><img src="https://img-blog.csdnimg.cn/20201012182107466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="this变量存储"></li></ul><p><strong>Slot的重复利用</strong><br>局部变量槽是可以重复利用的，如果一个局部变量过了其作用域被销毁了，则下一个局部变量可以利用这个局部变量槽。比如以下代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> test4() &#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//b出了作用域，变量b被销毁，但是数组已经分配，因此c可以利用这个slot</span><br>    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>    <span class="hljs-built_in">int</span> c = a + <span class="hljs-number">1</span>;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> test4();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: istore_1<br>         <span class="hljs-number">2</span>: iconst_0<br>         <span class="hljs-number">3</span>: istore_2<br>         <span class="hljs-number">4</span>: iload_1<br>         <span class="hljs-number">5</span>: iconst_1<br>         <span class="hljs-number">6</span>: iadd<br>         <span class="hljs-number">7</span>: istore_2<br>         <span class="hljs-number">8</span>: iload_1<br>         <span class="hljs-number">9</span>: iconst_1<br>        <span class="hljs-number">10</span>: iadd<br>        <span class="hljs-number">11</span>: istore_2<br>        <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">36</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">38</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">39</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">43</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">44</span>: <span class="hljs-number">12</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">4</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>     b   I<br>            <span class="hljs-number">0</span>      <span class="hljs-number">13</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/LocalVariablesTest;<br>            <span class="hljs-number">2</span>      <span class="hljs-number">11</span>     <span class="hljs-number">1</span>     a   I<br>           <span class="hljs-number">12</span>       <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     c   I<br></code></pre></td></tr></table></figure><p><font color=green>&emsp;局部变量表和性能调优密切相关，局部变量表占了栈帧的主要空间，因此它和栈溢出息息相关。局部变量表中的变量是垃圾回收的根节点，被局部变量表中的直接或间接引用的对象不会被回收。</font></p><blockquote><ol start="2"><li>操作数栈</li></ol></blockquote><p>&emsp;栈帧中的操作数栈Operand Stack采用数组来具体实现，也可被称之为表达式栈。操作数栈在方法的执行过程中，根据字节码指令，往栈中写入（入栈）或者提取（出栈）数据。<br>&emsp;操作数栈是栈（虚拟机栈）中栈（栈帧的操作数栈），它主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。<strong>局部变量表中的变量被操作的时候（比如执行i+j），会被压入操作数栈，经过一些指令(iadd)后再推出去，存储到局部变量表中</strong>。上述反汇编代码中的<code>stack=2</code>表示的是操作数栈的深度。</p><p>&emsp;栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul><p>&emsp;<strong>代码追踪实例</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> i = <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">800</span>;<br>    <span class="hljs-keyword">int</span> k = i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>javap -v xxx.class之后得到字节码指令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span><br> <span class="hljs-number">0</span>: bipush        <span class="hljs-number">15</span><br> <span class="hljs-number">2</span>: istore_1<br> <span class="hljs-number">3</span>: sipush        <span class="hljs-number">800</span><br> <span class="hljs-number">6</span>: istore_2<br> <span class="hljs-number">7</span>: iload_1<br> <span class="hljs-number">8</span>: iload_2<br> <span class="hljs-number">9</span>: iadd<br><span class="hljs-number">10</span>: istore_3<br><span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>&emsp;以上代码的具体执行如下图，<strong>指令类型采用所能包含的值的最小整数类型指令</strong>：</p><ul><li><ol><li>当执行main函数时，创建好栈帧。pc寄存器的值为0，栈帧中初始化了局部变量表和操作数栈，值为空</li></ol></li><li><ol start="2"><li>执行地址为0的指令，bipush，pc=2，15入栈</li></ol></li><li><ol start="3"><li>执行地址为2的指令，istore_1，pc=3，15出栈，局部变量表slot1=15（实例方法，slot0存储的是this变量）</li></ol></li><li><ol start="4"><li>执行地址为3的指令，sipush（由于800超过了byte的范围，所以会使用sipush，short类型），pc=5，8入栈</li></ol></li><li><ol start="5"><li>执行地址为5的指令，istore_2，pc=6，8出栈，局部变量表slot2=8</li></ol></li><li><ol start="6"><li>执行地址为6的指令，iload_1，pc=7，从slot1中加载15，15入栈</li></ol></li><li><ol start="7"><li>执行地址为7的指令，iload_2，pc=8，从slot2中加载8，8入栈</li></ol></li><li><ol start="8"><li>执行地址为8的指令，iadd，pc=9，8和15出栈并执行相加操作，23入栈</li></ol></li><li><ol start="9"><li>执行地址为9的指令，istore_3，pc=10，23出栈，局部变量表slot3=23</li></ol></li><li><ol start="10"><li>执行地址为10的指令，return。函数结束，栈帧销毁。<br><img src="https://img-blog.csdnimg.cn/20201013115416401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="代码追踪"></li></ol></li></ul><p><font color="red"><b>栈顶缓存(Top-of-Stack-Cashing)技术</b></font></p><p>&emsp;jvm简单介绍文章里面提到过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候需要使用更多的入栈和出栈指令，操作数栈存储在内存中，因此会导致频繁的内存读写，影响执行速度。为了解决这个问题HotSpot的提出了栈顶缓存技术。<br>&emsp;栈顶缓存是指将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎执行效率。</p><blockquote><ol start="3"><li>动态链接</li></ol></blockquote><p>&emsp;栈帧里面的<strong>动态链接、方法返回地址和一些附加信息</strong>有些地方把它们统称为<strong>帧数据区</strong>。<br>&emsp;动态链接又叫<strong>指向运行时常量池的方法引用</strong>。</p><ul><li><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>区域</p></li><li><p>包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>java源文件被编译为字节码文件后，<strong>所有的变量和方法的引用都会被保存到class文件的常量池（映射着的内存结构为方法区的运行时常量池）里面</strong></p></li><li><p>动态链接的作用是：<strong>把这些方法的符号引用转换为直接引用</strong></p></li></ul><p>  &emsp;如下图所示，栈帧中有一个区域专门用来存储方法引用。方法区内存是多线程共享的，假设方法A和方法B都调用方法C，那么在运行时常量池会有方法C的方法引用，方法A和方法B对应的栈帧中的区域都会存储该方法引用。</p><p>  <img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA2MTAxMjUxODQ3LnBuZw?x-oss-process=image/format,png" alt="动态链接"></p><p>  &emsp;以下代码，methodB()调用methodA()，反汇编之后的结果如下。从结果中我们可以看到，方法b中有指令<code>5: invokevirtual #5</code>，invokevirtual代表调用方法，<code>#5</code>为方法引用，表示常量池中的<code>#5 = Methodref          #28.#29</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DynamicLink</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br>        methodA();<br>        num++;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//javap -v xxx.class</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">hk7</span>.<span class="hljs-title">memory</span>.<span class="hljs-title">DynamicLink</span></span><br>  minor version: 0<br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>   #2 = Fieldref           #8.#24         // com/hk7/memory/DynamicLink.num:I<br>   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;<br>   #4 = String             #27            // methodA()....<br>   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V<br>   #6 = String             #30            // methodB()....<br>   #7 = Methodref          #8.#31         // com/hk7/memory/DynamicLink.methodA:()V<br>   #8 = Class              #32            // com/hk7/memory/DynamicLink<br>   #9 = Class              #33            // java/lang/Object<br>  #10 = Utf8               num<br>  #11 = Utf8               I<br>  #12 = Utf8               &lt;init&gt;<br>  #13 = Utf8               ()V<br>  #14 = Utf8               Code<br>  #15 = Utf8               LineNumberTable<br>  #16 = Utf8               LocalVariableTable<br>  #17 = Utf8               this<br>  #18 = Utf8               Lcom/hk7/memory/DynamicLink;<br>  #19 = Utf8               methodA<br>  #20 = Utf8               methodB<br>  #21 = Utf8               SourceFile<br>  #22 = Utf8               DynamicLink.java<br>  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V<br>  #24 = NameAndType        #10:#11        // num:I<br>  #25 = Class              #34            // java/lang/System<br>  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;<br>  #27 = Utf8               methodA()....<br>  #28 = Class              #37            // java/io/PrintStream<br>  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V<br>  #30 = Utf8               methodB()....<br>  #31 = NameAndType        #19:#13        // methodA:()V<br>  #32 = Utf8               com/hk7/memory/DynamicLink<br>  #33 = Utf8               java/lang/Object<br>  #34 = Utf8               java/lang/System<br>  #35 = Utf8               out<br>  #36 = Utf8               Ljava/io/PrintStream;<br>  #37 = Utf8               java/io/PrintStream<br>  #38 = Utf8               println<br>  #39 = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.hk7.memory.DynamicLink();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         7: putfield      #2                  // Field num:I<br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #4                  // String methodA()....<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">14</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;<br>         3: ldc           #6                  // String methodB()....<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V<br>         <span class="hljs-number">8</span>: aload_0<br>         9: invokevirtual #7                  // Method methodA:()V<br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        14: getfield      #2                  // Field num:I<br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        19: putfield      #2                  // Field num:I<br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">18</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/hk7/memory/DynamicLink;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=red><b>方法的调用</b></font></p><blockquote><ol start="4"><li>方法返回地址</li></ol></blockquote><p>&emsp;</p><blockquote><ol start="5"><li>一些附加信息</li></ol></blockquote><p>&emsp;《java虚拟机规范》中没有描述到的一些信息也可以保存在栈帧之中。比如调试、性能搜集等相关信息，取决于虚拟机具体的实现。</p><h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><p>&emsp;本地方法栈和虚拟机栈几乎一样，只不过它是为<strong>调用本地方法</strong>服务的。比如：调用本地的C、C++方法等。</p><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><p>&emsp;堆是虚拟机管理的最大的一块内存区域，此区域用于<strong>存放对象实例</strong>，几乎所有对象的内存分配都在java堆这里。</p><p>&emsp;堆是垃圾收集器管理的内存区域，因此堆也被叫做“GC堆”。大多数虚拟机对这一块内存采用“分代管理”的方式，因此这块内存在分代虚拟机（比如HotSpot虚拟机）里面又被分为新生代、老年代、永久代等，这块后面会具体讲。</p><p>&emsp;java堆属于多个线程共享的一块区域，但是如果具体划分也可以划分出线程私有的缓冲区（Thread Local Allocation Buffer， TLAB），用于提升对象分配效率。java虚拟机规范规定，java堆在物理上可以不连续，但是在逻辑上必须是连续的。</p><p>&emsp;java堆可以是固定大小的，也可以动态扩展，取决于具体虚拟机的实现。当前主流的虚拟机设计都是可动态扩展的（-Xmx、-Xms）。当堆中实例分配内存不足，且无法申请新的内存时，会报OutOfMemoryError。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h3><p>&emsp;方法区（只有HotSpot才有这个概念）是各个线程共享的一块区域，java方法区类似于常规语言编译代码的存储区，<strong>存储编译器编译后的代码缓存等数据</strong>，它存储每个类的结构，比如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法。</p><p>&emsp;JVM规范对方法区的约束很松，和堆一样，可以物理区间不连续、内存大小可选择固定和可扩展的外，还可以选择不实现垃圾回收。垃圾收集器在方法区很少出现，如果出现收集行为，主要针对常量池的回收和类型的卸载，这部分的回收很麻烦，但是有时候又很有必要。</p><p>&emsp;如果内存分配不足，会报OOM异常。</p><p>&emsp;<strong>由于这一块区域几乎不会发生GC，因此HotSpot把这一块区域称为“永久代”（Permanent Generation），jdk1.8之后称为元空间（metespace）。</strong></p><h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p>&emsp;<strong>运行时常量属于方法区的一部分</strong>，.class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项就是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量与符号引用，这部分的内容将在类加载后存放到方法区的运行时常量中池。</p><p>&emsp;规范没有对运行时常量池作任何要求，但是通常，除了保存.class中的符号描述引用外，还会把符号引用翻译出来的直接引用也存储在这里。</p><p>&emsp;运行时常量池具有动态性，除了编译产生的内容会进入，运行期间新产生的常量也可以进入常量池。比如String的intern()方法。当内存不够时，会报OOM异常。</p><h3 id="1-7-直接内存"><a href="#1-7-直接内存" class="headerlink" title="1.7 直接内存"></a>1.7 直接内存</h3><p>&emsp;直接内存不属于虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存经常被使用，也可能导致OOM。</p><p>&emsp;jdk1.4新加入了了NIO（New Input/Output）类，引入了一种基于通道和缓存区的I/O方式，它可以使用Native函数库直接分配对外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了再Java堆和Native堆中来回复制数据。</p><p>&emsp;直接内存的分配不受java堆大小的限制，但是机器的限制。</p><p>参考文档：<a href="https://docs.oracle.com/javase/8/docs/index.html">https://docs.oracle.com/javase/8/docs/index.html</a><br>参考文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5</a></p><h2 id="2-HotSpot对象内存布局"><a href="#2-HotSpot对象内存布局" class="headerlink" title="2. HotSpot对象内存布局"></a>2. HotSpot对象内存布局</h2><p>&emsp;HotSpot是目前最经典也最常用的虚拟机，本节以HotSpot为例，进一步解释说明上一节的运行时内存区域。</p><h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><p>&emsp;1、类加载</p><p>&emsp;当java虚拟机碰到new指令时，会执行以下步骤：</p><p><img src="https://img-blog.csdnimg.cn/2020112319063746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIwNzg=,size_16,color_FFFFFF,t_70" alt="对象的创建"></p><p>&emsp;2、内存分配</p><p>&emsp;类加载之后，对象所需要的内存大小可以完全确定下来。为对象分配内存实际上是从java堆上划分一块内存，存储对象相关信息。内存分划分有2种方式：</p><ul><li>如果内存是规整的（使用过的在一边，空闲的在另一边），则中间放一个指针，分配内存时，把指针向空闲的那边挪动与对象大小相等的距离。这种分配方式叫”指针碰撞“。</li><li>如果内存不是规整的，则需要维护一个列表，记录哪些内存块可用，哪些不可用。这种方式叫做”空闲列表“。</li></ul><p>&emsp;选择何种分配方式取决于内存是否规整，而内存是否规整又取决于垃圾收集器是否带有空间压缩站整理（Compact）功能。比如Serial、ParNew带压缩功能，使用指针碰撞方式，高效简单。CMS基于清楚算法的收集器，使用复杂的空闲列表方式。</p><p>&emsp;并发情况下，简单的”指针碰撞“会出现安全问题，有可能对象A分配内存指针还没来得及修改，对象B修改指针了。解决这个问题，有2种方式：</p><ul><li>虚拟机采用CAS+失败重试的方式，保证更新的原子性。</li><li>预先给线程划分一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB ），哪个线程需要分配内存，在自己的TLAB中进行。TLAB使用完毕之后，分配新的缓冲区则需要同步锁定。<code>-XX:+/-UseTLAB</code>设定是否使用TLAB</li></ul><p>&emsp;3、赋零值</p><p>&emsp;内存分配之后，虚拟机必须将分配到的内存空间（除了对象头）都初始化为零值。如果使用了TLAB，也可在在TLAB分配时赋零值。这一步操作保证了java代码中对象不赋初始值就可以直接使用。（比如 Integer i;）</p><p>&emsp;4、对象其他设置</p><p>&emsp;java虚拟机对象进行必要的设置，比如对象属于哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息会放到对象头（Object Header）之中。偏向锁、对象头设置方式等。</p><p>&emsp;以上步骤结束后，从虚拟机角度看，新的对象已经产生了。但是从程序员角度看，对象创建才和刚刚开始，因为还没开始执行init方法。</p><h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p>&emsp;在HotSpot虚拟机中，对象在堆内存中的布存储布局划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><blockquote><p>对象头（Mark Word）</p></blockquote><p>&emsp;HotSpot对象头包括两部分信息：1、存储自身的运行时数据  2、类型指针</p><p><strong>对象自身的运行时数据</strong></p><p>&emsp;比如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位虚拟机（未开启指针压缩）中，分别为**4个字节(32bit)和8个字节(64bit)**。</p><p>&emsp;对象头的结构是动态的，根据对象的状态复用存储空间。以便在极小的空间内存存储尽量多的数据，节省存储成本。</p><p>&emsp;在不同的状态下（5种状态）对象头中所存储的内容会有所不同，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">状态    标志位存储内容<br>无锁状态<span class="hljs-params">||</span><span class="hljs-number">01</span><span class="hljs-params">||</span>   对象哈希码、对象分代年龄<br>轻量级锁<span class="hljs-params">||</span>  <span class="hljs-number">00</span><span class="hljs-params">||</span>   指向栈中锁记录的指针<br>重量级锁<span class="hljs-params">||</span>  <span class="hljs-number">10</span><span class="hljs-params">||</span>   指向互斥量（重量级锁）的指针<br>GC标记<span class="hljs-params">||</span>  <span class="hljs-number">11</span><span class="hljs-params">||</span>   空，不记录信息<br>偏向锁，是否偏向锁为<span class="hljs-number">1</span>        <span class="hljs-params">||</span><span class="hljs-number">01</span><span class="hljs-params">||</span>   偏向线程ID、偏向时间戳、对象分代年龄<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200507092038123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpdXNoYW9Ncg==,size_16,color_FFFFFF,t_70" alt="32位和64位虚拟机中对象头结构"></p><p>&emsp;比如：在64位的HotSpot虚拟机中，如对象处于无锁状态下时，对象头的64个字节中的26个bit处于空闲状态，HashCode占了31个bit，4个bit用来描述分代年龄，1个bit固定为0表示不是偏向锁，2个bit用于存储锁标志位。</p><p><strong>类型指针</strong></p><p>&emsp;对象头的另一部分是类型指针，即对象指向它的类型原数据的指针，Java虚拟机通过这个指针来确定对象是哪个Class的实例。但是并不是所有的虚拟机实现都需要在对象数据上存储类型指针，后面会讲到这一点。</p><p>&emsp;如果对象是数组时，在对象头中还需要有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是数组的长度不确定，就无法推断出整个数组的大小，无法分配内存。</p><p>&emsp;类型指针占用大小：<code>-XX:+UseComparessedClassPointers</code> 开启的话是4个字节，不开启则为8个字节</p><blockquote><p>实例数据</p></blockquote><p>&emsp;实例数据部分是对象真正存储的有效信息。也就是我们在代码中定义的各种成员变量，父类子类的都必须记录起来。字段存储的顺序满足以下规则（按顺序满足）：</p><ul><li>HotSpot虚拟机默认分配顺序为：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），即相同宽度的字段会分配到一起存放。</li><li>父类中定义的变量会出现在子类之前。除非<code>+XX:CompactFields=true</code>，子类窄变量可以插入父类变量空隙之中。</li></ul><blockquote><p>对齐填充</p></blockquote><p>&emsp;HotSpot要求对象起始地址必须是8字节的整数倍，如果不是则会占位。实际上对象头的结构已经被定为6的整数倍（31或者64），如果实例数据部分不是，则会对齐填充。</p><p>&emsp;实例分析：分析new Object()对象大小</p><p>&emsp;&emsp;对象头：8个字节 + 类指针4个字节（默认开启了-XX:+UseComparessedClassPointers，因此为4字节）</p><p>   &emsp;&emsp;实例数据：成员变量没有，所以为0</p><p>&emsp;&emsp;对齐填充：8 + 4 = 12，需要对齐 + 4</p><p>&emsp;因此在64位下，SizeOf（Object） = 8 + 4 + 4 = 16字节。以下代码也可以验证：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> ObjectSizeTest &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        sizeOf();<br>    &#125;<br><br>    private static <span class="hljs-keyword">Object</span> <span class="hljs-keyword">types</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>();<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> Short((short) <span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> Long(<span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> Byte((byte) <span class="hljs-number">0</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">Character</span>((<span class="hljs-type">char</span>) <span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">Float</span>(<span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">Boolean</span>(<span class="hljs-keyword">true</span>);<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> String();<br><br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">0</span>];<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">1</span>];<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">2</span>];<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">3</span>];<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">4</span>];<br>//        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[<span class="hljs-number">5</span>];<br>    &#125;<br><br>    private static final Runtime runtime = Runtime.getRuntime();<br><br>    private static <span class="hljs-type">void</span> sizeOf() &#123;<br>        final <span class="hljs-type">int</span> count = <span class="hljs-number">100000</span>;<br>        <span class="hljs-keyword">Object</span>[] objs = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Object</span>[count];<br>        runGC();<br>        long heapSizeBefore = usedMemory();   // <span class="hljs-keyword">before</span> memory size<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            objs[i] = <span class="hljs-keyword">types</span>();<br>        &#125;<br><br>        runGC();<br>        long heapSizeAfter = usedMemory();      // <span class="hljs-keyword">after</span> memory size<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;heapSizeBefore = &quot; + heapSizeBefore);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;heapSizeAfter  = &quot; + heapSizeAfter);<br>        Long size = Math.round((heapSizeAfter - heapSizeBefore) / (<span class="hljs-type">double</span>) count);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(objs[<span class="hljs-number">0</span>].getClass().getSimpleName() + &quot;_size=&quot; + size);//<span class="hljs-number">16</span><br>    &#125;<br><br>    private static <span class="hljs-type">void</span> runGC() &#123;<br>        long usedMemOld = <span class="hljs-number">0</span>;<br>        long usedMemNew = usedMemory();<br>        <span class="hljs-keyword">while</span> (usedMemOld != usedMemNew) &#123;<br>            runtime.runFinalization();//强制调用已经失去引用的对象的finalize方法<br>            runtime.gc();//进行垃圾收集<br>            Thread.yield();//使当前线程从执行状态（运行状态）变为可执行态（就绪状态），给jvm去执行gc<br>            usedMemOld = usedMemNew;<br>            usedMemNew = usedMemory();<br>        &#125;<br>    &#125;<br><br><br>    private static long usedMemory() &#123;<br>        <span class="hljs-keyword">return</span> runtime.totalMemory() - runtime.freeMemory();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>&emsp;建立对象是为了使用对象，我们通过栈上的reference数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义引用应该通过什么方式定位、访问堆中的对象具体位置，所以对象的访问方式取决于虚拟机的实现。</p><p>&emsp;主流的方法分为<strong>句柄访问</strong>和<strong>直接指针访问</strong>两种，就HotSpot而言主要使用的是第二种直接指针访问进行对象访问（如果使用了ShenandoahGC收集器时会有额外的转发）</p><blockquote><p>句柄访问</p></blockquote><p>&emsp;Java堆中将可能会划分出一块内存在作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息。</p><p><img src="https://img-blog.csdnimg.cn/20200508115714208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpdXNoYW9Ncg==,size_16,color_FFFFFF,t_70" alt="句柄访问"></p><blockquote><p>直接指针访问</p></blockquote><p>&emsp;在使用直接指针访问时，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象实例地址，如果只是访问对象本身的话，就不需要多一次间接的定位开销</p><p><img src="https://img-blog.csdnimg.cn/20200508115734399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpdXNoYW9Ncg==,size_16,color_FFFFFF,t_70" alt="指针直接访问"></p><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM的简单介绍</title>
    <link href="/2020/10/09/JVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/10/09/JVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1、虚拟机概念"><a href="#1、虚拟机概念" class="headerlink" title="1、虚拟机概念"></a>1、虚拟机概念</h2><p>&emsp;虚拟机就是指虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>系统虚拟机：对物理计算机的仿真，提供可运行完整操作系统的虚拟平台，比如VirtualBox、VMware等。</li><li>程序虚拟机：专门为执行单个计算机程序而设计，比如java虚拟机（JVM），在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul><h2 id="2、java虚拟机"><a href="#2、java虚拟机" class="headerlink" title="2、java虚拟机"></a>2、java虚拟机</h2><h3 id="2-1-java字节码"><a href="#2-1-java字节码" class="headerlink" title="2.1 java字节码"></a>2.1 java字节码</h3><p>&emsp;java字节码是指java语言编译成的字节码，任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为jvm字节码。</p><p>&emsp;不同的编译器，可以编译出相同的字节码文件。任何语言只要能被编译器编译成字节码，就可以在jvm上运行。</p><p>&emsp;Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTIxNzI1MTg4LnBuZw?x-oss-process=image/format,png" alt="jvm只关注字节码，不关注源码"></p><h3 id="2-2-java虚拟机"><a href="#2-2-java虚拟机" class="headerlink" title="2.2 java虚拟机"></a>2.2 java虚拟机</h3><p>&emsp;Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制。由图上可知，不只是java，其他语言也可以被编译成字节码运行在jvm上，因此<strong>jvm是跨语言的平台</strong>。</p><p>&emsp;Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p><p>&emsp;Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里等。</p><p>&emsp;JVM的特点：</p><ul><li><ul><li>一次编译，到处运行</li></ul></li><li><ul><li>自动内存管理</li></ul></li><li><ul><li>自动垃圾回收</li></ul></li></ul><h2 id="3、JVM的整体结构"><a href="#3、JVM的整体结构" class="headerlink" title="3、JVM的整体结构"></a>3、JVM的整体结构</h2><p>&emsp;JVM运行在操作系统之上，它与硬件没有直接的交互。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTIzNDMyMDgyLnBuZw?x-oss-process=image/format,png" alt="jvm的位置"><br>&emsp;jvm在java体系中处于比较底层的位置。<br><img src="https://img2018.cnblogs.com/blog/890598/201902/890598-20190220210053733-743773115.png" alt="java体系结构"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTMyMzMwNjgyLnBuZw?x-oss-process=image/format,png" alt="hotspot整体结构"></p><ul><li>HotSpot是OracleJDK和OpenJDK共用的jvm</li><li>它采用解释器与即时编译器共存的结构</li><li>今天，java程序运行性能已经达到可以和c/c++一较高下的程度</li></ul><p>&emsp;上图可以看出，字节码文件是jvm的入口，文件通过类加载器被加载到内存中，生成一个大的class对象。加载又被分为加载、链接、初始化步骤，后续会具体讲解。运行时数据区是把内存分为了不同区域，其中java栈是老叫法，现在叫java虚拟机栈，具体可看上一篇文章。执行引擎被分为解释器、JIT即时编译器和垃圾回收，解释器用来解释字节码文件，JIT是对热点代码进行提前编译，这里的编译被称为编译的后端（源码被编译成字节码的过程叫编译的前端），垃圾回收器对使用后的内存进行回收管理，后续会具体讲到。执行引擎的作用实际上是把字节码指令翻译成机器指令，供计算机识别。</p><h2 id="4、java代码执行流程"><a href="#4、java代码执行流程" class="headerlink" title="4、java代码执行流程"></a>4、java代码执行流程</h2><p>&emsp;执行流程和一般的程序编译链接的差不多，具体可看<a href="https://happykite777.github.io/2020/09/27/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/">编译和链接</a>，Java的后端编译和链接是jvm实现的。<br><img src="http://5b0988e595225.cdn.sohucs.com/images/20200312/391f35c99f90452898cfefe633737401.png" alt="java代码执行流程"></p><h2 id="5、JVM架构模型"><a href="#5、JVM架构模型" class="headerlink" title="5、JVM架构模型"></a>5、JVM架构模型</h2><p>&emsp;java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><p>&emsp;基于栈式架构的特点：</p><ul><li><ul><li>设计和实现更简单，适用于资源受限的系统。（比如嵌入式平台、打印机）</li></ul></li><li><ul><li>避开寄存器的分配难题，使用零地址指令方式分配</li></ul></li><li><ul><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作占。指令集更小，编译器容易实现。</li></ul></li><li><ul><li>不需要硬件支持，可以执行更好，更好实现跨平台，可移植</li></ul></li><li><ul><li>在解释执行下，速度稍慢。但是经过即时编译器输出成物理机汇编指令流，就和指令没啥关系了</li></ul></li></ul><p>&emsp;基于寄存器架构的特点：</p><ul><li><ul><li>典型的应用是x86的二进制指令集：比如传统的pc和Android的Davlik虚拟机</li></ul></li><li><ul><li>指令集架构完全依赖于硬件，可以执行差</li></ul></li><li><ul><li>性能优秀和执行更高效</li></ul></li><li><ul><li>花费更少的指令去完成一项操作 </li></ul></li><li><ul><li>在大部分情况下，基于寄存器架构的指令集往往都是以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址为主</li></ul></li></ul><h3 id="两种架构举例"><a href="#两种架构举例" class="headerlink" title="两种架构举例"></a>两种架构举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackStructTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> k = i + j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译，在生成的StackStructTest.class目录下执行 <code>javap -v  StackStructTest.class</code>，可以得到汇编代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Classfile</span> <span class="hljs-string">/Users/zhoumi/IdeaProjects/learn/target/classes/com/hk7/memory/StackStructTest.class</span><br>  <span class="hljs-string">Last</span> <span class="hljs-string">modified</span> <span class="hljs-number">2020-10-10</span><span class="hljs-string">;</span> <span class="hljs-string">size</span> <span class="hljs-number">484</span> <span class="hljs-string">bytes</span><br>  <span class="hljs-string">MD5</span> <span class="hljs-string">checksum</span> <span class="hljs-string">7c6fc6746c6202d31f01b9dca6e74d98</span><br>  <span class="hljs-string">Compiled</span> <span class="hljs-string">from</span> <span class="hljs-string">&quot;StackStructTest.java&quot;</span><br><span class="hljs-string">public</span> <span class="hljs-string">class</span> <span class="hljs-string">com.hk7.memory.StackStructTest</span><br>  <span class="hljs-attr">minor version:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">major version:</span> <span class="hljs-number">49</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_SUPER</span><br><span class="hljs-attr">Constant pool:</span><br>   <span class="hljs-comment">#1 = Methodref          #3.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-comment">#2 = Class              #22            // com/hk7/memory/StackStructTest</span><br>   <span class="hljs-comment">#3 = Class              #23            // java/lang/Object</span><br>   <span class="hljs-comment">#4 = Utf8               &lt;init&gt;</span><br>   <span class="hljs-comment">#5 = Utf8               ()V</span><br>   <span class="hljs-comment">#6 = Utf8               Code</span><br>   <span class="hljs-comment">#7 = Utf8               LineNumberTable</span><br>   <span class="hljs-comment">#8 = Utf8               LocalVariableTable</span><br>   <span class="hljs-comment">#9 = Utf8               this</span><br>  <span class="hljs-comment">#10 = Utf8               Lcom/hk7/memory/StackStructTest;</span><br>  <span class="hljs-comment">#11 = Utf8               main</span><br>  <span class="hljs-comment">#12 = Utf8               ([Ljava/lang/String;)V</span><br>  <span class="hljs-comment">#13 = Utf8               args</span><br>  <span class="hljs-comment">#14 = Utf8               [Ljava/lang/String;</span><br>  <span class="hljs-comment">#15 = Utf8               i</span><br>  <span class="hljs-comment">#16 = Utf8               I</span><br>  <span class="hljs-comment">#17 = Utf8               j</span><br>  <span class="hljs-comment">#18 = Utf8               k</span><br>  <span class="hljs-comment">#19 = Utf8               SourceFile</span><br>  <span class="hljs-comment">#20 = Utf8               StackStructTest.java</span><br>  <span class="hljs-comment">#21 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V</span><br>  <span class="hljs-comment">#22 = Utf8               com/hk7/memory/StackStructTest</span><br>  <span class="hljs-comment">#23 = Utf8               java/lang/Object</span><br>&#123;<br>  <span class="hljs-string">public</span> <span class="hljs-string">com.hk7.memory.StackStructTest();</span><br>    <span class="hljs-attr">descriptor:</span> <span class="hljs-string">()V</span><br>    <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC</span><br>    <span class="hljs-attr">Code:</span><br>      <span class="hljs-string">stack=1</span>, <span class="hljs-string">locals=1</span>, <span class="hljs-string">args_size=1</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">aload_0</span><br>         <span class="hljs-attr">1:</span> <span class="hljs-string">invokespecial</span> <span class="hljs-comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-attr">4:</span> <span class="hljs-string">return</span><br>      <span class="hljs-attr">LineNumberTable:</span><br>        <span class="hljs-attr">line 9:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">LocalVariableTable:</span><br>        <span class="hljs-string">Start</span>  <span class="hljs-string">Length</span>  <span class="hljs-string">Slot</span>  <span class="hljs-string">Name</span>   <span class="hljs-string">Signature</span><br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-string">this</span>   <span class="hljs-string">Lcom/hk7/memory/StackStructTest;</span><br><br>  <span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String</span>[]<span class="hljs-string">);</span><br>    <span class="hljs-attr">descriptor:</span> <span class="hljs-string">(</span>[<span class="hljs-string">Ljava/lang/String;)V</span><br>    <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC</span>, <span class="hljs-string">ACC_STATIC</span><br>    <span class="hljs-attr">Code:</span><br>      <span class="hljs-string">stack=2</span>, <span class="hljs-string">locals=4</span>, <span class="hljs-string">args_size=1</span><br>         <span class="hljs-attr">0:</span> <span class="hljs-string">iconst_2</span><br>         <span class="hljs-attr">1:</span> <span class="hljs-string">istore_1</span><br>         <span class="hljs-attr">2:</span> <span class="hljs-string">iconst_3</span><br>         <span class="hljs-attr">3:</span> <span class="hljs-string">istore_2</span><br>         <span class="hljs-attr">4:</span> <span class="hljs-string">iload_1</span><br>         <span class="hljs-attr">5:</span> <span class="hljs-string">iload_2</span><br>         <span class="hljs-attr">6:</span> <span class="hljs-string">iadd</span><br>         <span class="hljs-attr">7:</span> <span class="hljs-string">istore_3</span><br>         <span class="hljs-attr">8:</span> <span class="hljs-string">return</span><br>      <span class="hljs-attr">LineNumberTable:</span><br>        <span class="hljs-attr">line 11:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">line 12:</span> <span class="hljs-number">2</span><br>        <span class="hljs-attr">line 13:</span> <span class="hljs-number">4</span><br>        <span class="hljs-attr">line 14:</span> <span class="hljs-number">8</span><br>      <span class="hljs-attr">LocalVariableTable:</span><br>        <span class="hljs-string">Start</span>  <span class="hljs-string">Length</span>  <span class="hljs-string">Slot</span>  <span class="hljs-string">Name</span>   <span class="hljs-string">Signature</span><br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-string">args</span>   [<span class="hljs-string">Ljava/lang/String;</span><br>            <span class="hljs-number">2</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>     <span class="hljs-string">i</span>   <span class="hljs-string">I</span><br>            <span class="hljs-number">4</span>       <span class="hljs-number">5</span>     <span class="hljs-number">2</span>     <span class="hljs-string">j</span>   <span class="hljs-string">I</span><br>            <span class="hljs-number">8</span>       <span class="hljs-number">1</span>     <span class="hljs-number">3</span>     <span class="hljs-string">k</span>   <span class="hljs-string">I</span><br>&#125;<br><span class="hljs-attr">SourceFile:</span> <span class="hljs-string">&quot;StackStructTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p>基于栈的计算流程（以Java虚拟机为例）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>: iconst_<span class="hljs-number">2</span>    //常量<span class="hljs-number">2</span><br><span class="hljs-attribute">1</span>: istore_<span class="hljs-number">1</span>    //把常量<span class="hljs-number">2</span>保存到索引为<span class="hljs-number">1</span>的操作数栈中<br><span class="hljs-attribute">2</span>: iconst_<span class="hljs-number">3</span>    //常量<span class="hljs-number">3</span><br><span class="hljs-attribute">3</span>: istore_<span class="hljs-number">2</span>    //把常量<span class="hljs-number">3</span>保存到索引为<span class="hljs-number">2</span>的操作数栈中<br><span class="hljs-attribute">4</span>: iload_<span class="hljs-number">1</span>     //加载常量<span class="hljs-number">2</span><br><span class="hljs-attribute">5</span>: iload_<span class="hljs-number">2</span>     //加载常量<span class="hljs-number">3</span><br><span class="hljs-attribute">6</span>: iadd   //对常量<span class="hljs-number">2</span>和<span class="hljs-number">3</span>求和<br><span class="hljs-attribute">7</span>: istore_<span class="hljs-number">3</span>    //把求和的结果保存在索引为<span class="hljs-number">3</span>的操作数栈中<br></code></pre></td></tr></table></figure><p>&emsp;基于栈的指令都是不带参数的，使用操作数栈中的数据作为指令的运算输入，指令运算结果也存在与操作数栈之中。</p></li><li><p>而基于寄存器的计算流程</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">2</span> //将<span class="hljs-built_in">eax</span>寄存器的值设为<span class="hljs-number">1</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">3</span> //使<span class="hljs-built_in">eax</span>寄存器的值加<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的。</strong></p><h2 id="6、JVM的生命周期"><a href="#6、JVM的生命周期" class="headerlink" title="6、JVM的生命周期"></a>6、JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>&emsp;<strong>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的</strong>，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong>。可通<code>jps</code>来查看虚拟机中正在执行的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mach-O目标文件格式</title>
    <link href="/2020/09/28/Mach-O%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2020/09/28/Mach-O%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-目标文件"><a href="#1-目标文件" class="headerlink" title="1. 目标文件"></a>1. 目标文件</h2><p>&emsp;程序如果被想要跑起来，必须遵循计算机可执行文件的格式。比如linux和unix下的elf、window下的PE、macOS下的Mach-O（Mach Object File Format）。他们都是COFF格式的变种。</p><p>&emsp;我们知道编译器编译源码生成可执行文件，链接器链接各个目标文件和库文件成为可执行文件，其实目标文件和可执行文件的内容和结构很类似，因此目标文件和可执行文件采用相同的格式，即可执行文件格式。此外，动态链接库（比如linux的.so，window的.dll）和静态链接库（window的.lib和linux的.a）文件都按照可执行文件格式存储。</p><p>&emsp;macOS 支持三种可执行格式：解释器脚本格式、通用二进制格式和 Mach-O 格式。</p><table><thead><tr><th align="center">可执行格式</th><th align="center">magic值</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">脚本</td><td align="center">\x7FELF</td><td align="center">主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 #! 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令</td></tr><tr><td align="center">通用二进制格式</td><td align="center">0xcafebabe（32bit）/0xbebafeca（64bit）</td><td align="center">包含多种架构支持的二进制格式，只在 macOS 上支持</td></tr><tr><td align="center">Mach-O</td><td align="center">0xfeedface(32bit)/0xfeedfacf(64bit)</td><td align="center">macOS 的原生二进制格式</td></tr></tbody></table><h2 id="2-Mach-O文件格式"><a href="#2-Mach-O文件格式" class="headerlink" title="2. Mach-O文件格式"></a>2. Mach-O文件格式</h2><p>&emsp;</p><h2 id="3-Simple-o剖析"><a href="#3-Simple-o剖析" class="headerlink" title="3. Simple.o剖析"></a>3. Simple.o剖析</h2><p><a href="https://www.jianshu.com/p/175925ab3355">https://www.jianshu.com/p/175925ab3355</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>编译和链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译和链接基础知识</title>
    <link href="/2020/09/27/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <url>/2020/09/27/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<ul><li>机器语言：能够被计算机识别和执行的二进制指令。</li><li>汇编语言：面向机器的程序设计语言，汇编指令和机器语言之间有着一一对应的关系，人看汇编代码很吃力，但是比起一大串的01代码还是简单的多。</li><li>高级语言：程序员编写的语言，C、C++、Java等。</li></ul><p>&emsp;程序员编写的高级语言符合人类的思维模式，但是计算机只认识0和1，无法识别高级语言，因此，我们编写好的代码，需要一种中间过程，将我们写好的代码，转换为二进制代码，从而让计算机得以执行。</p><p>&emsp;源文件转换为二进制文件经历了以下几个阶段：预处理(prepressing)、编译(compilation)、汇编(assembly)、链接(linking)，如下图所示：<br><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2496969140,4180722254&fm=26&gp=0.jpg"></p><p>&emsp;hello.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;经过gcc编译器编译（指以上的所有阶段，不是单指编译阶段）后，得到可执行文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.out</span><br></code></pre></td></tr></table></figure><p>&emsp;预处理需要预处理程序（c中叫cpp）处理、编译需要编译程序（c中叫cc1、c++中叫cc1plus、oc叫cc1obj、java叫jc1……）处理、汇编需要汇编程序程序（c中叫as）处理，链接需要链接器（c中叫ld）处理。gcc实际上是对这些过程的封装，通过不同的参数调用不同的处理程序。<br>&emsp;以上编译过程可以拆解为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -E hello<span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span>        <span class="hljs-comment">// 预编译</span><br>gcc -S hello<span class="hljs-selector-class">.i</span> -o hello<span class="hljs-selector-class">.s</span>        <span class="hljs-comment">// 编译</span><br>gcc -c hello<span class="hljs-selector-class">.s</span> -o hello<span class="hljs-selector-class">.o</span>      <span class="hljs-comment">// 汇编，目标文件</span><br>gcc hello<span class="hljs-selector-class">.o</span> -o hello<span class="hljs-selector-class">.out</span>      <span class="hljs-comment">// 链接，可执行文件</span><br></code></pre></td></tr></table></figure><h2 id="1-源代码是如何到二进制的"><a href="#1-源代码是如何到二进制的" class="headerlink" title="1. 源代码是如何到二进制的"></a>1. 源代码是如何到二进制的</h2><h3 id="1-1-预编译"><a href="#1-1-预编译" class="headerlink" title="1.1 预编译"></a>1.1 预编译</h3><p>预编译主要是对源文件中的预编译指令进行处理，比如#include、#define等。处理规则如下：</p><ul><li>删除所有的”#define”，并展开所有宏定义  </li><li>处理所有的条件预编译指令，比如 #if、#ifdef……</li><li>处理#include预编译指令，将所有被包含的文件插入进该指令位置</li><li>删除所有的注释</li><li>添加行号和文件名标识，便于编译是产生调试用的信息</li><li>保留所有的#pragma指令，供后续使用<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -E hello<span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span>        <span class="hljs-comment">// 预编译</span><br></code></pre></td></tr></table></figure>预编译之后，文件不再包含任何宏信息，以下是预处理之后文件的部分代码<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lsl"># <span class="hljs-number">1</span> <span class="hljs-string">&quot;hello.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> <span class="hljs-number">1</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> <span class="hljs-number">3</span><br># <span class="hljs-number">361</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> <span class="hljs-number">3</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command line&gt;&quot;</span> <span class="hljs-number">1</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span> <span class="hljs-number">2</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;hello.c&quot;</span> <span class="hljs-number">2</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">64</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h&quot;</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/_stdio.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><br>…………<br><br>extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,<br>       const char * restrict, va_list);<br># <span class="hljs-number">412</span> <span class="hljs-string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/stdio.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">2</span> <span class="hljs-string">&quot;hello.c&quot;</span> <span class="hljs-number">2</span><br><br>int main(int argc, char const *argv[])<br>&#123;<br> printf(<span class="hljs-string">&quot;%s<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br> return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-编译"><a href="#1-2-编译" class="headerlink" title="1.2 编译"></a>1.2 编译</h3><p>&emsp;编译过程主要是把预处理之后的文件进行一系列的词法分析、语法分析、语义分析及源码优化，编译后会产生相应的汇编源文件。这也是整个过程中最复杂的一部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.i</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.s</span><br></code></pre></td></tr></table></figure><p>&emsp;现代的gcc把预编译和编译两个步骤合并，使用cc1一步完成。</p><h3 id="1-3-汇编"><a href="#1-3-汇编" class="headerlink" title="1.3 汇编"></a>1.3 汇编</h3><p>&emsp;汇编器将汇编代码编程机器可以执行的指令， 每一条汇编指令都对应着一条机器指令。汇编器的执行很简单，不需要优化，只需要对照汇编指令和机器指令表一一翻译即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.o</span><br></code></pre></td></tr></table></figure><h3 id="1-4-链接"><a href="#1-4-链接" class="headerlink" title="1.4 链接"></a>1.4 链接</h3><p>通常我们看到链接会链接一大串文件，如下图所示，它会把编译生成的目标文件和运行时需要的库等打包放一起。具体后面会讲。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal">$ld -static /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">crt1</span>.<span class="hljs-title">o</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">crti</span>.<span class="hljs-title">o</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">gcc</span>/<span class="hljs-title">i486</span>-<span class="hljs-title">linux</span>-</span><br>gnu/<span class="hljs-number">4.1</span>.<span class="hljs-number">3</span>/crtbeginT.o -L/usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">gcc</span>/<span class="hljs-title">i486</span>-<span class="hljs-title">linux</span>-<span class="hljs-title">gnu</span>/4.1.3 -<span class="hljs-title">L</span>/<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span> -</span><br>L/<span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">hello</span>.<span class="hljs-title">o</span> --<span class="hljs-title">start</span>-<span class="hljs-title">group</span> -<span class="hljs-title">lgcc</span> -<span class="hljs-title">lgcc_eh</span> -<span class="hljs-title">lc</span> --<span class="hljs-title">end</span>-<span class="hljs-title">group</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">gcc</span>/<span class="hljs-title">i486</span>-</span><br>linux-gnu/<span class="hljs-number">4.1</span>.<span class="hljs-number">3</span>/crtend.o /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">crtn</span>.<span class="hljs-title">o</span></span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.out</span><br><span class="hljs-selector-tag">gcc</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">hello</span><span class="hljs-selector-class">.out</span><br></code></pre></td></tr></table></figure><h2 id="2-编译的过程"><a href="#2-编译的过程" class="headerlink" title="2. 编译的过程"></a>2. 编译的过程</h2><p>&emsp;编译主要分为6步：<strong>词法分析、语法分析、语义分析、中间代码优化、目标代码生成和目标代码优化。</strong>这里的编译实际上是上述的编译和汇编两个过程。<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1750648939,4195670772&fm=26&gp=0.jpg" alt="编译过程"><br>&emsp;其中前4个步骤生成中间代码，它是和机器无关的，被称为<strong>前端编译</strong>，后2个步骤，和具体的平台架构、字长等相关，又叫做<strong>后端编译</strong>。</p><h3 id="2-1-词法分析"><a href="#2-1-词法分析" class="headerlink" title="2.1 词法分析"></a>2.1 词法分析</h3><p>&emsp;源代码程序被输入到扫描器，它会做语法分析，运用算法将字符串分割成一系列的记号。<br>&emsp;比如有一行c源码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">array</span>[index] = (index + <span class="hljs-number">4</span>) * (<span class="hljs-number">2</span> + <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>&emsp;包含28个非空字符，扫描后，分割成16个记号。</p><!DOCTYPE html><html><head>    <title></title></head><body >    <table align="center" width="200px">        <tr><th>记号</th><th>类型</th></tr>        <tr><td>array</td><td>标识符 </td></tr>        <tr><td>[</td><td>左方括号 </td></tr>        <tr><td>]</td><td>右方括号 </td></tr>        <tr><td>=</td><td>赋值 </td></tr>        <tr><td>(</td><td>左圆括号 </td></tr>        <tr><td>index</td><td>标识符 </td></tr>        <tr><td>\+</td><td>加号 </td></tr>        <tr><td>4</td><td>数字 </td></tr>        <tr><td>)</td><td>右圆括号 </td></tr>        <tr><td>\*</td><td>乘号 </td></tr>        <tr><td>(</td><td>左圆括号 </td></tr>        <tr><td>2</td><td>数字 </td></tr>        <tr><td>\+</td><td>加号 </td></tr>        <tr><td>6</td><td>数字 </td></tr>        <tr><td>)</td><td>右圆括号 </td></tr>    </table></body></html><p>&emsp;词法分析产生的记号有几类：关键字、标识符、字面量和特殊符号（加号、括号等），扫描器在识别的同时会做一些其他的事，比如将标识符放到符号表，将数字字符串常量存放到文字表等。</p><h3 id="2-2-语法分析"><a href="#2-2-语法分析" class="headerlink" title="2.2 语法分析"></a>2.2 语法分析</h3><p>&emsp;语法分析器会将词法分析器产生的记号进行语法分析，产生语法分析树。比如以上产生的语法树如下：<br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3153678276,3283363363&fm=26&gp=0.jpg" alt="语法树"></p><h3 id="2-3-语义分析"><a href="#2-3-语义分析" class="headerlink" title="2.3 语义分析"></a>2.3 语义分析</h3><p>&emsp;语义分析由语义分析器完成，它会对上述生成的语法树进行合法性分析，比如数字和数字相加是合法的，但是数字和指针相加则会报错。<br>&emsp;编译器只能做静态语义分析。比如声明和类型的匹配、类型的转换等。经过语义分析后，产生的语法树如下：<br><img src="https://www.pianshen.com/images/621/6cd6f41ffec80b27c299440e4d41f29d.png" alt="语义分析后的语法树"></p><h3 id="2-4-中间代码优化"><a href="#2-4-中间代码优化" class="headerlink" title="2.4 中间代码优化"></a>2.4 中间代码优化</h3><p>&emsp;在生成汇编语言之前，编译器会对源代码进行优化。比如上述例子中的2+6，在编译时期是可以确定的，这是属于源代码优化的一种，类似的还有很多。<br><img src="https://www.pianshen.com/images/892/24b52fae4922dbb5d48677376e07b02c.png" alt="优化之后的语法树"><br>&emsp;但是编译器直接对语法树进行优化很难，因此它会将整个语法树转换成<strong>中间代码</strong>。它是语法树的中间表示，很接近目标代码，但是和机器无关。<br>&emsp;中间代码在不同的编译器中有不同形式，常见的有三地址码（Three-address Code）和P-代码（P-Code）。<br>&emsp;最基本的三地址码：x = y op z，表示将y和z进行op操作后，赋值给x。因此，上述代码被翻译成三地址码后是这样的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">t1</span> = <span class="hljs-number">2</span> + <span class="hljs-number">6</span><br><span class="hljs-attribute">t2</span> = index + <span class="hljs-number">4</span><br><span class="hljs-attribute">t3</span> = t<span class="hljs-number">2</span> * t<span class="hljs-number">1</span><br><span class="hljs-attribute">array</span>[index] = t<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以被优化成这样</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">t2</span> = index + <span class="hljs-number">4</span><br><span class="hljs-attribute">t2</span> = t<span class="hljs-number">2</span> * <span class="hljs-number">8</span><br><span class="hljs-attribute">array</span>[index] = t<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>&emsp;中间代码是编译分为前端和后端。前端负责产生和机器无关的中间代码（不是汇编代码），后端服务将中间代码转换成目标机器代码。一些跨平台的语言编译时，可以使用一个前端和不同的多个后端。</p><h3 id="2-5-目标代码生成与优化"><a href="#2-5-目标代码生成与优化" class="headerlink" title="2.5 目标代码生成与优化"></a>2.5 目标代码生成与优化</h3><p>&emsp;编译器后端主要包括代码生成器和目标代码优化器。代码生成器会将中间转换成目标机器代码，这个过程依赖目标机器，不同的机器字长、寄存器、整型长度等都不一样。假设目标机器cpu使用x86架构，则会生成以下汇编代码</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">movl <span class="hljs-keyword">index</span>, %ecx; <span class="hljs-keyword">index</span>放入ecx寄存器<br>addl $4, %ecx; ecx = ecx + <span class="hljs-number">4</span><br>mull $8, %ecx; ecx = ecx * <span class="hljs-number">8</span><br>movl <span class="hljs-keyword">index</span>, %eax; <span class="hljs-keyword">index</span>放入eax寄存器<br>movl %ecx, array(,eax,<span class="hljs-number">4</span>) ; array[<span class="hljs-keyword">index</span>] = ecx<br></code></pre></td></tr></table></figure><p>&emsp;最后代码优化器对上述代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法、删除多余的指令等。</p><h2 id="3-链接的过程"><a href="#3-链接的过程" class="headerlink" title="3. 链接的过程"></a>3. 链接的过程</h2><p>&emsp;经过编译器的词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化后，源代码终于被编译成了目标代码。但是目标代码中有一个问题：index和array的地址还没有确定？如果引用的是其他程序模块变量，地址怎么确定呢？<br>&emsp;事实上，定义的其他模块的全局变量和函数最终运行时的绝对地址都要在最终链接的时候确定，这个过程由链接器实现。<br>&emsp;链接器是一个将编译器产生的目标文件打包成可执行文件或者库文件或者目标文件的程序。<br>&emsp;程序由若干个模块组成，各个模块之间会进行通信，比如调用其他模块的函数，需要知道函数的地址，访问其他模块的变量，也需要变量的地址，这都归结于一种方式，即模块间符号的引用。<br>&emsp;<strong>模块间依靠符号来通信，定义符号的模块多出来的区域，刚好拼接上引用该符号的模块缺少的区域，这个拼接的过程就叫：链接</strong>。<br><img src="https://img-blog.csdn.net/20180917213258403?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zNzM4MjMxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="链接"></p><p>&emsp;链接器主要的工作就是把一些指令对其他符号地址的引用修正为真正的地址。<br>&emsp;链接过程主要包括<strong>地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）</strong>等步骤。<br>&emsp;符号决议在在静态链接的时候称为符号决议或者名称决议（Name Resolution），在动态链接的时候被叫做<strong>符号绑定（Symbol Binding）</strong>或者名称绑定（Name Binding），有时候甚至叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）。从名称上可以区分出来，决议偏向静态链接，绑定偏向动态链接。</p><ul><li>符号决议：其实就是指用符号来去标识一个地址。比如说 int a = 6;这样一句代码，用a来标识一个块4个字节大小的空间，空间里边存放的内容就是4.</li><li>重新计算各个目标的地址过程叫做重定位。</li></ul><h3 id="3-1-静态链接"><a href="#3-1-静态链接" class="headerlink" title="3.1 静态链接"></a>3.1 静态链接</h3><p>&emsp;如下图，最基本的静态链接就是把目标文件和库文件一起链接，形成最终可执行文件。最常见的库是运行时库。<br><img src="http://blog.chinaunix.net/attachment/201308/8/26548237_1375965656F2Fy.png" alt="静态链接过程"><br>&emsp;我们在main.c模块中调用另一个模块func.c中的函数foo，必须知道foo的地址，但是每个模块都是单独编译的，在编译main.c的的时候并不知道foo函数的地址，所以编译器会暂时搁置调用foo的指令的目标地址，等链接的时候，链接器会根据引用符号foo，自动去相应的func.c模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让他们的目标地址为真正foo函数的地址。这就是静态链接最基本的过程和作用。<br>&emsp;假设A里面有个全局变量p，我们再B里面要访问这个全局变量，B里面有这么一条指令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movl</span> $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>a, p     // p = <span class="hljs-number">42</span>，x<span class="hljs-number">86</span>架构<br></code></pre></td></tr></table></figure><p>&emsp;意思是给p变量赋值0x2a。编译B得到指令机器码  <u>C7 05</u>  <u>00 00 00 00</u>  <u>2a 00 00 00</u>，c705是mov指令码，2a为源常量，由于不知道地址所以暂时置为0，等链接器链接A和B的时候，假设确定p的地址为0x1000，则把目标地址修改为0x1000，即<u>C7 05</u>  <u>00 00 10 00</u>  <u>2a 00 00 00</u>。</p><h3 id="3-2-动态链接"><a href="#3-2-动态链接" class="headerlink" title="3.2 动态链接"></a>3.2 动态链接</h3><p>&emsp;把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件</p><p>&emsp;假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。</p><p>&emsp;链接是一个很复杂的过程，后续有时间再写。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译和链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引及其优化</title>
    <link href="/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <url>/2020/09/25/MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-索引的数据结构"><a href="#1-索引的数据结构" class="headerlink" title="1.索引的数据结构"></a>1.索引的数据结构</h2><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>&emsp;哈希索引为索引列计算一个哈希值，然后存放在一个哈希表中。如果哈希值相同，则以链表的形式连接。<br><img src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" alt="image"></p><ul><li>哈希索引数据未排序，因此做区间查询的速度慢，且无法用于order by</li><li>哈希索引对于数据读取特别快，但只适用于等值查询的场景，比如Memory引擎</li><li>如果哈希冲突很多，索引维护代价高</li></ul><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>&emsp;&emsp;最常用的索引，大多数MySQL引擎支持B-Tree索引（Archive引擎不支持任何索引），虽然名字叫B-Tree索引，但不同的引擎内部有自己的实现方式，比如NDB集群引擎内部使用B-Tree结构存储数据，而InnDB使用B+Tree结构。</p><html><center><img src='https://note.youdao.com/yws/public/resource/39bb332f3420ad4aeff72ecc1ee7f58c/xmlnote/WEBRESOURCEeaac64d29be16f22c5dbe9dde8da5926/18609'></img><h4>InnoDB 索引结构</h4></center>关于<a href='https://blog.csdn.net/qq_26222859/article/details/80631121'>B+树</a></html><p>&emsp;&emsp;二叉搜索树是查询效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>&emsp;&emsp;你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p><p>&emsp;&emsp;二分查找每一次搜索就是一次IO，如果想减少IO操作，必须把树变矮，存储数据不变，则每个节点变多，也就是N叉树（B+树的阶）。“N”取决于数据块的大小。</p><p>&emsp;&emsp;以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><hr><h2 id="2-索引的类型"><a href="#2-索引的类型" class="headerlink" title="2.索引的类型"></a>2.索引的类型</h2><p>索引按照类型区分</p><ul><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li><li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li></ul><p><strong>普通索引和唯一索引如何选择？</strong></p><p>当数据页更新时，如果这个数据页还没有在内存中的话，<br>在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中。<br>当下次访问这个数据页的时候，会将change buffer持久化到磁盘。</p><p>记录要更新的目标页在内存中：</p><ul><li>对于唯一索引来说，找到合适的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到合适的位置，插入这个值，语句执行结束。</li></ul><p>记录要更新的目标页不在内存中：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。</li></ul><p>综上，尽量选择普通索引，如果有唯一性需求，在业务代码中做判断。</p><p>ps.索引合并，使用多个单列索引组合搜索</p><hr><h2 id="3-InnoDB索引模型"><a href="#3-InnoDB索引模型" class="headerlink" title="3.InnoDB索引模型"></a>3.InnoDB索引模型</h2><h3 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h3><p>假设有以下表T，id为主键，k建索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(<br>  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>, <br>  k <span class="hljs-built_in">int</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>, <br>  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">16</span>),<br>  <span class="hljs-keyword">index</span> (k)<br>)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">InnoDB</span>;<br></code></pre></td></tr></table></figure><p>那么将会对应2颗索引树主键索引和非主键索引，如下图。<br><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="image"></p><ul><li>主键索引的叶子节点存的是==整行数据==。在InnoDB里，主键索引也被称为==聚簇索引==（clustered index）。</li><li>非主键索引的叶子节点内容是==主键的值==。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> <span class="hljs-keyword">ID</span>=<span class="hljs-number">500</span> <br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> k=<span class="hljs-number">5</span>    <br></code></pre></td></tr></table></figure><p>以上两个语句虽然结果是一样的，但是查询过程有差别：</p><ul><li>where ID=500, 主键查询方式，则只需要搜索ID这棵B+树；</li><li>where k=5, 普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p><strong>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</strong></p><p>对于InnDB，如果建表时候没有指定pk，会判断是否有非空的唯一索引，如果有则该列为主键，如果没有会自动创建一个db_row_id做主键。</p><h3 id="主键如何选择"><a href="#主键如何选择" class="headerlink" title="主键如何选择"></a>主键如何选择</h3><p>主键可以采用自增也可以以业务字段（比如身份证号）做主键。</p><ul><li>从性能上看，以业务字段做主键无法保证有序插入，这样使得写数据的成本变高。</li><li>从存储空间的角度来看，每个非主键索引的叶子节点上都是主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</li></ul><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><p>当业务需求，表中只有一个索引，且为唯一索引时，适合使用业务字段做主键。</p><h2 id="4-索引优化策略"><a href="#4-索引优化策略" class="headerlink" title="4.索引优化策略"></a>4.索引优化策略</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>&emsp;&emsp;上述例子，如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为==覆盖索引==。</p><html><p style="color:red;">&emsp;&emsp;由<b>于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</b></p></html><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引就是只给列的前n个字符建立索引。通常适合在大字段上建立前缀索引。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">alter table t_dispatch_citys add key(<span class="hljs-name">en_name</span>(<span class="hljs-name">n</span>))<br></code></pre></td></tr></table></figure><p>n如何选择？  </p><blockquote><p>选择性 = 基数 / 记录总数,   （1/T  ~  1）</p></blockquote><p>选择性要足够大，唯一索引的选择性为1，是最好的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">1</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r1,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">2</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r2,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">3</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r3,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">4</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r4,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">5</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r5,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">6</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r6,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">7</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r7,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">8</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r8,<br><span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-keyword">left</span>(en_name, <span class="hljs-number">20</span>))/<span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> r9<br><span class="hljs-keyword">from</span> <span class="hljs-string">`t_dispatch_citys`</span>;<br><br><span class="hljs-comment"># 测试结果</span><br><span class="hljs-comment">#   r1 r2  r3  r4  r5  r6  r7  r8</span><br><span class="hljs-comment"># 0.0940.18650.49660.74160.90110.97300.98880.9910</span><br><span class="hljs-comment"># 当n=6的时候，选择性已经97%了。</span><br></code></pre></td></tr></table></figure><p>MySQL不支持后缀索引，但是可以采用曲线方式，后缀索引=reverse(前缀)</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引即在多个字段上建索引，联合索引也符合“最左前缀原则”。  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span> T where <span class="hljs-attribute">a</span>=? <span class="hljs-keyword">and</span> <span class="hljs-attribute">b</span>=?<br></code></pre></td></tr></table></figure><p>如果分别在a、b上建索引，则mysql会采用using intersect交集算法。对所有使用的索引执行同步扫描，并生成从合并索引扫描中接收到的行序列的交集。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9iVVJQamdGcEdNVDl5Z2dQc2Zkcktad1pjZkEwZmliaWM2Uk5ZeDdaWkpYZVN1bDVZRnp1TmZmT2JHOG9ZSUk0d21hTWZkd1pERGtyY2RvaWM0aDJuYWcwdy82NDA?x-oss-process=image/format,png" alt="intersect交集算法"><br>联合索引如何排序？</p><blockquote><p>如果通过调整顺序，可以少维护一个索引，则优先考虑该顺序。<br>如果仅仅只是选择这一个索引，则选择性高的字段排前面。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">test</span><br>(<br>    <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>,<br>    a  <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>    b  <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>    c  <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>    d <span class="hljs-built_in">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">index</span> (a, b, c)<br>);<br><br><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span>, a <span class="hljs-keyword">from</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">where</span> c = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>以上sql还是会命中索引，where虽然不符合最左前缀原则，但是id和a字段都在联合索引上，优化器会对比遍历主键索引树和联合索引树的代价，发现联合索引更快，于是会命中。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">CREATE TABLE `tuser` (<br>  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  `id_card` varchar(32)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `name` varchar(32)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `ismale` tinyint(1)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  PRIMARY KEY (`id`),<br>  KEY `id_card` (`id_card`),<br>  KEY `name_age` (`name`,`age`)<br>) <span class="hljs-attribute">ENGINE</span>=InnoDB<br></code></pre></td></tr></table></figure><p>MySQL5.6以前是这样走的<br><img src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="不走索引下推"><br>MySQL5.6推出了索引下推策略，是这样走的，减少了回表的次数<br><img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="索引下推"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot自动配置原理</title>
    <link href="/2020/07/25/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/25/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>&emsp;spring boot大大简化了spring里面的各种配置，那么它是如何自动加载各种配置的呢？通过源码分析</p><p>springboot项目都有一个主启动类，主启动类最重要的注解是<code>@SpringBootApplication</code>，<code>@SpringBootApplication</code>又是由一系列注解组成的，大概的继承关系如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span>：<br><br>​<span class="hljs-variable">@EnableAutoConfiguration</span>：<br><br>​<span class="hljs-variable">@AutoConfigurationPackage</span><br><br>​<span class="hljs-variable">@Import</span>(AutoConfigurationImportSelector.class)<br><br>​……<br><br>​……<br></code></pre></td></tr></table></figure><p>&emsp;自动配置的核心功能又这两个注解完成：<code>@AutoConfigurationPackage</code>和<code>@Import(AutoConfigurationImportSelector.class)</code>。</p><h2 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h2><p>&emsp;@AutoConfigurationPackage的内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>register(registry, <span class="hljs-keyword">new</span> PackageImport(metadata).getPackageName());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br><span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> PackageImport(metadata));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;AutoConfigurationPackages.Registrar类中的registerBeanDefinitions()，功能是注册一个Bean的定义。**new PackageImport(metadata).getPackageName()**，返回了当前主程序类的 <em>同级以及子级</em>   的包组件。也就是main文件所在文件夹包及其下面所有的包。当程序进行ioc注入的时候，只会注入这些包下面被<code>@Bean</code>标注的对象。</p><h2 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)"></a>@Import(AutoConfigurationImportSelector.class)</h2><p>&emsp;AutoConfigurationImportSelector.class的源码如下，其中getAutoConfigurationEntry()方法实现了所有需要自动配置的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> NO_IMPORTS;<br>&#125;<br>AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader<br>.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br>AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,<br>annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;getCandidateConfigurations()方法得到所有需要配置的候选类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span><br><span class="hljs-function"><span class="hljs-params">AnnotationMetadata annotationMetadata)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125;<br>AnnotationAttributes attributes = getAttributes(annotationMetadata);<br><span class="hljs-comment">//获取所有需要自动配置的类名</span><br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br><span class="hljs-comment">//去重</span><br>configurations = removeDuplicates(configurations);<br><span class="hljs-comment">//移除不符合条件的配置类</span><br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br><span class="hljs-comment">//移除不符合元数据要求的类</span><br>configurations = filter(configurations, autoConfigurationMetadata);<br><span class="hljs-comment">//为配置类添加自动事件</span><br><span class="hljs-comment">//为不同的实例添加不同的类加载器</span><br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-comment">//new出和配置类数量相同的容器</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;其中加载配置在函数<code>getCandidateConfigurations();</code>中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;<br>List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),<br>getBeanClassLoader());<br>Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br>+ <span class="hljs-string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);<br><span class="hljs-keyword">return</span> configurations;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>        String factoryTypeName = factoryType.getName();<br>        <span class="hljs-keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>        MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//从META-INF/spring.factories加载配置文件</span><br>                Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<br>                LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();<br>……<br></code></pre></td></tr></table></figure><p>&emsp;SpringFactoriesLoader是Spring的一个工具类，功能是从指定的位置加载配置文件。因此，</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
